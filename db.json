{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"6f1ac954be2d843e2e0a11bc575ba5609dff1fa1","modified":1624541909852},{"_id":"source/tags/index.md","hash":"ddcf18e0327d52c7bd3745c396d97068155f9e03","modified":1624541909852},{"_id":"source/categories/index.md","hash":"ae3d0c820e6a13aff3d220f63cbd0b848aeec6fc","modified":1624541909852},{"_id":"source/_posts/Dubbo/Dubbo.md","hash":"e9387627638f70ed7026decf27ef3a00ac0a5613","modified":1624631545522},{"_id":"source/_posts/Hexo/hexo常用命令.md","hash":"8d046788dcbfb76a765ff94a4721218d231072df","modified":1624541909848},{"_id":"source/_posts/MQ/AMQP.md","hash":"85a81cc7e2107b9451ab1baf3321d2a9a32f56a5","modified":1624628226478},{"_id":"source/_posts/MQ/RabbitMQ.md","hash":"be60bca6736f2aa9810441a55af0c5a1a0aa2a06","modified":1624543579529},{"_id":"source/_posts/MQ/消息中间件入门与简介.md","hash":"670f702763b88f6956e68fbd980a1d55a8aee852","modified":1624628226478},{"_id":"source/_posts/MySQL/MySQL-基础.md","hash":"74e764262684bb16357633071d3b4fe6a1f5468a","modified":1624628226479},{"_id":"source/_posts/MySQL/MySQL-日志系统.md","hash":"340e7e2ec034c4c15c1a49d9d6f03c91b4315b22","modified":1624628226480},{"_id":"source/_posts/Markdown/Markdown语法.md","hash":"72e7def381dc826cd0dfa414ace4e8baab56526d","modified":1624541909851},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1624541909853},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1624541909853},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1624541909853},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1624541909857},{"_id":"themes/next/.gitignore","hash":"d9021ac0041b511356fc7044cb02c6e0e567d706","modified":1624541909857},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1624541909857},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1624541909857},{"_id":"themes/next/_config.yml","hash":"9fb845137b6842574b0d19a534efa63368b9d5c7","modified":1624544664514},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1624541909857},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1624541909858},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1624541909864},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1624541909885},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1624541909854},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1624541909855},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1624541909853},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1624541909855},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1624541909855},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1624541909856},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1624541909855},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1624541909856},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1624541909856},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1624541909858},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1624541909856},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1624541909859},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1624541909856},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1624541909859},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1624541909859},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1624541909859},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1624541909860},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1624541909860},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1624541909860},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1624541909859},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1624541909864},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1624541909864},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1624541909864},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1624541909864},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1624541909865},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1624541909865},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1624541909865},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1624541909865},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1624541909866},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1624541909866},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1624541909866},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1624541909866},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1624541909866},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1624541909866},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1624541909867},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1624541909867},{"_id":"themes/next/languages/tr.yml","hash":"46e09f2119cbfbcf93fb8dbd267dccabeb8b0cda","modified":1624541909867},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1624541909867},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1624541909867},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1624541909868},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1624541909868},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1624541909868},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1624541909868},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1624541909884},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1624541909884},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1624541909884},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1624541909884},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1624541909884},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1624541909885},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1624541909890},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1624541909854},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1624541909854},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1624541909855},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1624541909854},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1624541909860},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1624541909861},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1624541909861},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1624541909861},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1624541909861},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1624541909862},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1624541909862},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1624541909862},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1624541909862},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1624541909863},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1624541909863},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1624541909863},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1624541909863},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"c459531bba73a11ce84435d2c91f105ecd0e310a","modified":1624541909869},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1624541909869},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1624541909869},{"_id":"themes/next/layout/_macro/post.swig","hash":"60d4ab526812d93ad17e44e51ddaf5d7d4e06475","modified":1624541909869},{"_id":"themes/next/layout/_partials/footer.swig","hash":"9924245c199e8c4e2db3c223153486e7caf2268d","modified":1624541909870},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1624541909871},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1624541909872},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1624541909875},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1624541909874},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1624541909875},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1624541909875},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1624541909876},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1624541909877},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"bd9ba0bf60cc3008ee14339fa395ee6af188e879","modified":1624541909878},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1624541909880},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1624541909881},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1624541909881},{"_id":"themes/next/scripts/events/index.js","hash":"7baf362743b3d30626066614d877891fc140c502","modified":1624541909885},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1624541909888},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1624541909888},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1624541909888},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1624541909889},{"_id":"themes/next/scripts/filters/post.js","hash":"cf5b0db0a9271687f7a21bc581ae87addd8f0767","modified":1624541909889},{"_id":"themes/next/scripts/helpers/engine.js","hash":"6abda91b431c9b6f6cd2adfa665e694cfdb171be","modified":1624541909889},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1624541909889},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1624541909890},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1624541909890},{"_id":"themes/next/scripts/tags/button.js","hash":"178d3efb8d2c1aca606181894c352fc65c40c32a","modified":1624541909890},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1624541909890},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e11a738ee77c4304add79c964bdec3715c45653a","modified":1624541909891},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1624541909891},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1624541909891},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1624541909891},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1624541909891},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1624541909892},{"_id":"themes/next/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1624541909892},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1624541909892},{"_id":"themes/next/source/css/_colors.styl","hash":"9d65353ca8c634eb96142dcee1b36b6f1004522a","modified":1624541909893},{"_id":"themes/next/source/css/_mixins.styl","hash":"cf81a6731aa436e7bb8d9a743b01f62107e27dd3","modified":1624541909908},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1624541909914},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1624541909914},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1624541909914},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1624541909915},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1624541909915},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1624541909915},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1624541909915},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1624541909916},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1624541909916},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1624541909916},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1624541909916},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1624541909916},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1624541909917},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1624541909917},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1624541909917},{"_id":"themes/next/source/js/algolia-search.js","hash":"f0cee802b4d48d5e78ba88d77d4257cb8a88dd6e","modified":1624541909918},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1624541909917},{"_id":"themes/next/source/js/bookmark.js","hash":"2268bfcab8cf9019e590e2d356b08a3d4a0cf791","modified":1624541909918},{"_id":"themes/next/source/js/local-search.js","hash":"8f046860139f8dc7d1b445290a19e391800ff322","modified":1624541909918},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1624541909918},{"_id":"themes/next/source/js/next-boot.js","hash":"509c5b02446d4989a6ef3081cafeb9497cdde4e5","modified":1624541909918},{"_id":"themes/next/source/js/utils.js","hash":"c00a94e206cca6e973b13bb53585b61646f4585b","modified":1624541909919},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1624541909920},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"ca1b16202403515550f57b51dccb19afcb10ccf1","modified":1624541909870},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1624541909870},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1624541909870},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1624541909871},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"6a3901962ad7e698640a288be627947de90de1f6","modified":1624541909871},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"11acd6b585eeb823358e642c7dde7d637fda706f","modified":1624541909871},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1624541909871},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1624541909872},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1624541909872},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"deffa919e72da6c2cdc2f32d403c809916bd36d1","modified":1624541909873},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1624541909873},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"5fd5ba53962aefccb43b1d2b306a534add2373e1","modified":1624541909872},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1624541909873},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1624541909873},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1624541909873},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1624541909874},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1624541909874},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"d1b9a43bdfaf2b151cce1a74d23e65c2e488e41b","modified":1624541909874},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1624541909875},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1624541909876},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1624541909876},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1624541909876},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1624541909876},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1624541909877},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1624541909877},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1624541909878},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1624541909878},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1624541909878},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1624541909879},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1624541909879},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1624541909879},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1624541909879},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1624541909880},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1624541909880},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1624541909880},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1624541909880},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1624541909881},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1624541909881},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1624541909881},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1624541909882},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1624541909882},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"5b5618c2f6ad1d7971e6db257222fce89aa56565","modified":1624541909882},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1624541909882},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1624541909883},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1624541909883},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1624541909883},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1624541909884},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1624541909886},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1624541909883},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1624541909886},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1624541909886},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"d002c9eea7e7dd31b64a4172012d4294489974d5","modified":1624541909887},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"31a6c8fbdfa16112b0b099727437b9df7641d421","modified":1624541909887},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1624541909887},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"14917c0f9ac76b50296e64437316cba0966c61d1","modified":1624541909887},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1624541909887},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1624541909888},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1624541909888},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"7ff11f64f4315d06ba585928fc9a8bc3761894a5","modified":1624541909888},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1624541909913},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1624541909913},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fa086b75ff09268e22adf6cb36b2b6720306d824","modified":1624541909914},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1624541909913},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"93625aa12a40482fe911e350758f9b4abe4546ff","modified":1624541909913},{"_id":"themes/next/source/js/schemes/muse.js","hash":"78c77614b9fe0d7d97aa08468c6cffbcbda96b75","modified":1624541909919},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"1a9741145938e2c754a808381350723cbebf43c5","modified":1624541909919},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1624541909920},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1624541909920},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1624541909920},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1624541909921},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1624541909921},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1624541909925},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1624541909925},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1624541909893},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1624541909893},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1624541909893},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1624541909897},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1624541909902},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1624541909902},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6471369bd120986f4afad25ad1216f9c4e8405d5","modified":1624541909904},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1624541909904},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1624541909905},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1624541909906},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1624541909906},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1624541909906},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"7ed4733240206d1aa729c835e69a85f8f3c73cd6","modified":1624541909906},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1624541909908},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1624541909909},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1624541909909},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1624541909909},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1624541909909},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1624541909910},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1624541909910},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1624541909912},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1624541909912},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"919068c7db32bfee26238e3a783efe14b3060d63","modified":1624541909912},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"c9df5ee78b46f4a2926e6e88fbe1ba1a9a75aecc","modified":1624541909912},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1624541909913},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"315eea625a90a19421b6d6413322ae40bb5ad4c6","modified":1624541909912},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1624541909910},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1624541909910},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"83b7104a319cfbf6af3548f354240eb07dd73d38","modified":1624541909911},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1624541909911},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1624541909911},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1624541909911},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1624541909921},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1624541909921},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1624541909922},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1624541909894},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1624541909894},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1624541909894},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"a22c639cdf1073c9d060af62233125991ddf4dd5","modified":1624541909895},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"66001b7624ca044f9c06e75036f0e6e4b091b094","modified":1624541909894},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"5912a1676a973b6d9291b43aec6aeeef6871d1ed","modified":1624541909895},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1624541909895},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1624541909895},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1624541909896},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1624541909896},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1624541909896},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"44749e3f07a328d81a959708316494d3d737ab57","modified":1624541909896},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"81b2bbd6fb590101a089bc390ed4934f5c462215","modified":1624541909896},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"82a275ca74086a46b8e82d5ebf78c7a807cd9c8b","modified":1624541909897},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1624541909897},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1624541909897},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1624541909898},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1624541909897},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1624541909897},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1624541909898},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1624541909898},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1624541909899},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1624541909899},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1624541909900},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"f7977cfacaca9db6fab4d154486ad57ec4b0fde9","modified":1624541909900},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1624541909900},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1624541909901},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1624541909901},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1624541909901},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"73c578914052e11392cd4364af9075b66832b793","modified":1624541909901},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1624541909901},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1624541909902},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1624541909902},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1624541909903},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1624541909903},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1624541909903},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"0812ae7ecd1d8c60ec4290f506ec10881ed0fca8","modified":1624541909903},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1624541909903},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1624541909903},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1624541909904},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1624541909905},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1624541909904},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1624541909905},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1624541909906},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1624541909905},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"8c318a485c56dbdcdb22fd00781484ecc151bf8a","modified":1624541909907},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1624541909907},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1624541909907},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1624541909907},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"9d1f42d01f6e346b61f83cdd4f5fbd3bf8e44968","modified":1624541909907},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1624541909908},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1624541909908},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1624541909924},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1624541909924},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1624541909923}],"Category":[{"name":"hexo","_id":"ckqcfpmji0004howm0jvn2kyh"},{"name":"MQ","_id":"ckqcfpmjk0007howm88q04ed4"},{"name":"Markdown","_id":"ckqcfpmjo000fhowmhdwzawd2"},{"name":"MySQL","_id":"ckqcfpmjp000mhowm082w0j12"},{"name":"Dubbo","_id":"ckqcfpmka000uhowm7g6l34em"}],"Data":[],"Page":[{"title":"关于","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ntype: \"about\"\n---\n","date":"2021-06-24T13:38:29.852Z","updated":"2021-06-24T13:38:29.852Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckqcfpmjd0000howm6qo61po7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\n---\n","date":"2021-06-24T13:38:29.852Z","updated":"2021-06-24T13:38:29.852Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckqcfpmjh0002howm9fnta4tg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\n---\n","date":"2021-06-24T13:38:29.852Z","updated":"2021-06-24T13:38:29.852Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckqcfpmjj0006howm2jm907qe","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"hexo常用命令.md","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","source":"_posts/Hexo/hexo常用命令.md","raw":"---\ntitle: hexo常用命令.md\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: hexo\ncategories: hexo\n---\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","slug":"Hexo/hexo常用命令","published":1,"updated":"2021-06-24T13:38:29.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqcfpmjf0001howm27ymayqm","content":"<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<span id=\"more\"></span>\n\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>","more":"<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"RabbitMQ","date":"2021-06-21T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\naaaaa","source":"_posts/MQ/RabbitMQ.md","raw":"---\ntitle: RabbitMQ\ndate: 2021-06-22 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: MQ\ncategories: MQ\n---\n\naaaaa","slug":"MQ/RabbitMQ","published":1,"updated":"2021-06-24T14:06:19.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqcfpmjh0003howm2fbcfsy1","content":"<p>aaaaa</p>\n","site":{"data":{}},"excerpt":"","more":"<p>aaaaa</p>\n"},{"title":"Markdown语法","date":"2021-04-30T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Markdown标题\n\n## 使用 = 和 - 表示一级和二级标题\n\n= 和 - 标记语法格式如下：\n```\n\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n---------------\n\n```\n\n***\n\n<!-- more -->\n\n## 使用 # 号标记\n\n使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n\n```\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n```\n\n***\n\n# Markdown 段落格式\n\n## 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg)\n\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg)\n\n***\n\n## 字体\n\nMarkdown 可以使用以下几种字体：\n```\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/md3.gif)\n\n***\n\n## 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n```\n***\n\n* * *\n\n*****\n\n- - -\n\n----------\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg)\n\n*****\n\n## 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n```\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg)\n\n*****\n\n## 下划线\n\n下划线可以通过 HTML 的 <u> 标签来实现：\n```\n<u>带下划线文本</u>\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg)\n\n*****\n\n## 脚注\n\n脚注是对文本的补充说明。  \nMarkdown 脚注的格式如下:\n```\n[^要注明的文本]\n```\n\n以下实例演示了脚注的用法：\n```\n创建脚注格式类似这样 [^RUNOOB]。\n\n[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\n```\n\n演示效果如下：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/md5.gif)","source":"_posts/Markdown/Markdown语法.md","raw":"---\ntitle: Markdown语法\ndate: 2021-05-01 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: Markdown\ncategories: Markdown\n---\n\n# Markdown标题\n\n## 使用 = 和 - 表示一级和二级标题\n\n= 和 - 标记语法格式如下：\n```\n\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n---------------\n\n```\n\n***\n\n<!-- more -->\n\n## 使用 # 号标记\n\n使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n\n```\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n```\n\n***\n\n# Markdown 段落格式\n\n## 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg)\n\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg)\n\n***\n\n## 字体\n\nMarkdown 可以使用以下几种字体：\n```\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/md3.gif)\n\n***\n\n## 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n```\n***\n\n* * *\n\n*****\n\n- - -\n\n----------\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg)\n\n*****\n\n## 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n```\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg)\n\n*****\n\n## 下划线\n\n下划线可以通过 HTML 的 <u> 标签来实现：\n```\n<u>带下划线文本</u>\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg)\n\n*****\n\n## 脚注\n\n脚注是对文本的补充说明。  \nMarkdown 脚注的格式如下:\n```\n[^要注明的文本]\n```\n\n以下实例演示了脚注的用法：\n```\n创建脚注格式类似这样 [^RUNOOB]。\n\n[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\n```\n\n演示效果如下：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/md5.gif)","slug":"Markdown/Markdown语法","published":1,"updated":"2021-06-24T13:38:29.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqcfpmjm000dhowm7avefaes","content":"<h1 id=\"Markdown标题\"><a href=\"#Markdown标题\" class=\"headerlink\" title=\"Markdown标题\"></a>Markdown标题</h1><h2 id=\"使用-和-表示一级和二级标题\"><a href=\"#使用-和-表示一级和二级标题\" class=\"headerlink\" title=\"使用 = 和 - 表示一级和二级标题\"></a>使用 = 和 - 表示一级和二级标题</h2><p>= 和 - 标记语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">我展示的是一级标题</span><br><span class=\"line\">=================</span><br><span class=\"line\"></span><br><span class=\"line\">我展示的是二级标题</span><br><span class=\"line\">---------------</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<span id=\"more\"></span>\n\n<h2 id=\"使用-号标记\"><a href=\"#使用-号标记\" class=\"headerlink\" title=\"使用 # 号标记\"></a>使用 # 号标记</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"Markdown-段落格式\"><a href=\"#Markdown-段落格式\" class=\"headerlink\" title=\"Markdown 段落格式\"></a>Markdown 段落格式</h1><h2 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg\" alt=\"效果图\"></p>\n<p>当然也可以在段落后面使用一个空行来表示重新开始一个段落。<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体文本*</span><br><span class=\"line\">_斜体文本_</span><br><span class=\"line\">**粗体文本**</span><br><span class=\"line\">__粗体文本__</span><br><span class=\"line\">***粗斜体文本***</span><br><span class=\"line\">___粗斜体文本___</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/md3.gif\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">***</span><br><span class=\"line\"></span><br><span class=\"line\">* * *</span><br><span class=\"line\"></span><br><span class=\"line\">*****</span><br><span class=\"line\"></span><br><span class=\"line\">- - -</span><br><span class=\"line\"></span><br><span class=\"line\">----------</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUNOOB.COM</span><br><span class=\"line\">GOOGLE.COM</span><br><span class=\"line\">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>下划线可以通过 HTML 的 <u> 标签来实现：</u></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚注是对文本的补充说明。<br>Markdown 脚注的格式如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[^要注明的文本]</span><br></pre></td></tr></table></figure>\n\n<p>以下实例演示了脚注的用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建脚注格式类似这样 [^RUNOOB]。</span><br><span class=\"line\"></span><br><span class=\"line\">[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span><br></pre></td></tr></table></figure>\n\n<p>演示效果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/md5.gif\" alt=\"效果图\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Markdown标题\"><a href=\"#Markdown标题\" class=\"headerlink\" title=\"Markdown标题\"></a>Markdown标题</h1><h2 id=\"使用-和-表示一级和二级标题\"><a href=\"#使用-和-表示一级和二级标题\" class=\"headerlink\" title=\"使用 = 和 - 表示一级和二级标题\"></a>使用 = 和 - 表示一级和二级标题</h2><p>= 和 - 标记语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">我展示的是一级标题</span><br><span class=\"line\">=================</span><br><span class=\"line\"></span><br><span class=\"line\">我展示的是二级标题</span><br><span class=\"line\">---------------</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>","more":"<h2 id=\"使用-号标记\"><a href=\"#使用-号标记\" class=\"headerlink\" title=\"使用 # 号标记\"></a>使用 # 号标记</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"Markdown-段落格式\"><a href=\"#Markdown-段落格式\" class=\"headerlink\" title=\"Markdown 段落格式\"></a>Markdown 段落格式</h1><h2 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg\" alt=\"效果图\"></p>\n<p>当然也可以在段落后面使用一个空行来表示重新开始一个段落。<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体文本*</span><br><span class=\"line\">_斜体文本_</span><br><span class=\"line\">**粗体文本**</span><br><span class=\"line\">__粗体文本__</span><br><span class=\"line\">***粗斜体文本***</span><br><span class=\"line\">___粗斜体文本___</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/md3.gif\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">***</span><br><span class=\"line\"></span><br><span class=\"line\">* * *</span><br><span class=\"line\"></span><br><span class=\"line\">*****</span><br><span class=\"line\"></span><br><span class=\"line\">- - -</span><br><span class=\"line\"></span><br><span class=\"line\">----------</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUNOOB.COM</span><br><span class=\"line\">GOOGLE.COM</span><br><span class=\"line\">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>下划线可以通过 HTML 的 <u> 标签来实现：</u></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg\" alt=\"效果图\"></p>\n<hr>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚注是对文本的补充说明。<br>Markdown 脚注的格式如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[^要注明的文本]</span><br></pre></td></tr></table></figure>\n\n<p>以下实例演示了脚注的用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建脚注格式类似这样 [^RUNOOB]。</span><br><span class=\"line\"></span><br><span class=\"line\">[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span><br></pre></td></tr></table></figure>\n\n<p>演示效果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/md5.gif\" alt=\"效果图\"></p>"},{"title":"AMQP","date":"2021-06-20T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# AMQP是什么\n\nAMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。\n\n在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。\n\n***\n\n<!-- more -->\n\n# 2.AMQP模型\n\n## 2.1.AMQP模型\n\n![AMQP模型](https://rong0624.github.io/images/MQ/amqp模型.png)\n\n1）Broker  \n表示消息队列服务器实体（一个进程）。  \n一个server，接受客户端的连接，上线AMQP实体服务。  \n\n2）Connection  \n连接  \n应用程序与broker的网络连接，TCP/IP套接字连接。  \n\n3）Channel  \n消息通道  \n几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个  \nChannel，每个Channel代表一个会话任务。\n\n4）Message  \n消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）> ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等\n\n5）Exchange  \n交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。\n\n6）Queue  \n消息队列，存储消息，用于发送给消费者。  \n它是消息的容器，也是消息的终点。一个消息可以投入多个队列。  \n消息一直在队列里面，等待消费者连接到这个队列将其取走。\n\n7）Binding  \n绑定，消息队列和交换器之间的关联。  \n一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n\n8）Routing Key  \n路由关键字  \n一个消息头，交换机可以用这个消息头决定如何路由某条消息。\n\n9）Publisher  \n消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。\n\n10）Consumer  \n消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。\n\n11）Virtual Host  \n虚拟主机\n\n***\n\n## 2.2.工作过程\n\n生产者发布消息流程：  \n1、生产者和Broker建立TCP连接。  \n2、生产者和Broker建立通道。  \n3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。  \n4、Exchange将消息转发到指定的Queue（队列）  \n\n消费者消费消息流程：  \n1、消费者和Broker建立TCP连接  \n2、消费者和Broker建立通道  \n3、消费者监听指定的Queue（队列）  \n4、当有消息到达Queue时Broker默认将消息推送给消费者。  \n5、消费者接收到消息。  \n6、ack回复  \n\n***\n\n# Exchange交换机\n\n## 默认交换机（default exchange）\n\n默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。\n\n它有一个特殊属性使得它对于简单应用特别有用处：\n那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。\n\n举个栗子：当你声明了一个名为\"search-indexing-online\"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为\"search-indexing-online\"。因此，当携带着名为\"search-indexing-online\"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为\"search-indexing-online\"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。\n\n***\n\n## 直连交换机（direct exchange）\n\n直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。\n\n下面介绍它是如何工作的：  \n1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）  \n2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。\n\n直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。  \n比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。\n\n直连型交换机图例：  \n![直连交换机图解](https://rong0624.github.io/images/MQ/直连交换机图解.png)\n\n当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。\n\n如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。\n\n***\n\n## 扇型交换机（funout exchange）\n\n扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。\n\n因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：\n* 1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件\n* 2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端\n* 3）分发系统使用它来广播各种状态和配置更新\n* 4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）\n\n扇型交换机图例：  \n![扇型交换机图解](https://rong0624.github.io/images/MQ/扇型交换机图解.png)\n\n上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。\n\n***\n\n## 主题交换机（topic exchanges）\n\n主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。\n\n主题交换机规则：  \n前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.  \n而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  \n\n它的约定是：  \n1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）   \n2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.> nyse”、“nyse.vmw”、“quick.> orange.rabbit”  \n3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串\n\n主题交换机图例：  \n![主题交换机图解](https://rong0624.github.io/images/MQ/主题交换机图解.png)\n\n当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。\n\n***\n\n### 使用场景\n\n主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。\n\n使用案例：  \n1）分发有关于特定地理位置的数据，例如销售点  \n2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务  \n3）股票价格更新（以及其他类型的金融数据更新）  \n4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）  \n5）云端的不同种类服务的协调  \n6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。\n\n***\n\n## 头交换机（headers exchanges）\n\n有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。\n\n我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是\"x-match\"参数。当\"x-match\"设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当\"x-match\"设置为“all”的时候，就需要消息头的所有值都匹配成功。\n\n头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。\n\n***\n\n# Queue队列\n\nAMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。\n\n## 队列属性\n\n队列跟交换机共享某些属性，但是队列也有一些另外的属性。  \n1）Name  \n2）Durable（消息代理重启后，队列依旧存在）  \n3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）  \n4）Auto-delete（当最后一个消费者退订后即被删除）  \n5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  \n\n***\n\n## 队列创建\n\n队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。\n\n***\n\n## 队列名称\n\n队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。\n以\"amq.\"开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。\n\n***\n\n## 队列持久化\n\n持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。  \n持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。\n\n***\n\n# Binding绑定\n\n绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\n\n打个比方：  \n队列（queue）是我们想要去的位于纽约的目的地  \n交换机（exchange）是JFK机场  \n绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条  \n拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  \n\n如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。\n\n**最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。**\n\n***\n\n# 消费者\n\n消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。\n\n在AMQP 0-9-1 模型中，有两种途径可以达到此目的：  \n1）将消息投递给应用 (\"push API\")  \n2）应用根据需要主动获取消息 (\"pull API\")\n\n使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。\n\n每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。\n\n***\n\n# 消息机制\n\n## 消息属性\n\nAMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。\n\n例如：  \n1）Content type（内容类型）  \n2）Content encoding（内容编码）  \n3）Routing key（路由键）  \n4）Delivery mode (persistent or not)  \n5）投递模式（持久化 或 非持久化）  \n6）Message priority（消息优先权）  \n7）Message publishing timestamp（消息发布的时间戳）  \n8）Expiration period（消息有效期）  \n9）Publisher application id（发布应用的 ID）  \n\n有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。\n\n***\n\n## 消息主体\nAMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。\n\n消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。\n\n***\n\n## 消息持久化\n\n消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。\n\n简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。\n\n***\n\n## 消息确认\n\n消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？\n\nAMQP 0-9-1 规范给我们两种建议：  \n1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)  \n2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）\n\n如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。\n\n***\n\n## 拒绝消息\n\n当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。\n\n当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。\n\n当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。\n\n***\n\n## 预取消息\n\n在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）\n\n注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。\n\n***\n\n# 其他\n\n## 连接\n\nAMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。\n\n***\n\n## 通道\n\n有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。\n\n在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。\n\n一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。\n\n***\n\n## 虚拟主机\n\n为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。\n\n***\n\n# 参考资料\n\nhttp://rabbitmq.mr-ping.com/  \nhttps://www.cnblogs.com/dwlsxj/p/RabbitMQ.html","source":"_posts/MQ/AMQP.md","raw":"---\ntitle: AMQP\ndate: 2021-06-21 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: MQ\ncategories: MQ\n---\n\n# AMQP是什么\n\nAMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。\n\n在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。\n\n***\n\n<!-- more -->\n\n# 2.AMQP模型\n\n## 2.1.AMQP模型\n\n![AMQP模型](https://rong0624.github.io/images/MQ/amqp模型.png)\n\n1）Broker  \n表示消息队列服务器实体（一个进程）。  \n一个server，接受客户端的连接，上线AMQP实体服务。  \n\n2）Connection  \n连接  \n应用程序与broker的网络连接，TCP/IP套接字连接。  \n\n3）Channel  \n消息通道  \n几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个  \nChannel，每个Channel代表一个会话任务。\n\n4）Message  \n消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）> ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等\n\n5）Exchange  \n交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。\n\n6）Queue  \n消息队列，存储消息，用于发送给消费者。  \n它是消息的容器，也是消息的终点。一个消息可以投入多个队列。  \n消息一直在队列里面，等待消费者连接到这个队列将其取走。\n\n7）Binding  \n绑定，消息队列和交换器之间的关联。  \n一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n\n8）Routing Key  \n路由关键字  \n一个消息头，交换机可以用这个消息头决定如何路由某条消息。\n\n9）Publisher  \n消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。\n\n10）Consumer  \n消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。\n\n11）Virtual Host  \n虚拟主机\n\n***\n\n## 2.2.工作过程\n\n生产者发布消息流程：  \n1、生产者和Broker建立TCP连接。  \n2、生产者和Broker建立通道。  \n3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。  \n4、Exchange将消息转发到指定的Queue（队列）  \n\n消费者消费消息流程：  \n1、消费者和Broker建立TCP连接  \n2、消费者和Broker建立通道  \n3、消费者监听指定的Queue（队列）  \n4、当有消息到达Queue时Broker默认将消息推送给消费者。  \n5、消费者接收到消息。  \n6、ack回复  \n\n***\n\n# Exchange交换机\n\n## 默认交换机（default exchange）\n\n默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。\n\n它有一个特殊属性使得它对于简单应用特别有用处：\n那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。\n\n举个栗子：当你声明了一个名为\"search-indexing-online\"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为\"search-indexing-online\"。因此，当携带着名为\"search-indexing-online\"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为\"search-indexing-online\"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。\n\n***\n\n## 直连交换机（direct exchange）\n\n直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。\n\n下面介绍它是如何工作的：  \n1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）  \n2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。\n\n直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。  \n比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。\n\n直连型交换机图例：  \n![直连交换机图解](https://rong0624.github.io/images/MQ/直连交换机图解.png)\n\n当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。\n\n如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。\n\n***\n\n## 扇型交换机（funout exchange）\n\n扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。\n\n因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：\n* 1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件\n* 2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端\n* 3）分发系统使用它来广播各种状态和配置更新\n* 4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）\n\n扇型交换机图例：  \n![扇型交换机图解](https://rong0624.github.io/images/MQ/扇型交换机图解.png)\n\n上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。\n\n***\n\n## 主题交换机（topic exchanges）\n\n主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。\n\n主题交换机规则：  \n前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.  \n而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  \n\n它的约定是：  \n1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）   \n2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.> nyse”、“nyse.vmw”、“quick.> orange.rabbit”  \n3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串\n\n主题交换机图例：  \n![主题交换机图解](https://rong0624.github.io/images/MQ/主题交换机图解.png)\n\n当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。\n\n***\n\n### 使用场景\n\n主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。\n\n使用案例：  \n1）分发有关于特定地理位置的数据，例如销售点  \n2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务  \n3）股票价格更新（以及其他类型的金融数据更新）  \n4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）  \n5）云端的不同种类服务的协调  \n6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。\n\n***\n\n## 头交换机（headers exchanges）\n\n有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。\n\n我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是\"x-match\"参数。当\"x-match\"设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当\"x-match\"设置为“all”的时候，就需要消息头的所有值都匹配成功。\n\n头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。\n\n***\n\n# Queue队列\n\nAMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。\n\n## 队列属性\n\n队列跟交换机共享某些属性，但是队列也有一些另外的属性。  \n1）Name  \n2）Durable（消息代理重启后，队列依旧存在）  \n3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）  \n4）Auto-delete（当最后一个消费者退订后即被删除）  \n5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  \n\n***\n\n## 队列创建\n\n队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。\n\n***\n\n## 队列名称\n\n队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。\n以\"amq.\"开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。\n\n***\n\n## 队列持久化\n\n持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。  \n持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。\n\n***\n\n# Binding绑定\n\n绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\n\n打个比方：  \n队列（queue）是我们想要去的位于纽约的目的地  \n交换机（exchange）是JFK机场  \n绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条  \n拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  \n\n如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。\n\n**最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。**\n\n***\n\n# 消费者\n\n消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。\n\n在AMQP 0-9-1 模型中，有两种途径可以达到此目的：  \n1）将消息投递给应用 (\"push API\")  \n2）应用根据需要主动获取消息 (\"pull API\")\n\n使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。\n\n每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。\n\n***\n\n# 消息机制\n\n## 消息属性\n\nAMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。\n\n例如：  \n1）Content type（内容类型）  \n2）Content encoding（内容编码）  \n3）Routing key（路由键）  \n4）Delivery mode (persistent or not)  \n5）投递模式（持久化 或 非持久化）  \n6）Message priority（消息优先权）  \n7）Message publishing timestamp（消息发布的时间戳）  \n8）Expiration period（消息有效期）  \n9）Publisher application id（发布应用的 ID）  \n\n有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。\n\n***\n\n## 消息主体\nAMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。\n\n消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。\n\n***\n\n## 消息持久化\n\n消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。\n\n简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。\n\n***\n\n## 消息确认\n\n消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？\n\nAMQP 0-9-1 规范给我们两种建议：  \n1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)  \n2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）\n\n如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。\n\n***\n\n## 拒绝消息\n\n当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。\n\n当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。\n\n当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。\n\n***\n\n## 预取消息\n\n在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）\n\n注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。\n\n***\n\n# 其他\n\n## 连接\n\nAMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。\n\n***\n\n## 通道\n\n有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。\n\n在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。\n\n一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。\n\n***\n\n## 虚拟主机\n\n为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。\n\n***\n\n# 参考资料\n\nhttp://rabbitmq.mr-ping.com/  \nhttps://www.cnblogs.com/dwlsxj/p/RabbitMQ.html","slug":"MQ/AMQP","published":1,"updated":"2021-06-25T13:37:06.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqcfpmjn000ehowmfqg73yzt","content":"<h1 id=\"AMQP是什么\"><a href=\"#AMQP是什么\" class=\"headerlink\" title=\"AMQP是什么\"></a>AMQP是什么</h1><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>\n<p>在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。</p>\n<hr>\n<span id=\"more\"></span>\n\n<h1 id=\"2-AMQP模型\"><a href=\"#2-AMQP模型\" class=\"headerlink\" title=\"2.AMQP模型\"></a>2.AMQP模型</h1><h2 id=\"2-1-AMQP模型\"><a href=\"#2-1-AMQP模型\" class=\"headerlink\" title=\"2.1.AMQP模型\"></a>2.1.AMQP模型</h2><p><img src=\"https://rong0624.github.io/images/MQ/amqp%E6%A8%A1%E5%9E%8B.png\" alt=\"AMQP模型\"></p>\n<p>1）Broker<br>表示消息队列服务器实体（一个进程）。<br>一个server，接受客户端的连接，上线AMQP实体服务。  </p>\n<p>2）Connection<br>连接<br>应用程序与broker的网络连接，TCP/IP套接字连接。  </p>\n<p>3）Channel<br>消息通道<br>几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个<br>Channel，每个Channel代表一个会话任务。</p>\n<p>4）Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）&gt; ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等</p>\n<p>5）Exchange<br>交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。</p>\n<p>6）Queue<br>消息队列，存储消息，用于发送给消费者。<br>它是消息的容器，也是消息的终点。一个消息可以投入多个队列。<br>消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>\n<p>7）Binding<br>绑定，消息队列和交换器之间的关联。<br>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>\n<p>8）Routing Key<br>路由关键字<br>一个消息头，交换机可以用这个消息头决定如何路由某条消息。</p>\n<p>9）Publisher<br>消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。</p>\n<p>10）Consumer<br>消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。</p>\n<p>11）Virtual Host<br>虚拟主机</p>\n<hr>\n<h2 id=\"2-2-工作过程\"><a href=\"#2-2-工作过程\" class=\"headerlink\" title=\"2.2.工作过程\"></a>2.2.工作过程</h2><p>生产者发布消息流程：<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）  </p>\n<p>消费者消费消息流程：<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。<br>6、ack回复  </p>\n<hr>\n<h1 id=\"Exchange交换机\"><a href=\"#Exchange交换机\" class=\"headerlink\" title=\"Exchange交换机\"></a>Exchange交换机</h1><h2 id=\"默认交换机（default-exchange）\"><a href=\"#默认交换机（default-exchange）\" class=\"headerlink\" title=\"默认交换机（default exchange）\"></a>默认交换机（default exchange）</h2><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。</p>\n<p>它有一个特殊属性使得它对于简单应用特别有用处：<br>那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>\n<p>举个栗子：当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>\n<hr>\n<h2 id=\"直连交换机（direct-exchange）\"><a href=\"#直连交换机（direct-exchange）\" class=\"headerlink\" title=\"直连交换机（direct exchange）\"></a>直连交换机（direct exchange）</h2><p>直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</p>\n<p>下面介绍它是如何工作的：<br>1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）<br>2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</p>\n<p>直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。<br>比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</p>\n<p>直连型交换机图例：<br><img src=\"https://rong0624.github.io/images/MQ/%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"直连交换机图解\"></p>\n<p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p>\n<p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p>\n<hr>\n<h2 id=\"扇型交换机（funout-exchange）\"><a href=\"#扇型交换机（funout-exchange）\" class=\"headerlink\" title=\"扇型交换机（funout exchange）\"></a>扇型交换机（funout exchange）</h2><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>\n<p>因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：</p>\n<ul>\n<li>1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件</li>\n<li>2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li>\n<li>3）分发系统使用它来广播各种状态和配置更新</li>\n<li>4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）</li>\n</ul>\n<p>扇型交换机图例：<br><img src=\"https://rong0624.github.io/images/MQ/%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"扇型交换机图解\"></p>\n<p>上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p>\n<hr>\n<h2 id=\"主题交换机（topic-exchanges）\"><a href=\"#主题交换机（topic-exchanges）\" class=\"headerlink\" title=\"主题交换机（topic exchanges）\"></a>主题交换机（topic exchanges）</h2><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>\n<p>主题交换机规则：<br>前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.<br>而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  </p>\n<p>它的约定是：<br>1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）<br>2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.&gt; nyse”、“nyse.vmw”、“quick.&gt; orange.rabbit”<br>3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串</p>\n<p>主题交换机图例：<br><img src=\"https://rong0624.github.io/images/MQ/%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"主题交换机图解\"></p>\n<p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p>\n<hr>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。</p>\n<p>使用案例：<br>1）分发有关于特定地理位置的数据，例如销售点<br>2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务<br>3）股票价格更新（以及其他类型的金融数据更新）<br>4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）<br>5）云端的不同种类服务的协调<br>6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</p>\n<hr>\n<h2 id=\"头交换机（headers-exchanges）\"><a href=\"#头交换机（headers-exchanges）\" class=\"headerlink\" title=\"头交换机（headers exchanges）\"></a>头交换机（headers exchanges）</h2><p>有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</p>\n<p>我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是”x-match”参数。当”x-match”设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当”x-match”设置为“all”的时候，就需要消息头的所有值都匹配成功。</p>\n<p>头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p>\n<hr>\n<h1 id=\"Queue队列\"><a href=\"#Queue队列\" class=\"headerlink\" title=\"Queue队列\"></a>Queue队列</h1><p>AMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。</p>\n<h2 id=\"队列属性\"><a href=\"#队列属性\" class=\"headerlink\" title=\"队列属性\"></a>队列属性</h2><p>队列跟交换机共享某些属性，但是队列也有一些另外的属性。<br>1）Name<br>2）Durable（消息代理重启后，队列依旧存在）<br>3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）<br>4）Auto-delete（当最后一个消费者退订后即被删除）<br>5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  </p>\n<hr>\n<h2 id=\"队列创建\"><a href=\"#队列创建\" class=\"headerlink\" title=\"队列创建\"></a>队列创建</h2><p>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。</p>\n<hr>\n<h2 id=\"队列名称\"><a href=\"#队列名称\" class=\"headerlink\" title=\"队列名称\"></a>队列名称</h2><p>队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。<br>以”amq.”开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。</p>\n<hr>\n<h2 id=\"队列持久化\"><a href=\"#队列持久化\" class=\"headerlink\" title=\"队列持久化\"></a>队列持久化</h2><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。<br>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>\n<hr>\n<h1 id=\"Binding绑定\"><a href=\"#Binding绑定\" class=\"headerlink\" title=\"Binding绑定\"></a>Binding绑定</h1><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>\n<p>打个比方：<br>队列（queue）是我们想要去的位于纽约的目的地<br>交换机（exchange）是JFK机场<br>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条<br>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  </p>\n<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>\n<p><strong>最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。</strong></p>\n<hr>\n<h1 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h1><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。</p>\n<p>在AMQP 0-9-1 模型中，有两种途径可以达到此目的：<br>1）将消息投递给应用 (“push API”)<br>2）应用根据需要主动获取消息 (“pull API”)</p>\n<p>使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p>\n<p>每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。</p>\n<hr>\n<h1 id=\"消息机制\"><a href=\"#消息机制\" class=\"headerlink\" title=\"消息机制\"></a>消息机制</h1><h2 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h2><p>AMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。</p>\n<p>例如：<br>1）Content type（内容类型）<br>2）Content encoding（内容编码）<br>3）Routing key（路由键）<br>4）Delivery mode (persistent or not)<br>5）投递模式（持久化 或 非持久化）<br>6）Message priority（消息优先权）<br>7）Message publishing timestamp（消息发布的时间戳）<br>8）Expiration period（消息有效期）<br>9）Publisher application id（发布应用的 ID）  </p>\n<p>有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。</p>\n<hr>\n<h2 id=\"消息主体\"><a href=\"#消息主体\" class=\"headerlink\" title=\"消息主体\"></a>消息主体</h2><p>AMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。</p>\n<p>消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>\n<hr>\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><p>消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。</p>\n<p>简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>\n<hr>\n<h2 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h2><p>消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？</p>\n<p>AMQP 0-9-1 规范给我们两种建议：<br>1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)<br>2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）</p>\n<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。</p>\n<hr>\n<h2 id=\"拒绝消息\"><a href=\"#拒绝消息\" class=\"headerlink\" title=\"拒绝消息\"></a>拒绝消息</h2><p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。</p>\n<p>当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。</p>\n<p>当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>\n<hr>\n<h2 id=\"预取消息\"><a href=\"#预取消息\" class=\"headerlink\" title=\"预取消息\"></a>预取消息</h2><p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）</p>\n<p>注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p>\n<hr>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>AMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p>\n<hr>\n<h2 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h2><p>有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。</p>\n<p>在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。</p>\n<p>一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p>\n<hr>\n<h2 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h2><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。</p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://rabbitmq.mr-ping.com/\">http://rabbitmq.mr-ping.com/</a><br><a href=\"https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html\">https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"AMQP是什么\"><a href=\"#AMQP是什么\" class=\"headerlink\" title=\"AMQP是什么\"></a>AMQP是什么</h1><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>\n<p>在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。</p>\n<hr>","more":"<h1 id=\"2-AMQP模型\"><a href=\"#2-AMQP模型\" class=\"headerlink\" title=\"2.AMQP模型\"></a>2.AMQP模型</h1><h2 id=\"2-1-AMQP模型\"><a href=\"#2-1-AMQP模型\" class=\"headerlink\" title=\"2.1.AMQP模型\"></a>2.1.AMQP模型</h2><p><img src=\"https://rong0624.github.io/images/MQ/amqp%E6%A8%A1%E5%9E%8B.png\" alt=\"AMQP模型\"></p>\n<p>1）Broker<br>表示消息队列服务器实体（一个进程）。<br>一个server，接受客户端的连接，上线AMQP实体服务。  </p>\n<p>2）Connection<br>连接<br>应用程序与broker的网络连接，TCP/IP套接字连接。  </p>\n<p>3）Channel<br>消息通道<br>几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个<br>Channel，每个Channel代表一个会话任务。</p>\n<p>4）Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）&gt; ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等</p>\n<p>5）Exchange<br>交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。</p>\n<p>6）Queue<br>消息队列，存储消息，用于发送给消费者。<br>它是消息的容器，也是消息的终点。一个消息可以投入多个队列。<br>消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>\n<p>7）Binding<br>绑定，消息队列和交换器之间的关联。<br>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>\n<p>8）Routing Key<br>路由关键字<br>一个消息头，交换机可以用这个消息头决定如何路由某条消息。</p>\n<p>9）Publisher<br>消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。</p>\n<p>10）Consumer<br>消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。</p>\n<p>11）Virtual Host<br>虚拟主机</p>\n<hr>\n<h2 id=\"2-2-工作过程\"><a href=\"#2-2-工作过程\" class=\"headerlink\" title=\"2.2.工作过程\"></a>2.2.工作过程</h2><p>生产者发布消息流程：<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）  </p>\n<p>消费者消费消息流程：<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。<br>6、ack回复  </p>\n<hr>\n<h1 id=\"Exchange交换机\"><a href=\"#Exchange交换机\" class=\"headerlink\" title=\"Exchange交换机\"></a>Exchange交换机</h1><h2 id=\"默认交换机（default-exchange）\"><a href=\"#默认交换机（default-exchange）\" class=\"headerlink\" title=\"默认交换机（default exchange）\"></a>默认交换机（default exchange）</h2><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。</p>\n<p>它有一个特殊属性使得它对于简单应用特别有用处：<br>那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>\n<p>举个栗子：当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>\n<hr>\n<h2 id=\"直连交换机（direct-exchange）\"><a href=\"#直连交换机（direct-exchange）\" class=\"headerlink\" title=\"直连交换机（direct exchange）\"></a>直连交换机（direct exchange）</h2><p>直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</p>\n<p>下面介绍它是如何工作的：<br>1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）<br>2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</p>\n<p>直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。<br>比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</p>\n<p>直连型交换机图例：<br><img src=\"https://rong0624.github.io/images/MQ/%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"直连交换机图解\"></p>\n<p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p>\n<p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p>\n<hr>\n<h2 id=\"扇型交换机（funout-exchange）\"><a href=\"#扇型交换机（funout-exchange）\" class=\"headerlink\" title=\"扇型交换机（funout exchange）\"></a>扇型交换机（funout exchange）</h2><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>\n<p>因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：</p>\n<ul>\n<li>1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件</li>\n<li>2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li>\n<li>3）分发系统使用它来广播各种状态和配置更新</li>\n<li>4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）</li>\n</ul>\n<p>扇型交换机图例：<br><img src=\"https://rong0624.github.io/images/MQ/%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"扇型交换机图解\"></p>\n<p>上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p>\n<hr>\n<h2 id=\"主题交换机（topic-exchanges）\"><a href=\"#主题交换机（topic-exchanges）\" class=\"headerlink\" title=\"主题交换机（topic exchanges）\"></a>主题交换机（topic exchanges）</h2><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>\n<p>主题交换机规则：<br>前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.<br>而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  </p>\n<p>它的约定是：<br>1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）<br>2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.&gt; nyse”、“nyse.vmw”、“quick.&gt; orange.rabbit”<br>3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串</p>\n<p>主题交换机图例：<br><img src=\"https://rong0624.github.io/images/MQ/%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"主题交换机图解\"></p>\n<p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p>\n<hr>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。</p>\n<p>使用案例：<br>1）分发有关于特定地理位置的数据，例如销售点<br>2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务<br>3）股票价格更新（以及其他类型的金融数据更新）<br>4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）<br>5）云端的不同种类服务的协调<br>6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</p>\n<hr>\n<h2 id=\"头交换机（headers-exchanges）\"><a href=\"#头交换机（headers-exchanges）\" class=\"headerlink\" title=\"头交换机（headers exchanges）\"></a>头交换机（headers exchanges）</h2><p>有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</p>\n<p>我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是”x-match”参数。当”x-match”设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当”x-match”设置为“all”的时候，就需要消息头的所有值都匹配成功。</p>\n<p>头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p>\n<hr>\n<h1 id=\"Queue队列\"><a href=\"#Queue队列\" class=\"headerlink\" title=\"Queue队列\"></a>Queue队列</h1><p>AMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。</p>\n<h2 id=\"队列属性\"><a href=\"#队列属性\" class=\"headerlink\" title=\"队列属性\"></a>队列属性</h2><p>队列跟交换机共享某些属性，但是队列也有一些另外的属性。<br>1）Name<br>2）Durable（消息代理重启后，队列依旧存在）<br>3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）<br>4）Auto-delete（当最后一个消费者退订后即被删除）<br>5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  </p>\n<hr>\n<h2 id=\"队列创建\"><a href=\"#队列创建\" class=\"headerlink\" title=\"队列创建\"></a>队列创建</h2><p>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。</p>\n<hr>\n<h2 id=\"队列名称\"><a href=\"#队列名称\" class=\"headerlink\" title=\"队列名称\"></a>队列名称</h2><p>队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。<br>以”amq.”开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。</p>\n<hr>\n<h2 id=\"队列持久化\"><a href=\"#队列持久化\" class=\"headerlink\" title=\"队列持久化\"></a>队列持久化</h2><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。<br>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>\n<hr>\n<h1 id=\"Binding绑定\"><a href=\"#Binding绑定\" class=\"headerlink\" title=\"Binding绑定\"></a>Binding绑定</h1><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>\n<p>打个比方：<br>队列（queue）是我们想要去的位于纽约的目的地<br>交换机（exchange）是JFK机场<br>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条<br>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  </p>\n<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>\n<p><strong>最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。</strong></p>\n<hr>\n<h1 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h1><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。</p>\n<p>在AMQP 0-9-1 模型中，有两种途径可以达到此目的：<br>1）将消息投递给应用 (“push API”)<br>2）应用根据需要主动获取消息 (“pull API”)</p>\n<p>使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p>\n<p>每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。</p>\n<hr>\n<h1 id=\"消息机制\"><a href=\"#消息机制\" class=\"headerlink\" title=\"消息机制\"></a>消息机制</h1><h2 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h2><p>AMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。</p>\n<p>例如：<br>1）Content type（内容类型）<br>2）Content encoding（内容编码）<br>3）Routing key（路由键）<br>4）Delivery mode (persistent or not)<br>5）投递模式（持久化 或 非持久化）<br>6）Message priority（消息优先权）<br>7）Message publishing timestamp（消息发布的时间戳）<br>8）Expiration period（消息有效期）<br>9）Publisher application id（发布应用的 ID）  </p>\n<p>有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。</p>\n<hr>\n<h2 id=\"消息主体\"><a href=\"#消息主体\" class=\"headerlink\" title=\"消息主体\"></a>消息主体</h2><p>AMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。</p>\n<p>消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>\n<hr>\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><p>消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。</p>\n<p>简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>\n<hr>\n<h2 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h2><p>消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？</p>\n<p>AMQP 0-9-1 规范给我们两种建议：<br>1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)<br>2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）</p>\n<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。</p>\n<hr>\n<h2 id=\"拒绝消息\"><a href=\"#拒绝消息\" class=\"headerlink\" title=\"拒绝消息\"></a>拒绝消息</h2><p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。</p>\n<p>当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。</p>\n<p>当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>\n<hr>\n<h2 id=\"预取消息\"><a href=\"#预取消息\" class=\"headerlink\" title=\"预取消息\"></a>预取消息</h2><p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）</p>\n<p>注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p>\n<hr>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>AMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p>\n<hr>\n<h2 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h2><p>有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。</p>\n<p>在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。</p>\n<p>一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p>\n<hr>\n<h2 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h2><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。</p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://rabbitmq.mr-ping.com/\">http://rabbitmq.mr-ping.com/</a><br><a href=\"https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html\">https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html</a></p>"},{"title":"消息中间件入门与简介","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 什么是中间件\n\n## 什么是中间件\n\n我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。\n\n中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来\n\n***\n\n<!-- more -->\n\n## 中间件特点\n\n为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。\n\n![中间件特点](https://rong0624.github.io/images/MQ/中间件特点.png)\n\n也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：  \n（1）满足大量应用的需要  \n（2）运行于多种硬件和 OS平台  \n（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互  \n（4）支持标准的协议  \n（5）支持标准的接口\n\n由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。\n\n简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。\n\n***\n\n## 常见中间件\n\n![常见中间件](https://rong0624.github.io/images/MQ/常见中间件.png)\n\n***\n\n## 学习中间件的方式和技巧\n\n1）理解中间件在项目架构中的作用，以及各中间件的底层实现  \n2）可以使用一些类比的生活概念去理解中间件  \n3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用  \n4）尝试用 java技术去实现中间件的原理  \n5）静下来去思考中间件在项目中设计的和使用的原因  \n6）如果找到对应的代替总结方案  \n7）尝试编写博文总结类同中间件技术的对比和使用场景  \n8）学会查看中间件的源码以及开源项目和博文\n\n***\n\n# 什么是消息中间件\n\n## 什么是消息中间件\n\n消息中间件：\n是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。\n\n***\n\n## 为什么需要使用消息中间件\n具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。\n\n***\n\n## 消息中间件功能与组成\n\n### 功能\n\n消息中间件：\n是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。\n\nMQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。  \n![常见中间件](https://rong0624.github.io/images/MQ/mq消息队列图解1.png)\n\n谁来生产消息，存储消息和消费消息呢？  \n生产者生产消息，MQ存储消息，消费者消费消息  \n![常见中间件](https://rong0624.github.io/images/MQ/mq消息队列图解2.png)\n\n### 核心组成部分\n\n消息中间件的核心组成部分：  \n消息的协议   \n消息的持久化机制   \n消息的分发策略   \n消息的高可用  \n高可靠消息的容错机制\n\n\n## 消息中间件应用场景\n\n参考：https://www.jianshu.com/p/3fed7e963a2d\n\n***\n\n### 异步通信\n\n异步通信：（异步处理）    \n当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。\n\n案例讲解：  \n假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。  \n![常见中间件](https://rong0624.github.io/images/MQ/并行执行.png)\n\n生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。\n\n按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。  \n过程如下图所示：  \n![常见中间件](https://rong0624.github.io/images/MQ/异步执行.png)\n\n### 系统解耦\n\n系统解耦：降低系统之间的耦合度。\n\n案例讲解：\n首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：  \n![常见中间件](https://rong0624.github.io/images/MQ/系统耦合.png)\n\n那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：  \n![常见中间件](https://rong0624.github.io/images/MQ/系统耦合2.png)\n\n我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：  \n![常见中间件](https://rong0624.github.io/images/MQ/系统解耦.png)\n\n### 流量削峰\n\n流量消峰：\n针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.\n\n案例讲解：\n假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。  \n![常见中间件](https://rong0624.github.io/images/MQ/流量削峰1.png)\n\n那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。  \n![常见中间件](https://rong0624.github.io/images/MQ/流量削峰2.png)\n\n但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：  \n![常见中间件](https://rong0624.github.io/images/MQ/流量削峰3.png)\n\n## 常见的消息中间件\n\nActiveMQ，RabbitMQ，Kafka，RocketMQ\n\n***\n\n# 消息队列协议\n\n## 什么是协议\n\n![常见中间件](https://rong0624.github.io/images/MQ/mq协议.png)\n\n所谓协议是指：  \n1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流  \n2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高  \n3）协议对数据格式和计算机之间交换数据都必须严格遵守规范\n\n***\n\n## 网络协议的三要素\n\n1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序  \n2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应  \n3）时序：时序是对事件发生顺序的详细说明\n\n比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：  \n1）语法：http规定了请求报文和响应报文的格式  \n2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）  \n3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）\n\n***\n\n## 常见的消息中间件协议\n\n消息中间件采用的不是 http协议。  \n常见的消息中间件协议有：JSM、AMQP、Kafka，OpenMessage，OpenWire，MQTT协议\n\n***\n\n### JMS协议\n\nJMS：（全称：Java Message Service）Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。这是java定义的api，是不可跨语言，是不可跨平台的。\n\n特性：  \n1）可靠的消息处理  \n2）消息的持久化支持  \n3）跨平台跨语言支持差\n\n支持MQ：ActiveMQ\n\n### AMQP协议\n\nAMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。\n\n特性：  \n1）分布式事务支持  \n2）消息的持久化支持  \n3）高性能和高可靠的消息处理优势\n\n支持MQ：RabbitMQ\n\n### MQTT协议\n\nMQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。\n\n特点：  \n1）轻量  \n2）结构简单  \n3）传输快，不支持事务  \n4）没有持久化设计\n\n支持MQ：RabbitMQ\n\n### Kafka协议\n\nKafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）无事务支持  \n4）有持久化设计\n\n代表MQ：Kafka\n\n### OpenMessage协议\n\nOpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）支持事务和持久化设计\n\n支持MQ：RocketMQ\n\n## 为什么消息中间件不使用 http协议\n\n为什么消息中间件不使用 http协议？  \n1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速  \n2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。\n\n***\n\n# 消息队列持久化\n\n## 持久化\n\n简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。  \n![消息持久化图片](https://rong0624.github.io/images/MQ/消息持久化.png)\n\n***\n\n## 常见MQ的持久化方式\n\nActiveMQ：支持文件存储，支持数据库\n\nRabbitMQ & Kafka & RocketMQ：支持文件存储\n\n***\n\n# 消息的分发策略\n\n## 场景分析\n\n场景分析一：  \n![消息分发1](https://rong0624.github.io/images/MQ/消息分发1.png)  \n比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。\n\n场景分析二：  \n![消息分发2](https://rong0624.github.io/images/MQ/消息分发2.png)  \n在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。\n\n## 消息的分发策略\n\nMQ消息队列有如下几个角色  \n1）生产者  \n2）存储消息  \n3）消费者\n\n那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。\n\n![消息分发策略](https://rong0624.github.io/images/MQ/消息分发策略.png)  \n\n***\n\n# 消息队列高可用和高可靠\n\n## 什么是高可用机制\n\n所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力\n当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。\n\n### 集群模式一\n\nMaster-slave主从同步部署方式  \n![集群模式1](https://rong0624.github.io/images/MQ/集群模式一.png)  \n解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。\n\n### 集群模式二\n\nMaster-slave与 Broker-cluster组合的方案  \n![集群模式1](https://rong0624.github.io/images/MQ/集群模式二.png)  \n解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。\n\n**注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。**\n\n\n## 什么是高可靠机制\n\n所谓高可靠是指：  \n系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。\n\n如何保证中间件消息的可靠性呢，可以从两个方面考虑：  \n1）消息的传输：通过协议来保证系统间数据解析的正确性  \n2）消息的存储区可靠：通过持久化来保证消息的可靠性\n\n注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。","source":"_posts/MQ/消息中间件入门与简介.md","raw":"---\ntitle: 消息中间件入门与简介\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: MQ\ncategories: MQ\n---\n\n# 什么是中间件\n\n## 什么是中间件\n\n我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。\n\n中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来\n\n***\n\n<!-- more -->\n\n## 中间件特点\n\n为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。\n\n![中间件特点](https://rong0624.github.io/images/MQ/中间件特点.png)\n\n也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：  \n（1）满足大量应用的需要  \n（2）运行于多种硬件和 OS平台  \n（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互  \n（4）支持标准的协议  \n（5）支持标准的接口\n\n由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。\n\n简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。\n\n***\n\n## 常见中间件\n\n![常见中间件](https://rong0624.github.io/images/MQ/常见中间件.png)\n\n***\n\n## 学习中间件的方式和技巧\n\n1）理解中间件在项目架构中的作用，以及各中间件的底层实现  \n2）可以使用一些类比的生活概念去理解中间件  \n3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用  \n4）尝试用 java技术去实现中间件的原理  \n5）静下来去思考中间件在项目中设计的和使用的原因  \n6）如果找到对应的代替总结方案  \n7）尝试编写博文总结类同中间件技术的对比和使用场景  \n8）学会查看中间件的源码以及开源项目和博文\n\n***\n\n# 什么是消息中间件\n\n## 什么是消息中间件\n\n消息中间件：\n是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。\n\n***\n\n## 为什么需要使用消息中间件\n具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。\n\n***\n\n## 消息中间件功能与组成\n\n### 功能\n\n消息中间件：\n是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。\n\nMQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。  \n![常见中间件](https://rong0624.github.io/images/MQ/mq消息队列图解1.png)\n\n谁来生产消息，存储消息和消费消息呢？  \n生产者生产消息，MQ存储消息，消费者消费消息  \n![常见中间件](https://rong0624.github.io/images/MQ/mq消息队列图解2.png)\n\n### 核心组成部分\n\n消息中间件的核心组成部分：  \n消息的协议   \n消息的持久化机制   \n消息的分发策略   \n消息的高可用  \n高可靠消息的容错机制\n\n\n## 消息中间件应用场景\n\n参考：https://www.jianshu.com/p/3fed7e963a2d\n\n***\n\n### 异步通信\n\n异步通信：（异步处理）    \n当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。\n\n案例讲解：  \n假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。  \n![常见中间件](https://rong0624.github.io/images/MQ/并行执行.png)\n\n生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。\n\n按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。  \n过程如下图所示：  \n![常见中间件](https://rong0624.github.io/images/MQ/异步执行.png)\n\n### 系统解耦\n\n系统解耦：降低系统之间的耦合度。\n\n案例讲解：\n首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：  \n![常见中间件](https://rong0624.github.io/images/MQ/系统耦合.png)\n\n那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：  \n![常见中间件](https://rong0624.github.io/images/MQ/系统耦合2.png)\n\n我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：  \n![常见中间件](https://rong0624.github.io/images/MQ/系统解耦.png)\n\n### 流量削峰\n\n流量消峰：\n针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.\n\n案例讲解：\n假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。  \n![常见中间件](https://rong0624.github.io/images/MQ/流量削峰1.png)\n\n那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。  \n![常见中间件](https://rong0624.github.io/images/MQ/流量削峰2.png)\n\n但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：  \n![常见中间件](https://rong0624.github.io/images/MQ/流量削峰3.png)\n\n## 常见的消息中间件\n\nActiveMQ，RabbitMQ，Kafka，RocketMQ\n\n***\n\n# 消息队列协议\n\n## 什么是协议\n\n![常见中间件](https://rong0624.github.io/images/MQ/mq协议.png)\n\n所谓协议是指：  \n1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流  \n2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高  \n3）协议对数据格式和计算机之间交换数据都必须严格遵守规范\n\n***\n\n## 网络协议的三要素\n\n1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序  \n2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应  \n3）时序：时序是对事件发生顺序的详细说明\n\n比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：  \n1）语法：http规定了请求报文和响应报文的格式  \n2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）  \n3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）\n\n***\n\n## 常见的消息中间件协议\n\n消息中间件采用的不是 http协议。  \n常见的消息中间件协议有：JSM、AMQP、Kafka，OpenMessage，OpenWire，MQTT协议\n\n***\n\n### JMS协议\n\nJMS：（全称：Java Message Service）Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。这是java定义的api，是不可跨语言，是不可跨平台的。\n\n特性：  \n1）可靠的消息处理  \n2）消息的持久化支持  \n3）跨平台跨语言支持差\n\n支持MQ：ActiveMQ\n\n### AMQP协议\n\nAMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。\n\n特性：  \n1）分布式事务支持  \n2）消息的持久化支持  \n3）高性能和高可靠的消息处理优势\n\n支持MQ：RabbitMQ\n\n### MQTT协议\n\nMQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。\n\n特点：  \n1）轻量  \n2）结构简单  \n3）传输快，不支持事务  \n4）没有持久化设计\n\n支持MQ：RabbitMQ\n\n### Kafka协议\n\nKafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）无事务支持  \n4）有持久化设计\n\n代表MQ：Kafka\n\n### OpenMessage协议\n\nOpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）支持事务和持久化设计\n\n支持MQ：RocketMQ\n\n## 为什么消息中间件不使用 http协议\n\n为什么消息中间件不使用 http协议？  \n1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速  \n2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。\n\n***\n\n# 消息队列持久化\n\n## 持久化\n\n简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。  \n![消息持久化图片](https://rong0624.github.io/images/MQ/消息持久化.png)\n\n***\n\n## 常见MQ的持久化方式\n\nActiveMQ：支持文件存储，支持数据库\n\nRabbitMQ & Kafka & RocketMQ：支持文件存储\n\n***\n\n# 消息的分发策略\n\n## 场景分析\n\n场景分析一：  \n![消息分发1](https://rong0624.github.io/images/MQ/消息分发1.png)  \n比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。\n\n场景分析二：  \n![消息分发2](https://rong0624.github.io/images/MQ/消息分发2.png)  \n在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。\n\n## 消息的分发策略\n\nMQ消息队列有如下几个角色  \n1）生产者  \n2）存储消息  \n3）消费者\n\n那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。\n\n![消息分发策略](https://rong0624.github.io/images/MQ/消息分发策略.png)  \n\n***\n\n# 消息队列高可用和高可靠\n\n## 什么是高可用机制\n\n所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力\n当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。\n\n### 集群模式一\n\nMaster-slave主从同步部署方式  \n![集群模式1](https://rong0624.github.io/images/MQ/集群模式一.png)  \n解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。\n\n### 集群模式二\n\nMaster-slave与 Broker-cluster组合的方案  \n![集群模式1](https://rong0624.github.io/images/MQ/集群模式二.png)  \n解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。\n\n**注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。**\n\n\n## 什么是高可靠机制\n\n所谓高可靠是指：  \n系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。\n\n如何保证中间件消息的可靠性呢，可以从两个方面考虑：  \n1）消息的传输：通过协议来保证系统间数据解析的正确性  \n2）消息的存储区可靠：通过持久化来保证消息的可靠性\n\n注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。","slug":"MQ/消息中间件入门与简介","published":1,"updated":"2021-06-25T13:37:06.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqcfpmjo000hhowmfl7y1nzi","content":"<h1 id=\"什么是中间件\"><a href=\"#什么是中间件\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h1><h2 id=\"什么是中间件-1\"><a href=\"#什么是中间件-1\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h2><p>我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。</p>\n<p>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来</p>\n<hr>\n<span id=\"more\"></span>\n\n<h2 id=\"中间件特点\"><a href=\"#中间件特点\" class=\"headerlink\" title=\"中间件特点\"></a>中间件特点</h2><p>为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。</p>\n<p><img src=\"https://rong0624.github.io/images/MQ/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%89%B9%E7%82%B9.png\" alt=\"中间件特点\"></p>\n<p>也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：<br>（1）满足大量应用的需要<br>（2）运行于多种硬件和 OS平台<br>（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互<br>（4）支持标准的协议<br>（5）支持标准的接口</p>\n<p>由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。</p>\n<p>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。</p>\n<hr>\n<h2 id=\"常见中间件\"><a href=\"#常见中间件\" class=\"headerlink\" title=\"常见中间件\"></a>常见中间件</h2><p><img src=\"https://rong0624.github.io/images/MQ/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6.png\" alt=\"常见中间件\"></p>\n<hr>\n<h2 id=\"学习中间件的方式和技巧\"><a href=\"#学习中间件的方式和技巧\" class=\"headerlink\" title=\"学习中间件的方式和技巧\"></a>学习中间件的方式和技巧</h2><p>1）理解中间件在项目架构中的作用，以及各中间件的底层实现<br>2）可以使用一些类比的生活概念去理解中间件<br>3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用<br>4）尝试用 java技术去实现中间件的原理<br>5）静下来去思考中间件在项目中设计的和使用的原因<br>6）如果找到对应的代替总结方案<br>7）尝试编写博文总结类同中间件技术的对比和使用场景<br>8）学会查看中间件的源码以及开源项目和博文</p>\n<hr>\n<h1 id=\"什么是消息中间件\"><a href=\"#什么是消息中间件\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h1><h2 id=\"什么是消息中间件-1\"><a href=\"#什么是消息中间件-1\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h2><p>消息中间件：<br>是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。</p>\n<hr>\n<h2 id=\"为什么需要使用消息中间件\"><a href=\"#为什么需要使用消息中间件\" class=\"headerlink\" title=\"为什么需要使用消息中间件\"></a>为什么需要使用消息中间件</h2><p>具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p>\n<hr>\n<h2 id=\"消息中间件功能与组成\"><a href=\"#消息中间件功能与组成\" class=\"headerlink\" title=\"消息中间件功能与组成\"></a>消息中间件功能与组成</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>消息中间件：<br>是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。</p>\n<p>MQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。<br><img src=\"https://rong0624.github.io/images/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A31.png\" alt=\"常见中间件\"></p>\n<p>谁来生产消息，存储消息和消费消息呢？<br>生产者生产消息，MQ存储消息，消费者消费消息<br><img src=\"https://rong0624.github.io/images/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A32.png\" alt=\"常见中间件\"></p>\n<h3 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h3><p>消息中间件的核心组成部分：<br>消息的协议<br>消息的持久化机制<br>消息的分发策略<br>消息的高可用<br>高可靠消息的容错机制</p>\n<h2 id=\"消息中间件应用场景\"><a href=\"#消息中间件应用场景\" class=\"headerlink\" title=\"消息中间件应用场景\"></a>消息中间件应用场景</h2><p>参考：<a href=\"https://www.jianshu.com/p/3fed7e963a2d\">https://www.jianshu.com/p/3fed7e963a2d</a></p>\n<hr>\n<h3 id=\"异步通信\"><a href=\"#异步通信\" class=\"headerlink\" title=\"异步通信\"></a>异步通信</h3><p>异步通信：（异步处理）<br>当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。</p>\n<p>案例讲解：<br>假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。<br><img src=\"https://rong0624.github.io/images/MQ/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<p>生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。</p>\n<p>按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。<br>过程如下图所示：<br><img src=\"https://rong0624.github.io/images/MQ/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<h3 id=\"系统解耦\"><a href=\"#系统解耦\" class=\"headerlink\" title=\"系统解耦\"></a>系统解耦</h3><p>系统解耦：降低系统之间的耦合度。</p>\n<p>案例讲解：<br>首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：<br><img src=\"https://rong0624.github.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：<br><img src=\"https://rong0624.github.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%882.png\" alt=\"常见中间件\"></p>\n<p>我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：<br><img src=\"https://rong0624.github.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"常见中间件\"></p>\n<h3 id=\"流量削峰\"><a href=\"#流量削峰\" class=\"headerlink\" title=\"流量削峰\"></a>流量削峰</h3><p>流量消峰：<br>针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.</p>\n<p>案例讲解：<br>假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B01.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B02.png\" alt=\"常见中间件\"></p>\n<p>但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B03.png\" alt=\"常见中间件\"></p>\n<h2 id=\"常见的消息中间件\"><a href=\"#常见的消息中间件\" class=\"headerlink\" title=\"常见的消息中间件\"></a>常见的消息中间件</h2><p>ActiveMQ，RabbitMQ，Kafka，RocketMQ</p>\n<hr>\n<h1 id=\"消息队列协议\"><a href=\"#消息队列协议\" class=\"headerlink\" title=\"消息队列协议\"></a>消息队列协议</h1><h2 id=\"什么是协议\"><a href=\"#什么是协议\" class=\"headerlink\" title=\"什么是协议\"></a>什么是协议</h2><p><img src=\"https://rong0624.github.io/images/MQ/mq%E5%8D%8F%E8%AE%AE.png\" alt=\"常见中间件\"></p>\n<p>所谓协议是指：<br>1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流<br>2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高<br>3）协议对数据格式和计算机之间交换数据都必须严格遵守规范</p>\n<hr>\n<h2 id=\"网络协议的三要素\"><a href=\"#网络协议的三要素\" class=\"headerlink\" title=\"网络协议的三要素\"></a>网络协议的三要素</h2><p>1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序<br>2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应<br>3）时序：时序是对事件发生顺序的详细说明</p>\n<p>比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：<br>1）语法：http规定了请求报文和响应报文的格式<br>2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）<br>3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）</p>\n<hr>\n<h2 id=\"常见的消息中间件协议\"><a href=\"#常见的消息中间件协议\" class=\"headerlink\" title=\"常见的消息中间件协议\"></a>常见的消息中间件协议</h2><p>消息中间件采用的不是 http协议。<br>常见的消息中间件协议有：JSM、AMQP、Kafka，OpenMessage，OpenWire，MQTT协议</p>\n<hr>\n<h3 id=\"JMS协议\"><a href=\"#JMS协议\" class=\"headerlink\" title=\"JMS协议\"></a>JMS协议</h3><p>JMS：（全称：Java Message Service）Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。这是java定义的api，是不可跨语言，是不可跨平台的。</p>\n<p>特性：<br>1）可靠的消息处理<br>2）消息的持久化支持<br>3）跨平台跨语言支持差</p>\n<p>支持MQ：ActiveMQ</p>\n<h3 id=\"AMQP协议\"><a href=\"#AMQP协议\" class=\"headerlink\" title=\"AMQP协议\"></a>AMQP协议</h3><p>AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p>\n<p>特性：<br>1）分布式事务支持<br>2）消息的持久化支持<br>3）高性能和高可靠的消息处理优势</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"MQTT协议\"><a href=\"#MQTT协议\" class=\"headerlink\" title=\"MQTT协议\"></a>MQTT协议</h3><p>MQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。</p>\n<p>特点：<br>1）轻量<br>2）结构简单<br>3）传输快，不支持事务<br>4）没有持久化设计</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"Kafka协议\"><a href=\"#Kafka协议\" class=\"headerlink\" title=\"Kafka协议\"></a>Kafka协议</h3><p>Kafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）无事务支持<br>4）有持久化设计</p>\n<p>代表MQ：Kafka</p>\n<h3 id=\"OpenMessage协议\"><a href=\"#OpenMessage协议\" class=\"headerlink\" title=\"OpenMessage协议\"></a>OpenMessage协议</h3><p>OpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）支持事务和持久化设计</p>\n<p>支持MQ：RocketMQ</p>\n<h2 id=\"为什么消息中间件不使用-http协议\"><a href=\"#为什么消息中间件不使用-http协议\" class=\"headerlink\" title=\"为什么消息中间件不使用 http协议\"></a>为什么消息中间件不使用 http协议</h2><p>为什么消息中间件不使用 http协议？<br>1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速<br>2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p>\n<hr>\n<h1 id=\"消息队列持久化\"><a href=\"#消息队列持久化\" class=\"headerlink\" title=\"消息队列持久化\"></a>消息队列持久化</h1><h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96.png\" alt=\"消息持久化图片\"></p>\n<hr>\n<h2 id=\"常见MQ的持久化方式\"><a href=\"#常见MQ的持久化方式\" class=\"headerlink\" title=\"常见MQ的持久化方式\"></a>常见MQ的持久化方式</h2><p>ActiveMQ：支持文件存储，支持数据库</p>\n<p>RabbitMQ &amp; Kafka &amp; RocketMQ：支持文件存储</p>\n<hr>\n<h1 id=\"消息的分发策略\"><a href=\"#消息的分发策略\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h1><h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h2><p>场景分析一：<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%911.png\" alt=\"消息分发1\"><br>比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。</p>\n<p>场景分析二：<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%912.png\" alt=\"消息分发2\"><br>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。</p>\n<h2 id=\"消息的分发策略-1\"><a href=\"#消息的分发策略-1\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h2><p>MQ消息队列有如下几个角色<br>1）生产者<br>2）存储消息<br>3）消费者</p>\n<p>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。</p>\n<p><img src=\"https://rong0624.github.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5.png\" alt=\"消息分发策略\">  </p>\n<hr>\n<h1 id=\"消息队列高可用和高可靠\"><a href=\"#消息队列高可用和高可靠\" class=\"headerlink\" title=\"消息队列高可用和高可靠\"></a>消息队列高可用和高可靠</h1><h2 id=\"什么是高可用机制\"><a href=\"#什么是高可用机制\" class=\"headerlink\" title=\"什么是高可用机制\"></a>什么是高可用机制</h2><p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。</p>\n<h3 id=\"集群模式一\"><a href=\"#集群模式一\" class=\"headerlink\" title=\"集群模式一\"></a>集群模式一</h3><p>Master-slave主从同步部署方式<br><img src=\"https://rong0624.github.io/images/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%80.png\" alt=\"集群模式1\"><br>解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。</p>\n<h3 id=\"集群模式二\"><a href=\"#集群模式二\" class=\"headerlink\" title=\"集群模式二\"></a>集群模式二</h3><p>Master-slave与 Broker-cluster组合的方案<br><img src=\"https://rong0624.github.io/images/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%BA%8C.png\" alt=\"集群模式1\"><br>解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。</p>\n<p><strong>注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</strong></p>\n<h2 id=\"什么是高可靠机制\"><a href=\"#什么是高可靠机制\" class=\"headerlink\" title=\"什么是高可靠机制\"></a>什么是高可靠机制</h2><p>所谓高可靠是指：<br>系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</p>\n<p>如何保证中间件消息的可靠性呢，可以从两个方面考虑：<br>1）消息的传输：通过协议来保证系统间数据解析的正确性<br>2）消息的存储区可靠：通过持久化来保证消息的可靠性</p>\n<p>注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是中间件\"><a href=\"#什么是中间件\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h1><h2 id=\"什么是中间件-1\"><a href=\"#什么是中间件-1\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h2><p>我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。</p>\n<p>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来</p>\n<hr>","more":"<h2 id=\"中间件特点\"><a href=\"#中间件特点\" class=\"headerlink\" title=\"中间件特点\"></a>中间件特点</h2><p>为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。</p>\n<p><img src=\"https://rong0624.github.io/images/MQ/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%89%B9%E7%82%B9.png\" alt=\"中间件特点\"></p>\n<p>也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：<br>（1）满足大量应用的需要<br>（2）运行于多种硬件和 OS平台<br>（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互<br>（4）支持标准的协议<br>（5）支持标准的接口</p>\n<p>由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。</p>\n<p>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。</p>\n<hr>\n<h2 id=\"常见中间件\"><a href=\"#常见中间件\" class=\"headerlink\" title=\"常见中间件\"></a>常见中间件</h2><p><img src=\"https://rong0624.github.io/images/MQ/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6.png\" alt=\"常见中间件\"></p>\n<hr>\n<h2 id=\"学习中间件的方式和技巧\"><a href=\"#学习中间件的方式和技巧\" class=\"headerlink\" title=\"学习中间件的方式和技巧\"></a>学习中间件的方式和技巧</h2><p>1）理解中间件在项目架构中的作用，以及各中间件的底层实现<br>2）可以使用一些类比的生活概念去理解中间件<br>3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用<br>4）尝试用 java技术去实现中间件的原理<br>5）静下来去思考中间件在项目中设计的和使用的原因<br>6）如果找到对应的代替总结方案<br>7）尝试编写博文总结类同中间件技术的对比和使用场景<br>8）学会查看中间件的源码以及开源项目和博文</p>\n<hr>\n<h1 id=\"什么是消息中间件\"><a href=\"#什么是消息中间件\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h1><h2 id=\"什么是消息中间件-1\"><a href=\"#什么是消息中间件-1\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h2><p>消息中间件：<br>是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。</p>\n<hr>\n<h2 id=\"为什么需要使用消息中间件\"><a href=\"#为什么需要使用消息中间件\" class=\"headerlink\" title=\"为什么需要使用消息中间件\"></a>为什么需要使用消息中间件</h2><p>具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p>\n<hr>\n<h2 id=\"消息中间件功能与组成\"><a href=\"#消息中间件功能与组成\" class=\"headerlink\" title=\"消息中间件功能与组成\"></a>消息中间件功能与组成</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>消息中间件：<br>是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。</p>\n<p>MQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。<br><img src=\"https://rong0624.github.io/images/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A31.png\" alt=\"常见中间件\"></p>\n<p>谁来生产消息，存储消息和消费消息呢？<br>生产者生产消息，MQ存储消息，消费者消费消息<br><img src=\"https://rong0624.github.io/images/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A32.png\" alt=\"常见中间件\"></p>\n<h3 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h3><p>消息中间件的核心组成部分：<br>消息的协议<br>消息的持久化机制<br>消息的分发策略<br>消息的高可用<br>高可靠消息的容错机制</p>\n<h2 id=\"消息中间件应用场景\"><a href=\"#消息中间件应用场景\" class=\"headerlink\" title=\"消息中间件应用场景\"></a>消息中间件应用场景</h2><p>参考：<a href=\"https://www.jianshu.com/p/3fed7e963a2d\">https://www.jianshu.com/p/3fed7e963a2d</a></p>\n<hr>\n<h3 id=\"异步通信\"><a href=\"#异步通信\" class=\"headerlink\" title=\"异步通信\"></a>异步通信</h3><p>异步通信：（异步处理）<br>当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。</p>\n<p>案例讲解：<br>假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。<br><img src=\"https://rong0624.github.io/images/MQ/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<p>生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。</p>\n<p>按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。<br>过程如下图所示：<br><img src=\"https://rong0624.github.io/images/MQ/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<h3 id=\"系统解耦\"><a href=\"#系统解耦\" class=\"headerlink\" title=\"系统解耦\"></a>系统解耦</h3><p>系统解耦：降低系统之间的耦合度。</p>\n<p>案例讲解：<br>首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：<br><img src=\"https://rong0624.github.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：<br><img src=\"https://rong0624.github.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%882.png\" alt=\"常见中间件\"></p>\n<p>我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：<br><img src=\"https://rong0624.github.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"常见中间件\"></p>\n<h3 id=\"流量削峰\"><a href=\"#流量削峰\" class=\"headerlink\" title=\"流量削峰\"></a>流量削峰</h3><p>流量消峰：<br>针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.</p>\n<p>案例讲解：<br>假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B01.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B02.png\" alt=\"常见中间件\"></p>\n<p>但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B03.png\" alt=\"常见中间件\"></p>\n<h2 id=\"常见的消息中间件\"><a href=\"#常见的消息中间件\" class=\"headerlink\" title=\"常见的消息中间件\"></a>常见的消息中间件</h2><p>ActiveMQ，RabbitMQ，Kafka，RocketMQ</p>\n<hr>\n<h1 id=\"消息队列协议\"><a href=\"#消息队列协议\" class=\"headerlink\" title=\"消息队列协议\"></a>消息队列协议</h1><h2 id=\"什么是协议\"><a href=\"#什么是协议\" class=\"headerlink\" title=\"什么是协议\"></a>什么是协议</h2><p><img src=\"https://rong0624.github.io/images/MQ/mq%E5%8D%8F%E8%AE%AE.png\" alt=\"常见中间件\"></p>\n<p>所谓协议是指：<br>1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流<br>2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高<br>3）协议对数据格式和计算机之间交换数据都必须严格遵守规范</p>\n<hr>\n<h2 id=\"网络协议的三要素\"><a href=\"#网络协议的三要素\" class=\"headerlink\" title=\"网络协议的三要素\"></a>网络协议的三要素</h2><p>1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序<br>2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应<br>3）时序：时序是对事件发生顺序的详细说明</p>\n<p>比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：<br>1）语法：http规定了请求报文和响应报文的格式<br>2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）<br>3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）</p>\n<hr>\n<h2 id=\"常见的消息中间件协议\"><a href=\"#常见的消息中间件协议\" class=\"headerlink\" title=\"常见的消息中间件协议\"></a>常见的消息中间件协议</h2><p>消息中间件采用的不是 http协议。<br>常见的消息中间件协议有：JSM、AMQP、Kafka，OpenMessage，OpenWire，MQTT协议</p>\n<hr>\n<h3 id=\"JMS协议\"><a href=\"#JMS协议\" class=\"headerlink\" title=\"JMS协议\"></a>JMS协议</h3><p>JMS：（全称：Java Message Service）Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。这是java定义的api，是不可跨语言，是不可跨平台的。</p>\n<p>特性：<br>1）可靠的消息处理<br>2）消息的持久化支持<br>3）跨平台跨语言支持差</p>\n<p>支持MQ：ActiveMQ</p>\n<h3 id=\"AMQP协议\"><a href=\"#AMQP协议\" class=\"headerlink\" title=\"AMQP协议\"></a>AMQP协议</h3><p>AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p>\n<p>特性：<br>1）分布式事务支持<br>2）消息的持久化支持<br>3）高性能和高可靠的消息处理优势</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"MQTT协议\"><a href=\"#MQTT协议\" class=\"headerlink\" title=\"MQTT协议\"></a>MQTT协议</h3><p>MQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。</p>\n<p>特点：<br>1）轻量<br>2）结构简单<br>3）传输快，不支持事务<br>4）没有持久化设计</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"Kafka协议\"><a href=\"#Kafka协议\" class=\"headerlink\" title=\"Kafka协议\"></a>Kafka协议</h3><p>Kafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）无事务支持<br>4）有持久化设计</p>\n<p>代表MQ：Kafka</p>\n<h3 id=\"OpenMessage协议\"><a href=\"#OpenMessage协议\" class=\"headerlink\" title=\"OpenMessage协议\"></a>OpenMessage协议</h3><p>OpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）支持事务和持久化设计</p>\n<p>支持MQ：RocketMQ</p>\n<h2 id=\"为什么消息中间件不使用-http协议\"><a href=\"#为什么消息中间件不使用-http协议\" class=\"headerlink\" title=\"为什么消息中间件不使用 http协议\"></a>为什么消息中间件不使用 http协议</h2><p>为什么消息中间件不使用 http协议？<br>1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速<br>2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p>\n<hr>\n<h1 id=\"消息队列持久化\"><a href=\"#消息队列持久化\" class=\"headerlink\" title=\"消息队列持久化\"></a>消息队列持久化</h1><h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96.png\" alt=\"消息持久化图片\"></p>\n<hr>\n<h2 id=\"常见MQ的持久化方式\"><a href=\"#常见MQ的持久化方式\" class=\"headerlink\" title=\"常见MQ的持久化方式\"></a>常见MQ的持久化方式</h2><p>ActiveMQ：支持文件存储，支持数据库</p>\n<p>RabbitMQ &amp; Kafka &amp; RocketMQ：支持文件存储</p>\n<hr>\n<h1 id=\"消息的分发策略\"><a href=\"#消息的分发策略\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h1><h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h2><p>场景分析一：<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%911.png\" alt=\"消息分发1\"><br>比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。</p>\n<p>场景分析二：<br><img src=\"https://rong0624.github.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%912.png\" alt=\"消息分发2\"><br>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。</p>\n<h2 id=\"消息的分发策略-1\"><a href=\"#消息的分发策略-1\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h2><p>MQ消息队列有如下几个角色<br>1）生产者<br>2）存储消息<br>3）消费者</p>\n<p>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。</p>\n<p><img src=\"https://rong0624.github.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5.png\" alt=\"消息分发策略\">  </p>\n<hr>\n<h1 id=\"消息队列高可用和高可靠\"><a href=\"#消息队列高可用和高可靠\" class=\"headerlink\" title=\"消息队列高可用和高可靠\"></a>消息队列高可用和高可靠</h1><h2 id=\"什么是高可用机制\"><a href=\"#什么是高可用机制\" class=\"headerlink\" title=\"什么是高可用机制\"></a>什么是高可用机制</h2><p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。</p>\n<h3 id=\"集群模式一\"><a href=\"#集群模式一\" class=\"headerlink\" title=\"集群模式一\"></a>集群模式一</h3><p>Master-slave主从同步部署方式<br><img src=\"https://rong0624.github.io/images/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%80.png\" alt=\"集群模式1\"><br>解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。</p>\n<h3 id=\"集群模式二\"><a href=\"#集群模式二\" class=\"headerlink\" title=\"集群模式二\"></a>集群模式二</h3><p>Master-slave与 Broker-cluster组合的方案<br><img src=\"https://rong0624.github.io/images/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%BA%8C.png\" alt=\"集群模式1\"><br>解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。</p>\n<p><strong>注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</strong></p>\n<h2 id=\"什么是高可靠机制\"><a href=\"#什么是高可靠机制\" class=\"headerlink\" title=\"什么是高可靠机制\"></a>什么是高可靠机制</h2><p>所谓高可靠是指：<br>系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</p>\n<p>如何保证中间件消息的可靠性呢，可以从两个方面考虑：<br>1）消息的传输：通过协议来保证系统间数据解析的正确性<br>2）消息的存储区可靠：通过持久化来保证消息的可靠性</p>\n<p>注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</p>"},{"title":"MySQL日志系统","date":"2021-06-21T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n注意：当前设置系统参数方式，mysql重启即失效，如果要永久存在则需要修改配置文件。\n\n# error log（错误日志）\n\n## 定义\n\nerror log 是 MySQL 的错误日志。  \n主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。  \n和其他的日志不同，MySQL的error日志必须开启，无法关闭。\n\n**注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。**\n\n***\n\n<!-- more -->\n\n## 设置错误日志\n\n查看当前的错误日志文件  \n没有设置错误日志文件，默认指定了一个的错误日志文件\n```\nmysql> show variables like 'log_error';\n+---------------+----------------------+\n| Variable_name | Value                |\n+---------------+----------------------+\n| log_error     | ./VM-16-4-centos.err |\n+---------------+----------------------+\n1 row in set (0.00 sec)\n```\n\n命令：\n```sql\nshow variables like 'log_error'; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件\nset global log_error = '/var/lib/mysql/error.log'; #设置错误日志文件\n```\n\n修改配置文件：  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlog-error='/var/lib/mysql/error.log'\n```\n\n当前通过修改配置文件指定错误配置文件，重启服务配置生效  \n可以看到当启动服务后，打印出Starting MySQL.Logging to '/var/lib/mysql/error.log'  \n这代表设置成功！\n```\n[root@VM-16-4-centos mysql]# service mysql stop\nShutting down MySQL. SUCCESS! \n[root@VM-16-4-centos mysql]# service mysql start\nStarting MySQL.Logging to '/var/lib/mysql/error.log'.\n. SUCCESS! \n```\n\n查看错误日志文件：  \n发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log \n210621 18:35:41 [Note] Plugin 'FEDERATED' is disabled.\n210621 18:35:41 InnoDB: The InnoDB memory heap is disabled\n210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins\n210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11\n210621 18:35:41 InnoDB: Using Linux native AIO\n210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M\n210621 18:35:41 InnoDB: Completed initialization of buffer pool\n210621 18:35:41 InnoDB: highest supported file format is Barracuda.\n210621 18:35:41  InnoDB: Waiting for the background threads to start\n210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913\n210621 18:35:42 [Note] Server hostname (bind-address): '0.0.0.0'; port: 3306\n210621 18:35:42 [Note]   - '0.0.0.0' resolves to '0.0.0.0';\n210621 18:35:42 [Note] Server socket created on IP: '0.0.0.0'.\n210621 18:35:42 [Note] Event Scheduler: Loaded 0 events\n210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.\nVersion: '5.5.62'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  MySQL Community Server (GPL)\n```\n\n***\n\n# general log（普通日志）\n\n## 定义\n\ngeneral log 是 MySQL 的普通日志。  \n主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。\n\n**注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，\n如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。\n只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。**\n\n***\n\n## 相关参数\n\n普通日志相关参数：\n* general_log：是否开启普通日志\n* general_log_file：普通日志文件的存放路径\n\n***\n\n## 开启普通日志\n\n查看普通日志的当前配置\n```\nmysql> show variables like '%general_log%';\n+------------------+-----------------------------------+\n| Variable_name    | Value                             |\n+------------------+-----------------------------------+\n| general_log      | OFF                               |\n| general_log_file | /var/lib/mysql/VM-16-4-centos.log |\n+------------------+-----------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%general_log%'; #查看普通日志是否开启\nshow variables like '%general_log_file%'; #查看普通日志文件的存放路径\n\nset global general_log=1; #开启普通日志\nset global general_log_file='/var/lib/mysql/general.log'; #指定普通日志文件的存放路径\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\ngeneral_log=1\ngeneral_log_file=/var/lib/mysql/general.log\n```\n\n当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。  \n结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log \n/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:\nTcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock\nTime                 Id Command    Argument\n210621 21:51:45\t    1 Connect\troot@localhost on \n\t\t    1 Connect\tAccess denied for user 'root'@'localhost' (using password: NO)\n210621 21:52:01\t    2 Connect\troot@localhost on \n\t\t    2 Query\tselect @@version_comment limit 1\n210621 21:52:51\t    2 Query\tSELECT DATABASE()\n\t\t    2 Init DB\ttest\n210621 21:53:00\t    2 Query\tselect * from a\n210621 21:53:03\t    2 Query\tselect * from a\n```\n\n***\n\n## 普通日志文件处理\n\n//TODO\n\n***\n\n\n# slow query log（慢查询日志）\n\n## 定义\n\nslow query log 是 MySQL 的慢查询日志。  \n主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。\n\n**注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。**  \n\n***\n\n## 相关参数\n\n以下是慢查询日志相关的参数：\n* slow_query_log：慢查询日志是否开启\n* slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。\n* long_query_time：设置慢查询的时间阈值，默认阈值是10s。\n* log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n* slow_queries：记录当前慢查询sql条数\n\n***\n\n## 开启慢查询日志\n\n查看慢查询日志的当前配置.  \n默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。\n```\nmysql> show variables like '%slow_query_log%';\n+---------------------+----------------------------------------+\n| Variable_name       | Value                                  |\n+---------------------+----------------------------------------+\n| slow_query_log      | OFF                                    |\n| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |\n+---------------------+----------------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%slow_query_log%'; #查看是否开启\nshow variables like '%slow_query_log_file%'; #查看慢查询日志文件的存放路径\n\nset global slow_query_log=1; #设置开启慢查询日志\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nslow_query_log=1\nslow_query_log_file=/var/lib/mysql/atguigu-slow.log\n```\n\n***\n\n## 什么 sql 会被记录到慢查询日志\n\n问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？  \n答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。\n\n### 记录响应时间超过阀值的sql语句\n\n时间阈值是由 long_query_time 控制的.  \nlong_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。\n\n命令：\n```sql\nshow variables LIKE 'long_query_time%'; #查看long_query_time的值\nset global long_query_time=5; #设置查询超过5秒则算慢查询sql\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlong_query_time=5\n```\n\n### 记录没有使用索引的查询语句\n\nlog_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n\n命令：\n```sql\nshow variables like '%log_queries_not_using_indexes%'; #查看值\nset global log_queries_not_using_indexes=1; #设置开启记录没有使用索引的查询语句\n```\n\n修改配置文件：（永久开启）  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\nlog_queries_not_using_indexes=1\n```\n\n## 慢查询 sql 案例\n\n``` sql\nset global slow_query_log=1; #设置开启慢查询日志\nset global long_query_time=3; #设置查询超过3秒则算慢查询sql（注意，这里是全局命令设置，需要重新连接才生效）\n\nselect sleep(4) #模拟一次查询，查询耗时4秒\nshow global status like '%slow_queries%'; #查询当前慢查询sql条数命令\n```\n\n去mysql的data目录下找到慢查询日志文件：  \n我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log  \n![慢查询日志图片](https://rong0624.github.io/images/MySQL/1624261484667.jpg)\n\n可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。\n\n***\n\n## 日志查询分析器（mysqldumpslow）\n\n日志查询分析器的体现：  \n在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。  \n![日志查询分析器帮助信息图片](https://rong0624.github.io/images/MySQL/日志查询分析器使用.jpg)\n\nmysqldumpslow --help  查看mysqldumpslow的帮助信息\n* s：表示按照何种方式排序\n* c：访问次数\n* l：锁定时间\n* r：返回记录\n* t：查询时间\n* al：平均锁定时间\n* ar：平均返回记录数\n* at：平均查询时间\n* t：即为返回前面多少条数据\n* g：后边搭配一个正则匹配模式，大小写不敏感。\n\n分析器常用的方式：\n``` sql\n#得到返回数据集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log\n\n#得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log\n\n#得到按照时间排序的前10条里面含有左连接的查询sql\nmysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log\n\n#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n```\n\n***\n\n# bin log（二进制日志）\n\n## 定义\nbin log 是 MySQL 的二进制文件，也叫归档日志。  \n主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一把不会被记录，因为他们不会对数据产生任何改动。  \n用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。\n\n> 重要的使用场景：  \n> mysql主从复制：mysql replication 在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  \n> 数据恢复：通过mysqlbinlog工具来恢复数据\n\n> 二进制日志包含两种文件：  \n> 二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  \n> 二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件\n\n***\n\n## 相关参数\n\nbin log相关参数：\n* log_bin：指定 bin log是否打开\n* log_bin_basename：指定的是 bin log 的基本文件名，后面会追加标识来表示每一个文件\n* log_bin_index：指定的是 bin log 文件的索引文件，这个文件管理了所有的 bin log 文件的目录\n\n***\n\n## 开启二进制日志\n\n查看二进制日志的当前配置：  \n可以看到，二进制日志默认是不开启的\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld] \nlog-bin=mysql-bin\nserver-id=001\n```\n\n修改配置文件后，重启服务配置生效  \n查看 bin log 日志文件  \n![bin log 日志文件](https://rong0624.github.io/images/MySQL/1624350274231.jpg)\n\n***\n\n## 查看二进制日志文件\n\n注意：  \n1）bin log日志与数据库文件在同目录中。  \n2）bin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的mysqlbinlog命令查看。  \n\n### mysqlbinlog 工具查看\n\nmysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。  \n在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上\"--no-defaults\"选项\n\n查看二进制日志文件：mysqlbinlog mysql-bin.000002\n```\n# at 391\n#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0\nSET TIMESTAMP=1624352800/*!*/;\ninsert into admin_info values(1, \"admin\", 100) #执行的sql\n/*!*/;\n# at 501\n#210622 17:06:40 server id 1  end_log_pos 528   Xid = 7 #执行的时间\n```\n> 图解  \n> server id 1：数据库主机的服务号  \n> end_log_pos 528：sql结束时的pos节点  \n> thread_id=11：线程号  \n\n### 命令查看\n\n> mysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息  \n> 介绍一种更为方便的查询命令 show bin log events\n\n命令解析 show bin log events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];    \n参数解析：  \na、IN 'log_name':指定要查询的bin log文件名（不指定就是第一个bin log文件  \nb、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）  \nc、LIMIT【offset】：偏移量(不指定就是0)  \nd、row_count :查询总条数（不指定就是所有行）  \n\nshow bin log events查询：\n```\nmysql> show bin log events in'mysql-bin.000002';\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |\n| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |\n| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |\n| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |\n| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, \"admin\", 100)                     |\n| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |\n| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n7 rows in set (0.00 sec)\n```\n\n***\n\n## 二进制日志文件常用操作命令\n\n1）查看所有 bin log 日志。  \nshow master logs;\n```\nmysql> show master logs;\n+------------------+-----------+\n| Log_name         | File_size |\n+------------------+-----------+\n| mysql-bin.000001 |       107 |\n+------------------+-----------+\n1 row in set (0.00 sec)\n```\n\n2）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。  \nshow master status;\n```\nmysql> show master status;\n+------------------+----------+--------------+------------------+\n| File             | Position | bin log_Do_DB | bin log_Ignore_DB |\n+------------------+----------+--------------+------------------+\n| mysql-bin.000001 |      107 |              |                  |\n+------------------+----------+--------------+------------------+\n1 row in set (0.00 sec)\n```\n\n3）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;  \nflush logs;\n\n注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；\n\n4）重置（清空）所有bin log日志;  \nreset master;\n\n***\n\n## 利用二进制日志恢复数据\n\n// TODO\n\n***\n\n# redo log（重做日志）\n\n## 定义\n\nredo log 是 MySQL 的物理日志，也叫重做日志，记录存储引擎 InnoDB 的事务日志。\n\nMySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。\n\n***\n\n# undo log（回滚日志）\n\n## 定义\n\n\n***\n\n## 相关参数\n\nundo log相关参数：\n* innodb_undo_logs :设置回滚日志的回滚段大小，默认为128k\n* innodb_undo_directory: 设置回滚日志存放的目录。\n* innodb_undo_tablespace:设置了回滚日志由多少个回滚日志文件组成，默认为0.\n\n***\n\n# relay log（中继日志）\n\n## 定义\n\nrelay-log中继日志是连接master和slave的核心.\n\n***","source":"_posts/MySQL/MySQL-日志系统.md","raw":"---\ntitle: MySQL日志系统\ndate: 2021-06-22 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: MySQL\ncategories: MySQL\n---\n\n注意：当前设置系统参数方式，mysql重启即失效，如果要永久存在则需要修改配置文件。\n\n# error log（错误日志）\n\n## 定义\n\nerror log 是 MySQL 的错误日志。  \n主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。  \n和其他的日志不同，MySQL的error日志必须开启，无法关闭。\n\n**注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。**\n\n***\n\n<!-- more -->\n\n## 设置错误日志\n\n查看当前的错误日志文件  \n没有设置错误日志文件，默认指定了一个的错误日志文件\n```\nmysql> show variables like 'log_error';\n+---------------+----------------------+\n| Variable_name | Value                |\n+---------------+----------------------+\n| log_error     | ./VM-16-4-centos.err |\n+---------------+----------------------+\n1 row in set (0.00 sec)\n```\n\n命令：\n```sql\nshow variables like 'log_error'; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件\nset global log_error = '/var/lib/mysql/error.log'; #设置错误日志文件\n```\n\n修改配置文件：  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlog-error='/var/lib/mysql/error.log'\n```\n\n当前通过修改配置文件指定错误配置文件，重启服务配置生效  \n可以看到当启动服务后，打印出Starting MySQL.Logging to '/var/lib/mysql/error.log'  \n这代表设置成功！\n```\n[root@VM-16-4-centos mysql]# service mysql stop\nShutting down MySQL. SUCCESS! \n[root@VM-16-4-centos mysql]# service mysql start\nStarting MySQL.Logging to '/var/lib/mysql/error.log'.\n. SUCCESS! \n```\n\n查看错误日志文件：  \n发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log \n210621 18:35:41 [Note] Plugin 'FEDERATED' is disabled.\n210621 18:35:41 InnoDB: The InnoDB memory heap is disabled\n210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins\n210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11\n210621 18:35:41 InnoDB: Using Linux native AIO\n210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M\n210621 18:35:41 InnoDB: Completed initialization of buffer pool\n210621 18:35:41 InnoDB: highest supported file format is Barracuda.\n210621 18:35:41  InnoDB: Waiting for the background threads to start\n210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913\n210621 18:35:42 [Note] Server hostname (bind-address): '0.0.0.0'; port: 3306\n210621 18:35:42 [Note]   - '0.0.0.0' resolves to '0.0.0.0';\n210621 18:35:42 [Note] Server socket created on IP: '0.0.0.0'.\n210621 18:35:42 [Note] Event Scheduler: Loaded 0 events\n210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.\nVersion: '5.5.62'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  MySQL Community Server (GPL)\n```\n\n***\n\n# general log（普通日志）\n\n## 定义\n\ngeneral log 是 MySQL 的普通日志。  \n主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。\n\n**注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，\n如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。\n只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。**\n\n***\n\n## 相关参数\n\n普通日志相关参数：\n* general_log：是否开启普通日志\n* general_log_file：普通日志文件的存放路径\n\n***\n\n## 开启普通日志\n\n查看普通日志的当前配置\n```\nmysql> show variables like '%general_log%';\n+------------------+-----------------------------------+\n| Variable_name    | Value                             |\n+------------------+-----------------------------------+\n| general_log      | OFF                               |\n| general_log_file | /var/lib/mysql/VM-16-4-centos.log |\n+------------------+-----------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%general_log%'; #查看普通日志是否开启\nshow variables like '%general_log_file%'; #查看普通日志文件的存放路径\n\nset global general_log=1; #开启普通日志\nset global general_log_file='/var/lib/mysql/general.log'; #指定普通日志文件的存放路径\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\ngeneral_log=1\ngeneral_log_file=/var/lib/mysql/general.log\n```\n\n当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。  \n结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log \n/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:\nTcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock\nTime                 Id Command    Argument\n210621 21:51:45\t    1 Connect\troot@localhost on \n\t\t    1 Connect\tAccess denied for user 'root'@'localhost' (using password: NO)\n210621 21:52:01\t    2 Connect\troot@localhost on \n\t\t    2 Query\tselect @@version_comment limit 1\n210621 21:52:51\t    2 Query\tSELECT DATABASE()\n\t\t    2 Init DB\ttest\n210621 21:53:00\t    2 Query\tselect * from a\n210621 21:53:03\t    2 Query\tselect * from a\n```\n\n***\n\n## 普通日志文件处理\n\n//TODO\n\n***\n\n\n# slow query log（慢查询日志）\n\n## 定义\n\nslow query log 是 MySQL 的慢查询日志。  \n主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。\n\n**注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。**  \n\n***\n\n## 相关参数\n\n以下是慢查询日志相关的参数：\n* slow_query_log：慢查询日志是否开启\n* slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。\n* long_query_time：设置慢查询的时间阈值，默认阈值是10s。\n* log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n* slow_queries：记录当前慢查询sql条数\n\n***\n\n## 开启慢查询日志\n\n查看慢查询日志的当前配置.  \n默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。\n```\nmysql> show variables like '%slow_query_log%';\n+---------------------+----------------------------------------+\n| Variable_name       | Value                                  |\n+---------------------+----------------------------------------+\n| slow_query_log      | OFF                                    |\n| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |\n+---------------------+----------------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%slow_query_log%'; #查看是否开启\nshow variables like '%slow_query_log_file%'; #查看慢查询日志文件的存放路径\n\nset global slow_query_log=1; #设置开启慢查询日志\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nslow_query_log=1\nslow_query_log_file=/var/lib/mysql/atguigu-slow.log\n```\n\n***\n\n## 什么 sql 会被记录到慢查询日志\n\n问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？  \n答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。\n\n### 记录响应时间超过阀值的sql语句\n\n时间阈值是由 long_query_time 控制的.  \nlong_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。\n\n命令：\n```sql\nshow variables LIKE 'long_query_time%'; #查看long_query_time的值\nset global long_query_time=5; #设置查询超过5秒则算慢查询sql\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlong_query_time=5\n```\n\n### 记录没有使用索引的查询语句\n\nlog_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n\n命令：\n```sql\nshow variables like '%log_queries_not_using_indexes%'; #查看值\nset global log_queries_not_using_indexes=1; #设置开启记录没有使用索引的查询语句\n```\n\n修改配置文件：（永久开启）  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\nlog_queries_not_using_indexes=1\n```\n\n## 慢查询 sql 案例\n\n``` sql\nset global slow_query_log=1; #设置开启慢查询日志\nset global long_query_time=3; #设置查询超过3秒则算慢查询sql（注意，这里是全局命令设置，需要重新连接才生效）\n\nselect sleep(4) #模拟一次查询，查询耗时4秒\nshow global status like '%slow_queries%'; #查询当前慢查询sql条数命令\n```\n\n去mysql的data目录下找到慢查询日志文件：  \n我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log  \n![慢查询日志图片](https://rong0624.github.io/images/MySQL/1624261484667.jpg)\n\n可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。\n\n***\n\n## 日志查询分析器（mysqldumpslow）\n\n日志查询分析器的体现：  \n在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。  \n![日志查询分析器帮助信息图片](https://rong0624.github.io/images/MySQL/日志查询分析器使用.jpg)\n\nmysqldumpslow --help  查看mysqldumpslow的帮助信息\n* s：表示按照何种方式排序\n* c：访问次数\n* l：锁定时间\n* r：返回记录\n* t：查询时间\n* al：平均锁定时间\n* ar：平均返回记录数\n* at：平均查询时间\n* t：即为返回前面多少条数据\n* g：后边搭配一个正则匹配模式，大小写不敏感。\n\n分析器常用的方式：\n``` sql\n#得到返回数据集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log\n\n#得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log\n\n#得到按照时间排序的前10条里面含有左连接的查询sql\nmysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log\n\n#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n```\n\n***\n\n# bin log（二进制日志）\n\n## 定义\nbin log 是 MySQL 的二进制文件，也叫归档日志。  \n主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一把不会被记录，因为他们不会对数据产生任何改动。  \n用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。\n\n> 重要的使用场景：  \n> mysql主从复制：mysql replication 在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  \n> 数据恢复：通过mysqlbinlog工具来恢复数据\n\n> 二进制日志包含两种文件：  \n> 二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  \n> 二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件\n\n***\n\n## 相关参数\n\nbin log相关参数：\n* log_bin：指定 bin log是否打开\n* log_bin_basename：指定的是 bin log 的基本文件名，后面会追加标识来表示每一个文件\n* log_bin_index：指定的是 bin log 文件的索引文件，这个文件管理了所有的 bin log 文件的目录\n\n***\n\n## 开启二进制日志\n\n查看二进制日志的当前配置：  \n可以看到，二进制日志默认是不开启的\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld] \nlog-bin=mysql-bin\nserver-id=001\n```\n\n修改配置文件后，重启服务配置生效  \n查看 bin log 日志文件  \n![bin log 日志文件](https://rong0624.github.io/images/MySQL/1624350274231.jpg)\n\n***\n\n## 查看二进制日志文件\n\n注意：  \n1）bin log日志与数据库文件在同目录中。  \n2）bin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的mysqlbinlog命令查看。  \n\n### mysqlbinlog 工具查看\n\nmysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。  \n在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上\"--no-defaults\"选项\n\n查看二进制日志文件：mysqlbinlog mysql-bin.000002\n```\n# at 391\n#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0\nSET TIMESTAMP=1624352800/*!*/;\ninsert into admin_info values(1, \"admin\", 100) #执行的sql\n/*!*/;\n# at 501\n#210622 17:06:40 server id 1  end_log_pos 528   Xid = 7 #执行的时间\n```\n> 图解  \n> server id 1：数据库主机的服务号  \n> end_log_pos 528：sql结束时的pos节点  \n> thread_id=11：线程号  \n\n### 命令查看\n\n> mysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息  \n> 介绍一种更为方便的查询命令 show bin log events\n\n命令解析 show bin log events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];    \n参数解析：  \na、IN 'log_name':指定要查询的bin log文件名（不指定就是第一个bin log文件  \nb、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）  \nc、LIMIT【offset】：偏移量(不指定就是0)  \nd、row_count :查询总条数（不指定就是所有行）  \n\nshow bin log events查询：\n```\nmysql> show bin log events in'mysql-bin.000002';\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |\n| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |\n| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |\n| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |\n| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, \"admin\", 100)                     |\n| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |\n| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n7 rows in set (0.00 sec)\n```\n\n***\n\n## 二进制日志文件常用操作命令\n\n1）查看所有 bin log 日志。  \nshow master logs;\n```\nmysql> show master logs;\n+------------------+-----------+\n| Log_name         | File_size |\n+------------------+-----------+\n| mysql-bin.000001 |       107 |\n+------------------+-----------+\n1 row in set (0.00 sec)\n```\n\n2）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。  \nshow master status;\n```\nmysql> show master status;\n+------------------+----------+--------------+------------------+\n| File             | Position | bin log_Do_DB | bin log_Ignore_DB |\n+------------------+----------+--------------+------------------+\n| mysql-bin.000001 |      107 |              |                  |\n+------------------+----------+--------------+------------------+\n1 row in set (0.00 sec)\n```\n\n3）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;  \nflush logs;\n\n注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；\n\n4）重置（清空）所有bin log日志;  \nreset master;\n\n***\n\n## 利用二进制日志恢复数据\n\n// TODO\n\n***\n\n# redo log（重做日志）\n\n## 定义\n\nredo log 是 MySQL 的物理日志，也叫重做日志，记录存储引擎 InnoDB 的事务日志。\n\nMySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。\n\n***\n\n# undo log（回滚日志）\n\n## 定义\n\n\n***\n\n## 相关参数\n\nundo log相关参数：\n* innodb_undo_logs :设置回滚日志的回滚段大小，默认为128k\n* innodb_undo_directory: 设置回滚日志存放的目录。\n* innodb_undo_tablespace:设置了回滚日志由多少个回滚日志文件组成，默认为0.\n\n***\n\n# relay log（中继日志）\n\n## 定义\n\nrelay-log中继日志是连接master和slave的核心.\n\n***","slug":"MySQL/MySQL-日志系统","published":1,"updated":"2021-06-25T13:37:06.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqcfpmjo000jhowm3bze2s9m","content":"<p>注意：当前设置系统参数方式，mysql重启即失效，如果要永久存在则需要修改配置文件。</p>\n<h1 id=\"error-log（错误日志）\"><a href=\"#error-log（错误日志）\" class=\"headerlink\" title=\"error log（错误日志）\"></a>error log（错误日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>error log 是 MySQL 的错误日志。<br>主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。<br>和其他的日志不同，MySQL的error日志必须开启，无法关闭。</p>\n<p><strong>注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。</strong></p>\n<hr>\n<span id=\"more\"></span>\n\n<h2 id=\"设置错误日志\"><a href=\"#设置错误日志\" class=\"headerlink\" title=\"设置错误日志\"></a>设置错误日志</h2><p>查看当前的错误日志文件<br>没有设置错误日志文件，默认指定了一个的错误日志文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_error&#x27;;</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| Variable_name | Value                |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| log_error     | ./VM-16-4-centos.err |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;log_error&#x27;</span>; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_error <span class=\"operator\">=</span> <span class=\"string\">&#x27;/var/lib/mysql/error.log&#x27;</span>; #设置错误日志文件</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">log-error=&#x27;/var/lib/mysql/error.log&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定错误配置文件，重启服务配置生效<br>可以看到当启动服务后，打印出Starting MySQL.Logging to ‘/var/lib/mysql/error.log’<br>这代表设置成功！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql stop</span><br><span class=\"line\">Shutting down MySQL. SUCCESS! </span><br><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql start</span><br><span class=\"line\">Starting MySQL.Logging to &#x27;/var/lib/mysql/error.log&#x27;.</span><br><span class=\"line\">. SUCCESS! </span><br></pre></td></tr></table></figure>\n\n<p>查看错误日志文件：<br>发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log </span><br><span class=\"line\">210621 18:35:41 [Note] Plugin &#x27;FEDERATED&#x27; is disabled.</span><br><span class=\"line\">210621 18:35:41 InnoDB: The InnoDB memory heap is disabled</span><br><span class=\"line\">210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class=\"line\">210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11</span><br><span class=\"line\">210621 18:35:41 InnoDB: Using Linux native AIO</span><br><span class=\"line\">210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M</span><br><span class=\"line\">210621 18:35:41 InnoDB: Completed initialization of buffer pool</span><br><span class=\"line\">210621 18:35:41 InnoDB: highest supported file format is Barracuda.</span><br><span class=\"line\">210621 18:35:41  InnoDB: Waiting for the background threads to start</span><br><span class=\"line\">210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913</span><br><span class=\"line\">210621 18:35:42 [Note] Server hostname (bind-address): &#x27;0.0.0.0&#x27;; port: 3306</span><br><span class=\"line\">210621 18:35:42 [Note]   - &#x27;0.0.0.0&#x27; resolves to &#x27;0.0.0.0&#x27;;</span><br><span class=\"line\">210621 18:35:42 [Note] Server socket created on IP: &#x27;0.0.0.0&#x27;.</span><br><span class=\"line\">210621 18:35:42 [Note] Event Scheduler: Loaded 0 events</span><br><span class=\"line\">210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.</span><br><span class=\"line\">Version: &#x27;5.5.62&#x27;  socket: &#x27;/var/lib/mysql/mysql.sock&#x27;  port: 3306  MySQL Community Server (GPL)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"general-log（普通日志）\"><a href=\"#general-log（普通日志）\" class=\"headerlink\" title=\"general log（普通日志）\"></a>general log（普通日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>general log 是 MySQL 的普通日志。<br>主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。</p>\n<p><strong>注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，<br>如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。<br>只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。</strong></p>\n<hr>\n<h2 id=\"相关参数\"><a href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>普通日志相关参数：</p>\n<ul>\n<li>general_log：是否开启普通日志</li>\n<li>general_log_file：普通日志文件的存放路径</li>\n</ul>\n<hr>\n<h2 id=\"开启普通日志\"><a href=\"#开启普通日志\" class=\"headerlink\" title=\"开启普通日志\"></a>开启普通日志</h2><p>查看普通日志的当前配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%general_log%&#x27;;</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| Variable_name    | Value                             |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| general_log      | OFF                               |</span><br><span class=\"line\">| general_log_file | /var/lib/mysql/VM-16-4-centos.log |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log%&#x27;</span>; #查看普通日志是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log_file%&#x27;</span>; #查看普通日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #开启普通日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log_file<span class=\"operator\">=</span><span class=\"string\">&#x27;/var/lib/mysql/general.log&#x27;</span>; #指定普通日志文件的存放路径</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">general_log=1</span><br><span class=\"line\">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。<br>结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log </span><br><span class=\"line\">/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:</span><br><span class=\"line\">Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock</span><br><span class=\"line\">Time                 Id Command    Argument</span><br><span class=\"line\">210621 21:51:45\t    1 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    1 Connect\tAccess denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)</span><br><span class=\"line\">210621 21:52:01\t    2 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    2 Query\tselect @@version_comment limit 1</span><br><span class=\"line\">210621 21:52:51\t    2 Query\tSELECT DATABASE()</span><br><span class=\"line\">\t\t    2 Init DB\ttest</span><br><span class=\"line\">210621 21:53:00\t    2 Query\tselect * from a</span><br><span class=\"line\">210621 21:53:03\t    2 Query\tselect * from a</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"普通日志文件处理\"><a href=\"#普通日志文件处理\" class=\"headerlink\" title=\"普通日志文件处理\"></a>普通日志文件处理</h2><p>//TODO</p>\n<hr>\n<h1 id=\"slow-query-log（慢查询日志）\"><a href=\"#slow-query-log（慢查询日志）\" class=\"headerlink\" title=\"slow query log（慢查询日志）\"></a>slow query log（慢查询日志）</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>slow query log 是 MySQL 的慢查询日志。<br>主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。</p>\n<p><strong>注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。</strong>  </p>\n<hr>\n<h2 id=\"相关参数-1\"><a href=\"#相关参数-1\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>以下是慢查询日志相关的参数：</p>\n<ul>\n<li>slow_query_log：慢查询日志是否开启</li>\n<li>slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。</li>\n<li>long_query_time：设置慢查询的时间阈值，默认阈值是10s。</li>\n<li>log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</li>\n<li>slow_queries：记录当前慢查询sql条数</li>\n</ul>\n<hr>\n<h2 id=\"开启慢查询日志\"><a href=\"#开启慢查询日志\" class=\"headerlink\" title=\"开启慢查询日志\"></a>开启慢查询日志</h2><p>查看慢查询日志的当前配置.<br>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| Variable_name       | Value                                  |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| slow_query_log      | OFF                                    |</span><br><span class=\"line\">| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>; #查看是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log_file%&#x27;</span>; #查看慢查询日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">slow_query_log=1</span><br><span class=\"line\">slow_query_log_file=/var/lib/mysql/atguigu-slow.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"什么-sql-会被记录到慢查询日志\"><a href=\"#什么-sql-会被记录到慢查询日志\" class=\"headerlink\" title=\"什么 sql 会被记录到慢查询日志\"></a>什么 sql 会被记录到慢查询日志</h2><p>问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？<br>答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。</p>\n<h3 id=\"记录响应时间超过阀值的sql语句\"><a href=\"#记录响应时间超过阀值的sql语句\" class=\"headerlink\" title=\"记录响应时间超过阀值的sql语句\"></a>记录响应时间超过阀值的sql语句</h3><p>时间阈值是由 long_query_time 控制的.<br>long_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;long_query_time%&#x27;</span>; #查看long_query_time的值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">5</span>; #设置查询超过<span class=\"number\">5</span>秒则算慢查询<span class=\"keyword\">sql</span></span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">long_query_time=5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"记录没有使用索引的查询语句\"><a href=\"#记录没有使用索引的查询语句\" class=\"headerlink\" title=\"记录没有使用索引的查询语句\"></a>记录没有使用索引的查询语句</h3><p>log_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%log_queries_not_using_indexes%&#x27;</span>; #查看值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_queries_not_using_indexes<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启记录没有使用索引的查询语句</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：（永久开启）<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"慢查询-sql-案例\"><a href=\"#慢查询-sql-案例\" class=\"headerlink\" title=\"慢查询 sql 案例\"></a>慢查询 sql 案例</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">3</span>; #设置查询超过<span class=\"number\">3</span>秒则算慢查询<span class=\"keyword\">sql</span>（注意，这里是全局命令设置，需要重新连接才生效）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> sleep(<span class=\"number\">4</span>) #模拟一次查询，查询耗时<span class=\"number\">4</span>秒</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_queries%&#x27;</span>; #查询当前慢查询<span class=\"keyword\">sql</span>条数命令</span><br></pre></td></tr></table></figure>\n\n<p>去mysql的data目录下找到慢查询日志文件：<br>我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log<br><img src=\"https://rong0624.github.io/images/MySQL/1624261484667.jpg\" alt=\"慢查询日志图片\"></p>\n<p>可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。</p>\n<hr>\n<h2 id=\"日志查询分析器（mysqldumpslow）\"><a href=\"#日志查询分析器（mysqldumpslow）\" class=\"headerlink\" title=\"日志查询分析器（mysqldumpslow）\"></a>日志查询分析器（mysqldumpslow）</h2><p>日志查询分析器的体现：<br>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。<br><img src=\"https://rong0624.github.io/images/MySQL/%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8.jpg\" alt=\"日志查询分析器帮助信息图片\"></p>\n<p>mysqldumpslow –help  查看mysqldumpslow的帮助信息</p>\n<ul>\n<li>s：表示按照何种方式排序</li>\n<li>c：访问次数</li>\n<li>l：锁定时间</li>\n<li>r：返回记录</li>\n<li>t：查询时间</li>\n<li>al：平均锁定时间</li>\n<li>ar：平均返回记录数</li>\n<li>at：平均查询时间</li>\n<li>t：即为返回前面多少条数据</li>\n<li>g：后边搭配一个正则匹配模式，大小写不敏感。</li>\n</ul>\n<p>分析器常用的方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#得到返回数据集最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>localhost<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到访问次数最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s c <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到按照时间排序的前<span class=\"number\">10</span>条里面含有左连接的查询<span class=\"keyword\">sql</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s t <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">-</span>g &quot;left join&quot; <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#另外建议在使用这些命令时结合 <span class=\"operator\">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span> more</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"bin-log（二进制日志）\"><a href=\"#bin-log（二进制日志）\" class=\"headerlink\" title=\"bin log（二进制日志）\"></a>bin log（二进制日志）</h1><h2 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>bin log 是 MySQL 的二进制文件，也叫归档日志。<br>主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一把不会被记录，因为他们不会对数据产生任何改动。<br>用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。</p>\n<blockquote>\n<p>重要的使用场景：<br>mysql主从复制：mysql replication 在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。<br>数据恢复：通过mysqlbinlog工具来恢复数据</p>\n</blockquote>\n<blockquote>\n<p>二进制日志包含两种文件：<br>二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件<br>二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件</p>\n</blockquote>\n<hr>\n<h2 id=\"相关参数-2\"><a href=\"#相关参数-2\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>bin log相关参数：</p>\n<ul>\n<li>log_bin：指定 bin log是否打开</li>\n<li>log_bin_basename：指定的是 bin log 的基本文件名，后面会追加标识来表示每一个文件</li>\n<li>log_bin_index：指定的是 bin log 文件的索引文件，这个文件管理了所有的 bin log 文件的目录</li>\n</ul>\n<hr>\n<h2 id=\"开启二进制日志\"><a href=\"#开启二进制日志\" class=\"headerlink\" title=\"开启二进制日志\"></a>开启二进制日志</h2><p>查看二进制日志的当前配置：<br>可以看到，二进制日志默认是不开启的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] </span><br><span class=\"line\">log-bin=mysql-bin</span><br><span class=\"line\">server-id=001</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件后，重启服务配置生效<br>查看 bin log 日志文件<br><img src=\"https://rong0624.github.io/images/MySQL/1624350274231.jpg\" alt=\"bin log 日志文件\"></p>\n<hr>\n<h2 id=\"查看二进制日志文件\"><a href=\"#查看二进制日志文件\" class=\"headerlink\" title=\"查看二进制日志文件\"></a>查看二进制日志文件</h2><p>注意：<br>1）bin log日志与数据库文件在同目录中。<br>2）bin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的mysqlbinlog命令查看。  </p>\n<h3 id=\"mysqlbinlog-工具查看\"><a href=\"#mysqlbinlog-工具查看\" class=\"headerlink\" title=\"mysqlbinlog 工具查看\"></a>mysqlbinlog 工具查看</h3><p>mysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。<br>在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上”–no-defaults”选项</p>\n<p>查看二进制日志文件：mysqlbinlog mysql-bin.000002</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># at 391</span><br><span class=\"line\">#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0</span><br><span class=\"line\">SET TIMESTAMP=1624352800/*!*/;</span><br><span class=\"line\">insert into admin_info values(1, &quot;admin&quot;, 100) #执行的sql</span><br><span class=\"line\">/*!*/;</span><br><span class=\"line\"># at 501</span><br><span class=\"line\">#210622 17:06:40 server id 1  end_log_pos 528   Xid = 7 #执行的时间</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>图解<br>server id 1：数据库主机的服务号<br>end_log_pos 528：sql结束时的pos节点<br>thread_id=11：线程号  </p>\n</blockquote>\n<h3 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h3><blockquote>\n<p>mysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息<br>介绍一种更为方便的查询命令 show bin log events</p>\n</blockquote>\n<p>命令解析 show bin log events [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count];<br>参数解析：<br>a、IN ‘log_name’:指定要查询的bin log文件名（不指定就是第一个bin log文件<br>b、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）<br>c、LIMIT【offset】：偏移量(不指定就是0)<br>d、row_count :查询总条数（不指定就是所有行）  </p>\n<p>show bin log events查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show bin log events in&#x27;mysql-bin.000002&#x27;;</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |</span><br><span class=\"line\">| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, &quot;admin&quot;, 100)                     |</span><br><span class=\"line\">| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |</span><br><span class=\"line\">| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"二进制日志文件常用操作命令\"><a href=\"#二进制日志文件常用操作命令\" class=\"headerlink\" title=\"二进制日志文件常用操作命令\"></a>二进制日志文件常用操作命令</h2><p>1）查看所有 bin log 日志。<br>show master logs;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master logs;</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| Log_name         | File_size |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| mysql-bin.000001 |       107 |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>2）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。<br>show master status;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| File             | Position | bin log_Do_DB | bin log_Ignore_DB |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| mysql-bin.000001 |      107 |              |                  |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>3）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;<br>flush logs;</p>\n<p>注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；</p>\n<p>4）重置（清空）所有bin log日志;<br>reset master;</p>\n<hr>\n<h2 id=\"利用二进制日志恢复数据\"><a href=\"#利用二进制日志恢复数据\" class=\"headerlink\" title=\"利用二进制日志恢复数据\"></a>利用二进制日志恢复数据</h2><p>// TODO</p>\n<hr>\n<h1 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h1><h2 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的物理日志，也叫重做日志，记录存储引擎 InnoDB 的事务日志。</p>\n<p>MySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。</p>\n<hr>\n<h1 id=\"undo-log（回滚日志）\"><a href=\"#undo-log（回滚日志）\" class=\"headerlink\" title=\"undo log（回滚日志）\"></a>undo log（回滚日志）</h1><h2 id=\"定义-5\"><a href=\"#定义-5\" class=\"headerlink\" title=\"定义\"></a>定义</h2><hr>\n<h2 id=\"相关参数-3\"><a href=\"#相关参数-3\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>undo log相关参数：</p>\n<ul>\n<li>innodb_undo_logs :设置回滚日志的回滚段大小，默认为128k</li>\n<li>innodb_undo_directory: 设置回滚日志存放的目录。</li>\n<li>innodb_undo_tablespace:设置了回滚日志由多少个回滚日志文件组成，默认为0.</li>\n</ul>\n<hr>\n<h1 id=\"relay-log（中继日志）\"><a href=\"#relay-log（中继日志）\" class=\"headerlink\" title=\"relay log（中继日志）\"></a>relay log（中继日志）</h1><h2 id=\"定义-6\"><a href=\"#定义-6\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>relay-log中继日志是连接master和slave的核心.</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>注意：当前设置系统参数方式，mysql重启即失效，如果要永久存在则需要修改配置文件。</p>\n<h1 id=\"error-log（错误日志）\"><a href=\"#error-log（错误日志）\" class=\"headerlink\" title=\"error log（错误日志）\"></a>error log（错误日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>error log 是 MySQL 的错误日志。<br>主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。<br>和其他的日志不同，MySQL的error日志必须开启，无法关闭。</p>\n<p><strong>注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。</strong></p>\n<hr>","more":"<h2 id=\"设置错误日志\"><a href=\"#设置错误日志\" class=\"headerlink\" title=\"设置错误日志\"></a>设置错误日志</h2><p>查看当前的错误日志文件<br>没有设置错误日志文件，默认指定了一个的错误日志文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_error&#x27;;</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| Variable_name | Value                |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| log_error     | ./VM-16-4-centos.err |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;log_error&#x27;</span>; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_error <span class=\"operator\">=</span> <span class=\"string\">&#x27;/var/lib/mysql/error.log&#x27;</span>; #设置错误日志文件</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">log-error=&#x27;/var/lib/mysql/error.log&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定错误配置文件，重启服务配置生效<br>可以看到当启动服务后，打印出Starting MySQL.Logging to ‘/var/lib/mysql/error.log’<br>这代表设置成功！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql stop</span><br><span class=\"line\">Shutting down MySQL. SUCCESS! </span><br><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql start</span><br><span class=\"line\">Starting MySQL.Logging to &#x27;/var/lib/mysql/error.log&#x27;.</span><br><span class=\"line\">. SUCCESS! </span><br></pre></td></tr></table></figure>\n\n<p>查看错误日志文件：<br>发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log </span><br><span class=\"line\">210621 18:35:41 [Note] Plugin &#x27;FEDERATED&#x27; is disabled.</span><br><span class=\"line\">210621 18:35:41 InnoDB: The InnoDB memory heap is disabled</span><br><span class=\"line\">210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class=\"line\">210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11</span><br><span class=\"line\">210621 18:35:41 InnoDB: Using Linux native AIO</span><br><span class=\"line\">210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M</span><br><span class=\"line\">210621 18:35:41 InnoDB: Completed initialization of buffer pool</span><br><span class=\"line\">210621 18:35:41 InnoDB: highest supported file format is Barracuda.</span><br><span class=\"line\">210621 18:35:41  InnoDB: Waiting for the background threads to start</span><br><span class=\"line\">210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913</span><br><span class=\"line\">210621 18:35:42 [Note] Server hostname (bind-address): &#x27;0.0.0.0&#x27;; port: 3306</span><br><span class=\"line\">210621 18:35:42 [Note]   - &#x27;0.0.0.0&#x27; resolves to &#x27;0.0.0.0&#x27;;</span><br><span class=\"line\">210621 18:35:42 [Note] Server socket created on IP: &#x27;0.0.0.0&#x27;.</span><br><span class=\"line\">210621 18:35:42 [Note] Event Scheduler: Loaded 0 events</span><br><span class=\"line\">210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.</span><br><span class=\"line\">Version: &#x27;5.5.62&#x27;  socket: &#x27;/var/lib/mysql/mysql.sock&#x27;  port: 3306  MySQL Community Server (GPL)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"general-log（普通日志）\"><a href=\"#general-log（普通日志）\" class=\"headerlink\" title=\"general log（普通日志）\"></a>general log（普通日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>general log 是 MySQL 的普通日志。<br>主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。</p>\n<p><strong>注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，<br>如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。<br>只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。</strong></p>\n<hr>\n<h2 id=\"相关参数\"><a href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>普通日志相关参数：</p>\n<ul>\n<li>general_log：是否开启普通日志</li>\n<li>general_log_file：普通日志文件的存放路径</li>\n</ul>\n<hr>\n<h2 id=\"开启普通日志\"><a href=\"#开启普通日志\" class=\"headerlink\" title=\"开启普通日志\"></a>开启普通日志</h2><p>查看普通日志的当前配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%general_log%&#x27;;</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| Variable_name    | Value                             |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| general_log      | OFF                               |</span><br><span class=\"line\">| general_log_file | /var/lib/mysql/VM-16-4-centos.log |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log%&#x27;</span>; #查看普通日志是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log_file%&#x27;</span>; #查看普通日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #开启普通日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log_file<span class=\"operator\">=</span><span class=\"string\">&#x27;/var/lib/mysql/general.log&#x27;</span>; #指定普通日志文件的存放路径</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">general_log=1</span><br><span class=\"line\">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。<br>结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log </span><br><span class=\"line\">/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:</span><br><span class=\"line\">Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock</span><br><span class=\"line\">Time                 Id Command    Argument</span><br><span class=\"line\">210621 21:51:45\t    1 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    1 Connect\tAccess denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)</span><br><span class=\"line\">210621 21:52:01\t    2 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    2 Query\tselect @@version_comment limit 1</span><br><span class=\"line\">210621 21:52:51\t    2 Query\tSELECT DATABASE()</span><br><span class=\"line\">\t\t    2 Init DB\ttest</span><br><span class=\"line\">210621 21:53:00\t    2 Query\tselect * from a</span><br><span class=\"line\">210621 21:53:03\t    2 Query\tselect * from a</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"普通日志文件处理\"><a href=\"#普通日志文件处理\" class=\"headerlink\" title=\"普通日志文件处理\"></a>普通日志文件处理</h2><p>//TODO</p>\n<hr>\n<h1 id=\"slow-query-log（慢查询日志）\"><a href=\"#slow-query-log（慢查询日志）\" class=\"headerlink\" title=\"slow query log（慢查询日志）\"></a>slow query log（慢查询日志）</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>slow query log 是 MySQL 的慢查询日志。<br>主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。</p>\n<p><strong>注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。</strong>  </p>\n<hr>\n<h2 id=\"相关参数-1\"><a href=\"#相关参数-1\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>以下是慢查询日志相关的参数：</p>\n<ul>\n<li>slow_query_log：慢查询日志是否开启</li>\n<li>slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。</li>\n<li>long_query_time：设置慢查询的时间阈值，默认阈值是10s。</li>\n<li>log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</li>\n<li>slow_queries：记录当前慢查询sql条数</li>\n</ul>\n<hr>\n<h2 id=\"开启慢查询日志\"><a href=\"#开启慢查询日志\" class=\"headerlink\" title=\"开启慢查询日志\"></a>开启慢查询日志</h2><p>查看慢查询日志的当前配置.<br>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| Variable_name       | Value                                  |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| slow_query_log      | OFF                                    |</span><br><span class=\"line\">| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>; #查看是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log_file%&#x27;</span>; #查看慢查询日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">slow_query_log=1</span><br><span class=\"line\">slow_query_log_file=/var/lib/mysql/atguigu-slow.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"什么-sql-会被记录到慢查询日志\"><a href=\"#什么-sql-会被记录到慢查询日志\" class=\"headerlink\" title=\"什么 sql 会被记录到慢查询日志\"></a>什么 sql 会被记录到慢查询日志</h2><p>问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？<br>答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。</p>\n<h3 id=\"记录响应时间超过阀值的sql语句\"><a href=\"#记录响应时间超过阀值的sql语句\" class=\"headerlink\" title=\"记录响应时间超过阀值的sql语句\"></a>记录响应时间超过阀值的sql语句</h3><p>时间阈值是由 long_query_time 控制的.<br>long_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;long_query_time%&#x27;</span>; #查看long_query_time的值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">5</span>; #设置查询超过<span class=\"number\">5</span>秒则算慢查询<span class=\"keyword\">sql</span></span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">long_query_time=5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"记录没有使用索引的查询语句\"><a href=\"#记录没有使用索引的查询语句\" class=\"headerlink\" title=\"记录没有使用索引的查询语句\"></a>记录没有使用索引的查询语句</h3><p>log_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%log_queries_not_using_indexes%&#x27;</span>; #查看值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_queries_not_using_indexes<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启记录没有使用索引的查询语句</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：（永久开启）<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"慢查询-sql-案例\"><a href=\"#慢查询-sql-案例\" class=\"headerlink\" title=\"慢查询 sql 案例\"></a>慢查询 sql 案例</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">3</span>; #设置查询超过<span class=\"number\">3</span>秒则算慢查询<span class=\"keyword\">sql</span>（注意，这里是全局命令设置，需要重新连接才生效）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> sleep(<span class=\"number\">4</span>) #模拟一次查询，查询耗时<span class=\"number\">4</span>秒</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_queries%&#x27;</span>; #查询当前慢查询<span class=\"keyword\">sql</span>条数命令</span><br></pre></td></tr></table></figure>\n\n<p>去mysql的data目录下找到慢查询日志文件：<br>我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log<br><img src=\"https://rong0624.github.io/images/MySQL/1624261484667.jpg\" alt=\"慢查询日志图片\"></p>\n<p>可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。</p>\n<hr>\n<h2 id=\"日志查询分析器（mysqldumpslow）\"><a href=\"#日志查询分析器（mysqldumpslow）\" class=\"headerlink\" title=\"日志查询分析器（mysqldumpslow）\"></a>日志查询分析器（mysqldumpslow）</h2><p>日志查询分析器的体现：<br>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。<br><img src=\"https://rong0624.github.io/images/MySQL/%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8.jpg\" alt=\"日志查询分析器帮助信息图片\"></p>\n<p>mysqldumpslow –help  查看mysqldumpslow的帮助信息</p>\n<ul>\n<li>s：表示按照何种方式排序</li>\n<li>c：访问次数</li>\n<li>l：锁定时间</li>\n<li>r：返回记录</li>\n<li>t：查询时间</li>\n<li>al：平均锁定时间</li>\n<li>ar：平均返回记录数</li>\n<li>at：平均查询时间</li>\n<li>t：即为返回前面多少条数据</li>\n<li>g：后边搭配一个正则匹配模式，大小写不敏感。</li>\n</ul>\n<p>分析器常用的方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#得到返回数据集最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>localhost<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到访问次数最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s c <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到按照时间排序的前<span class=\"number\">10</span>条里面含有左连接的查询<span class=\"keyword\">sql</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s t <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">-</span>g &quot;left join&quot; <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#另外建议在使用这些命令时结合 <span class=\"operator\">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span> more</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"bin-log（二进制日志）\"><a href=\"#bin-log（二进制日志）\" class=\"headerlink\" title=\"bin log（二进制日志）\"></a>bin log（二进制日志）</h1><h2 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>bin log 是 MySQL 的二进制文件，也叫归档日志。<br>主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一把不会被记录，因为他们不会对数据产生任何改动。<br>用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。</p>\n<blockquote>\n<p>重要的使用场景：<br>mysql主从复制：mysql replication 在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。<br>数据恢复：通过mysqlbinlog工具来恢复数据</p>\n</blockquote>\n<blockquote>\n<p>二进制日志包含两种文件：<br>二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件<br>二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件</p>\n</blockquote>\n<hr>\n<h2 id=\"相关参数-2\"><a href=\"#相关参数-2\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>bin log相关参数：</p>\n<ul>\n<li>log_bin：指定 bin log是否打开</li>\n<li>log_bin_basename：指定的是 bin log 的基本文件名，后面会追加标识来表示每一个文件</li>\n<li>log_bin_index：指定的是 bin log 文件的索引文件，这个文件管理了所有的 bin log 文件的目录</li>\n</ul>\n<hr>\n<h2 id=\"开启二进制日志\"><a href=\"#开启二进制日志\" class=\"headerlink\" title=\"开启二进制日志\"></a>开启二进制日志</h2><p>查看二进制日志的当前配置：<br>可以看到，二进制日志默认是不开启的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] </span><br><span class=\"line\">log-bin=mysql-bin</span><br><span class=\"line\">server-id=001</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件后，重启服务配置生效<br>查看 bin log 日志文件<br><img src=\"https://rong0624.github.io/images/MySQL/1624350274231.jpg\" alt=\"bin log 日志文件\"></p>\n<hr>\n<h2 id=\"查看二进制日志文件\"><a href=\"#查看二进制日志文件\" class=\"headerlink\" title=\"查看二进制日志文件\"></a>查看二进制日志文件</h2><p>注意：<br>1）bin log日志与数据库文件在同目录中。<br>2）bin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的mysqlbinlog命令查看。  </p>\n<h3 id=\"mysqlbinlog-工具查看\"><a href=\"#mysqlbinlog-工具查看\" class=\"headerlink\" title=\"mysqlbinlog 工具查看\"></a>mysqlbinlog 工具查看</h3><p>mysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。<br>在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上”–no-defaults”选项</p>\n<p>查看二进制日志文件：mysqlbinlog mysql-bin.000002</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># at 391</span><br><span class=\"line\">#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0</span><br><span class=\"line\">SET TIMESTAMP=1624352800/*!*/;</span><br><span class=\"line\">insert into admin_info values(1, &quot;admin&quot;, 100) #执行的sql</span><br><span class=\"line\">/*!*/;</span><br><span class=\"line\"># at 501</span><br><span class=\"line\">#210622 17:06:40 server id 1  end_log_pos 528   Xid = 7 #执行的时间</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>图解<br>server id 1：数据库主机的服务号<br>end_log_pos 528：sql结束时的pos节点<br>thread_id=11：线程号  </p>\n</blockquote>\n<h3 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h3><blockquote>\n<p>mysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息<br>介绍一种更为方便的查询命令 show bin log events</p>\n</blockquote>\n<p>命令解析 show bin log events [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count];<br>参数解析：<br>a、IN ‘log_name’:指定要查询的bin log文件名（不指定就是第一个bin log文件<br>b、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）<br>c、LIMIT【offset】：偏移量(不指定就是0)<br>d、row_count :查询总条数（不指定就是所有行）  </p>\n<p>show bin log events查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show bin log events in&#x27;mysql-bin.000002&#x27;;</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |</span><br><span class=\"line\">| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, &quot;admin&quot;, 100)                     |</span><br><span class=\"line\">| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |</span><br><span class=\"line\">| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"二进制日志文件常用操作命令\"><a href=\"#二进制日志文件常用操作命令\" class=\"headerlink\" title=\"二进制日志文件常用操作命令\"></a>二进制日志文件常用操作命令</h2><p>1）查看所有 bin log 日志。<br>show master logs;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master logs;</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| Log_name         | File_size |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| mysql-bin.000001 |       107 |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>2）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。<br>show master status;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| File             | Position | bin log_Do_DB | bin log_Ignore_DB |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| mysql-bin.000001 |      107 |              |                  |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>3）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;<br>flush logs;</p>\n<p>注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；</p>\n<p>4）重置（清空）所有bin log日志;<br>reset master;</p>\n<hr>\n<h2 id=\"利用二进制日志恢复数据\"><a href=\"#利用二进制日志恢复数据\" class=\"headerlink\" title=\"利用二进制日志恢复数据\"></a>利用二进制日志恢复数据</h2><p>// TODO</p>\n<hr>\n<h1 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h1><h2 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的物理日志，也叫重做日志，记录存储引擎 InnoDB 的事务日志。</p>\n<p>MySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。</p>\n<hr>\n<h1 id=\"undo-log（回滚日志）\"><a href=\"#undo-log（回滚日志）\" class=\"headerlink\" title=\"undo log（回滚日志）\"></a>undo log（回滚日志）</h1><h2 id=\"定义-5\"><a href=\"#定义-5\" class=\"headerlink\" title=\"定义\"></a>定义</h2><hr>\n<h2 id=\"相关参数-3\"><a href=\"#相关参数-3\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>undo log相关参数：</p>\n<ul>\n<li>innodb_undo_logs :设置回滚日志的回滚段大小，默认为128k</li>\n<li>innodb_undo_directory: 设置回滚日志存放的目录。</li>\n<li>innodb_undo_tablespace:设置了回滚日志由多少个回滚日志文件组成，默认为0.</li>\n</ul>\n<hr>\n<h1 id=\"relay-log（中继日志）\"><a href=\"#relay-log（中继日志）\" class=\"headerlink\" title=\"relay log（中继日志）\"></a>relay log（中继日志）</h1><h2 id=\"定义-6\"><a href=\"#定义-6\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>relay-log中继日志是连接master和slave的核心.</p>\n<hr>"},{"title":"Dubbo","date":"2021-06-24T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 扩展知识\n\n## 什么是分布式系统\n\n分布式系统原理与泛型中定义：  \n分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。\n\n<!-- more -->\n\n## 发展演变\n\n![架构发展演变](https://rong0624.github.io/images/Dubbo/架构发展演变.png)\n\n单一应用架构：  \n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。\n\n垂直应用架构：  \n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。   \n此时，用于加速前端页面开发的 Web框架(MVC) 是关键。\n\n分布式服务架构：  \n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  \n此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。\n\n流动计算架构：  \n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 \n此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。\n\n## RPC\n\n什么叫PRC：  \nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n\nRPC原理：  \n![rpc通讯](https://rong0624.github.io/images/Dubbo/rpc通讯.png)  \n![rpc序列化](https://rong0624.github.io/images/Dubbo/rpc序列化.png)  \nRPC两个核心模块：通讯，序列化。\n\n# Dubbo入门\n\n## 简介\n\nDubbo 是一款高性能、轻量级的开源Java RPC框架。  \nDubbo 是分布式服务治理框架。\n\n提供了三大核心能力：  \n面向接口的远程方法调用  \n集群容错（容错与负债均衡）  \n服务自动注册与发现\n\n官网：http://dubbo.apache.org/\n\n## Dubbo能做什么\n\n问题:  \n服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)  \n各个服务之间依赖管理非常复杂  \n各个服务之间如何进行监控\n\n（1）面向接口的远程方法调用：  \n就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。\n\n（2）智能容错与负债均衡：  \n可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。\n\n（3）服务自动注册与发现：  \n不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。\n\n（4）服务监控：  \n监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。\n\n## Dubbo架构\n\n![dubbo架构图](https://rong0624.github.io/images/Dubbo/dubbo架构图.png)  \n\n### 节点角色说明\n\n服务提供者（Provider）：  \n暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n\n服务消费者（Consumer）:   \n调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n注册中心（Registry）：  \n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n\n监控中心（Monitor）：  \n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n\n### 调用关系说明\n\n（1）服务容器负责启动，加载，运行服务提供者。  \n（2）服务提供者在启动时，向注册中心注册自己提供的服务。  \n（3）服务消费者在启动时，向注册中心订阅自己所需的服务。  \n（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。  \n（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。  \n（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n# Dubbo Hello world\n\n## 环境准备\n\nDubbo学习前必须掌握以下内容：  \nZookeeper的使用经验  \nSpring框架的使用经验  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11\n\n注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。\n\n## 提出需求\n\n某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；\n\n我们现在需要创建两个服务模块进行测试：  \n订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。  \norder-web（订单模块，web，服务消费者）  \nuser-service（用户模块，service，服务提供者）\n\n## 工程架构\n\n根据 dubbo《服务化最佳实践》 \n\n### 分包\n\n建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。\n\n如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。\n\n### 粒度\n\n服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。  \n服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。  \n不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。\n\n### 结构\n\nuser模块：  \nuser-api 提供接口  \nuser-impl 接口实现层，服务提供者\n\n\norder模块：  \norder-web：服务消费者\n\n## 服务提供者\n\nuser项目总览：  \n创建user项目，这是一个聚合工程。  \n创建user-api，这是user公共接口层（提供接口）。  \n创建user-imp，这是user接口的实现层（服务提供者）。\n\n### user-api（提供user公共接口）\n\n（1）用户地址DTO：\n```java\npublic class UserAddressDto implements Serializable {\n\n    private Integer id;\n    private String userId;\n    private String userAddress;\n    private String consignee;\n    private String phone;\n    private String isDefault;\n}\n```\n\n（2）用户地址接口定义\n```java\npublic interface UserService {\n    List<UserAddressDto> getUserAddress(String userId);\n}\n```\n\n### user-impl（接口实现，服务提供者）\n\n（1）pom.xml导入依赖：\n```xml\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!--\n        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n        dubbo 2.6以前的版本引入zkclient操作zookeeper\n        dubbo 2.6及以后的版本引入curator操作zookeeper\n        下面两个zk客户端根据dubbo版本2选1即可\n    -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）实现用户地址接口：\n```java\npublic class UserServiceImpl implements UserService {\n\n    public final static Map<String, List<UserAddressDto>> map;\n\n    static {\n        List<UserAddressDto> list1 = Stream.of(new UserAddressDto(1, \"1\", \"江西赣州\", \"欧阳\", \"152*****\", false),\n                new UserAddressDto(2, \"1\", \"广东深圳\", \"欧阳\", \"152*****\", true),\n                new UserAddressDto(1, \"1\", \"浙江上海\", \"欧阳\", \"152*****\", false))\n                .collect(Collectors.toList());\n        List<UserAddressDto> list2 = Stream.of(new UserAddressDto(3, \"2\", \"江西赣州\", \"东华\", \"152*****\", false),\n                new UserAddressDto(4, \"2\", \"广东深圳\", \"东华\", \"152*****\", true),\n                new UserAddressDto(5, \"2\", \"浙江上海\", \"东华\", \"152*****\", false))\n                .collect(Collectors.toList());\n\n        map = new HashMap<>();\n        map.put(\"1\", list1);\n        map.put(\"2\", list2);\n    }\n\n    @Override\n    public List<UserAddressDto> getUserAddress(String userId) {\n        return map.get(userId);\n    }\n\n}\n```\n\n（3）服务提供者配置：\n新增provider.xml文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://code.alibabatech.com/schema/dubbo\n       http://code.alibabatech.com/schema/dubbo/dubbo.xsd \">\n\n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"user-provider\" />\n\n    <!-- 指定注册中心地址，使用zookeeper暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 用dubbo协议，将服务暴露在20880端口 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n\n    <!-- 声明需要暴露的服务接口 -->\n    <dubbo:service interface=\"com.oyr.user.service.UserService\"\n                   ref=\"userServiceImpl\" />\n\n    <!-- 将接口实现类提交到容器中 -->\n    <bean id=\"userServiceImpl\" class=\"com.oyr.user.service.impl.UserServiceImpl\" />\n</beans>\n```\n\n（4）启动服务提供者\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:provider.xml\");\n        System.in.read();\n    }\n\n}\n```\n注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。\n\n## 服务消费者\n\n（1）pom.xml导入依赖\n```xml\n<!-- 依赖user-api -->\n<dependency>\n    <groupId>com.oyr</groupId>\n    <artifactId>user-api</artifactId>\n    <version>${parent.version}</version>\n</dependency>\n\n<!-- dubbo -->\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.7.7</version>\n</dependency>\n<!--\n    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n    dubbo 2.6以前的版本引入zkclient操作zookeeper\n    dubbo 2.6及以后的版本引入curator操作zookeeper\n    下面两个zk客户端根据dubbo版本2选1即可\n-->\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>2.12.0</version>\n</dependency>\n```\n\n（2）服务消费者配置\n新增consumer.xml文件\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 -->\n    <dubbo:application name=\"order-consumer\" />\n\n    <!-- 指定注册中心，通过注册中心发现服务提供者地址 -->\n    <dubbo:registry protocol=\"zookeeper\" address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 生成远程服务代理，可以和本地bean一样使用userService -->\n    <dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" />\n\n</beans>\n```\n\n（3）启动消费者，尝试调用服务提供者\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:consumer.xml\");\n        UserService userService = context.getBean(UserService.class);\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。  \n说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。\n\n## 注解版\n\n@DubboComponentScan  \n使用dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n## Dubbo支持哪些协议\n\n### Dubbo协议\n\nDubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\n\n### Hessian协议\n\nHessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。Hessian是Caucho开源的一个RPC框架：http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。\n\n基于Hessian的远程调用协议:\n连接个数：多连接  \n连接方式：短连接  \n传输协议：HTTP  \n传输方式：同步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。  \n适用场景：页面传输，文件传输，或与原生hessian服务互操作\n\n### HTTP协议\n\n此协议采用 spring 的HttpInvoker的功能实现，\n\n基于HTTP的远程调用协议:  \n连接个数：多个  \n连接方式：长连接  \n连接协议：http  \n传输方式：同步传输  \n序列化：表单序列化  \n适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。  \n适用场景：需同时给应用程序和浏览器JS使用的服务。\n\n### RMI协议\n\n采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式\n\n基于RMI协议的远程调用协议:  \n连接个数：多连接  \n连接方式：短连接  \n传输协议：TCP  \n传输方式：同步传输\n序列化：Java标准二进制序列化  \n适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  \n适用场景：常规远程服务方法调用，与原生RMI服务互操作\n\n# 整合Spring Boot\n\n基于hello world项目改造成spring boot项目。\n\n## 环境准备\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11  \nSpring Boot 2.2.4.RELEASE\n\n## 服务提供者改造\n\nuser-api不改动，改动user-impl，以下改动都是user-impl的。\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）修改接口实现UserServiceImpl （类上加入DubboService）\n```java\n@DubboService // 暴露当前服务\npublic class UserServiceImpl implements UserService {\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n（4）修改启动类，并且启动服务提供者\n```java\n// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）\n@EnableDubbo\n@SpringBootApplication\npublic class Provider {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Provider.class, args);\n    }\n\n}\n```\n\n修改后，启动成功！！！\n\n## 服务消费者改造\n\n改动order-web（服务消费者）\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）新增controller\n```java\n@RestController\npublic class DubboController {\n\n    @DubboReference\n    private UserService userService;\n\n    @GetMapping(\"/dubbo\")\n    public void dubbo() {\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=cms-wms\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.consumer.client=netty\ndubbo.consumer.check=false\n```\n\n（4）修改启动类\n```java\n@EnableDubbo // 开启dubbo，扫描dubbo注解\n@SpringBootApplication\npublic class Consumer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Consumer.class, args);\n    }\n\n}\n```\n\n（5）测试，尝试远程调用是否成功  \n\n访问http://localhost:8080/dubbo  \n后台成功打印出客户地址列表  \n远程调用成功！！！！\n\n## 配置解释\n\n@EnableDubbo（组合型注解）  \n开启dubbo，扫描dubbo注解。  \n里面有dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n服务提供者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n服务消费者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=order-consumer\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\n```\n\n配置解释：  \ndubbo.application.nam：就是服务名，不能和其他服务提供者重复  \ndubbo.registry.protocol：指定注册中心协议  \ndubbo.registry.address：指定注册中心访问地址（地址加端口号）  \ndubbo.protocol.name：固定是dubbo，不要改  \ndubbo.protocol.port：指定服务提供者暴露的端口\n\n\n# Dubbo 配置详解\n\n注意：以下针对xml配置讲解，注解版差不多一致。\n\n## 重试次数\n\n失败自动重试：  \n当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。\n\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置重试 -->\n<dubbo:provider retries=\"2\" />\n\n<!-- 提供者指定接口重试 -->\n<dubbo:service retries=\"2\" />\n\n<!-- 提供者指定接口某个方法设置重试 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" retries=\"2\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 服务消费者全局配置重试 -->\n<dubbo:consumer retries=\"2\" />\n\n<!-- 服务消费者指定接口设置重试 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" retries=\"2\"/>\n```\n\n## 超时时间\n\n由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置超时时间 -->\n<dubbo:provider timeout=\"5000\" />\n\n<!-- 提供者指定接口以及某个方法配置超时时间 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" timeout=\"5000\" >\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 消费者全局配置超时时间 -->\n<dubbo:consumer timeout=\"3000\"/>\n\n<!-- 消费者指定接口和某个方法配置超时时间 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" timeout=\"5000\">\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\"/>\n</dubbo:reference>\n```\n\n## 版本号\n\n当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。\n\n可以按照以下的步骤进行版本迁移：  \n在低压力时间段，先升级一半提供者为新版本  \n再将所有消费者升级为新版本  \n然后将剩下的一半提供者升级为新版本\n\n```xml\n老版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n老版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n如果不需要区分版本，可以按照以下的方式配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"*\" />\n```\n\n## 配置原则\n\nDubbo推荐在Provider上尽量多配置Consumer端属性。  \n1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等  \n2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的\n\n## 属性配置覆盖规则\n\n![属性配置覆盖规则](https://rong0624.github.io/images/Dubbo/属性配置覆盖规则.png)\n\n1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先 \n2）Consumer端配置优于 Provider配置\n3）最后是Dubbo Hard Code的配置值（见配置文档）\n\n## 配置文件覆盖规则\n\n![配置文件覆盖规则](https://rong0624.github.io/images/Dubbo/配置文件覆盖规则.png)\n\n1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。  \n2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。  \n3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。\n\n# Dubbo-Admin监控中心\n\n## 监控中心简介\n\n监控中心：\n图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。\n\n监控中心：\n是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。\n\n## 搭建监控中心\n\n注意：dubbo-admin有多种启动方式  \n通过jar包方式启动，jar包形式。  \n通过war包方式启动，依赖tomcat容器。  \n通过导入eclipse或idea启动\n\n最新的dubbo-admin是前后端分离的（新版本），可以看教程：  \nhttps://blog.csdn.net/muriyue6/article/details/109304584\n\n**注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）**\n\n下载dubbo-admin项目：https://github.com/apache/incubator-dubbo-ops\n![incubator-dubbo-ops](https://rong0624.github.io/images/Dubbo/incubator-dubbo-ops.png)\n\n### war包启动\n\n1）先准备好dubbo-admin项目\n\n2）准备好tomcat，将dubbo-admin放到webapps目录下\n\n3）修改dubbo.properties文件内容\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root123\n# 指定guest账号密码\ndubbo.admin.guest.password=guest123\n```\n\n4）启动tomcat测试，尝试访问监控中心  \n在tomcat下，bin目录，通过startup.bat启动tomcat。  \n访问http://localhost:8080/dubbo-admin  \n![dubbo监控中心登录页面](https://rong0624.github.io/images/Dubbo/dubbo监控中心登录页面.png)  \n注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。  \n![dubbo监控中心页面](https://rong0624.github.io/images/Dubbo/dubbo监控中心页面.png)  \n最后成功进入监控中心界面！！！\n\n### jar包启动\n\n1）先准备好dubbo-admin项目\n\n2）修改application.properties配置\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root\n# 指定guest账号密码\ndubbo.admin.guest.password=guest\n```\n\n3）打包dubbo-admin\nmvn clean package -Dmaven.test.skip=true\n\n4）运行dubbo-admin.jar，尝试访问监控中心  \njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar  \n使用root/root登录  \n![dubbo监控中心页面](https://rong0624.github.io/images/Dubbo/dubbo监控中心页面.png)\n\n# Dubbo 高可用\n\n## 集群\n\nDubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的application.name相同，Dubbo则会认为是同一集群。\n\n## 集群容错\n\n集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。\n\n### 集群容错\n\n```\nFailover Cluster\n失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。\n\n重试次数配置如下：\n<dubbo:service retries=\"2\" />\n或\n<dubbo:reference retries=\"2\" />\n或\n<dubbo:reference>\n    <dubbo:method name=\"findFoo\" retries=\"2\" />\n</dubbo:reference>\n\nFailfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\nFailsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\nFailback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\nForking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\nBroadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n```\n\n### 集群模式配置\n\n按照以下示例在服务提供方和消费方配置集群模式\n```\n<dubbo:service cluster=\"failsafe\" />\n或\n<dubbo:reference cluster=\"failsafe\" />\n```\n\n## 负债均衡策略\n\n集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。\n\n### 负载均衡策略\n\n```\nRandom LoadBalance\n随机均衡算法，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n权重轮循均衡算法，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\nLeastActive LoadBalance\n最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```\n\n### 负债均衡配置\n\n负债均衡配置很简单。\n服务端和客户端都可以配置服务级别或者方法级别的策略。\n\n服务提供者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:provider loadbalance=\"roundrobin\" />\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" loadbalance=\"roundrobin\" >\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:service>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:service>\n```\n\n服务消费者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:consumer timeout=\"3000\" loadbalance=\"roundrobin\"/>\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" loadbalance=\"roundrobin\">\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:reference>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:reference>\n```\n\n## 注册中心宕机与Dubbo直连\n\n### 注册中心宕机问题\n\n在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。\n\n健壮性  \n监控中心宕掉不影响使用，只是丢失部分采样数据  \n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务  \n注册中心对等集群，任意一台宕掉后，将自动切换到另一台  \n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯  \n服务提供者无状态，任意一台宕掉后，不影响使用  \n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n### 直连模式\n\n注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。  \n点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。\n\nxml配置方式：\n```xml\n<dubbo:reference id=\"userService\" \ninterface=\"com.zang.gmall.service.UserService\" url=\"dubbo://localhost:20880\" />\n```\n\n注解方式：\n```java\n@Reference(url = \"127.0.0.1:20880\")   \n UserService userService;\n```\n\n# Hystrix 断路器\n\n## 服务降级\n\n服务降级概念：  \n当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。\n\n## 服务熔断\n\n服务熔断概念：  \n我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。\n\n同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n服务熔断机制和服务降级是一起使用。\n\n# Dubbo原理\n\n## RPC原理\n\n## Dubbo原理\n","source":"_posts/Dubbo/Dubbo.md","raw":"---\ntitle: Dubbo\ndate: 2021-06-25 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: Dubbo\ncategories: Dubbo\n---\n\n# 扩展知识\n\n## 什么是分布式系统\n\n分布式系统原理与泛型中定义：  \n分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。\n\n<!-- more -->\n\n## 发展演变\n\n![架构发展演变](https://rong0624.github.io/images/Dubbo/架构发展演变.png)\n\n单一应用架构：  \n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。\n\n垂直应用架构：  \n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。   \n此时，用于加速前端页面开发的 Web框架(MVC) 是关键。\n\n分布式服务架构：  \n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  \n此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。\n\n流动计算架构：  \n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 \n此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。\n\n## RPC\n\n什么叫PRC：  \nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n\nRPC原理：  \n![rpc通讯](https://rong0624.github.io/images/Dubbo/rpc通讯.png)  \n![rpc序列化](https://rong0624.github.io/images/Dubbo/rpc序列化.png)  \nRPC两个核心模块：通讯，序列化。\n\n# Dubbo入门\n\n## 简介\n\nDubbo 是一款高性能、轻量级的开源Java RPC框架。  \nDubbo 是分布式服务治理框架。\n\n提供了三大核心能力：  \n面向接口的远程方法调用  \n集群容错（容错与负债均衡）  \n服务自动注册与发现\n\n官网：http://dubbo.apache.org/\n\n## Dubbo能做什么\n\n问题:  \n服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)  \n各个服务之间依赖管理非常复杂  \n各个服务之间如何进行监控\n\n（1）面向接口的远程方法调用：  \n就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。\n\n（2）智能容错与负债均衡：  \n可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。\n\n（3）服务自动注册与发现：  \n不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。\n\n（4）服务监控：  \n监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。\n\n## Dubbo架构\n\n![dubbo架构图](https://rong0624.github.io/images/Dubbo/dubbo架构图.png)  \n\n### 节点角色说明\n\n服务提供者（Provider）：  \n暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n\n服务消费者（Consumer）:   \n调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n注册中心（Registry）：  \n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n\n监控中心（Monitor）：  \n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n\n### 调用关系说明\n\n（1）服务容器负责启动，加载，运行服务提供者。  \n（2）服务提供者在启动时，向注册中心注册自己提供的服务。  \n（3）服务消费者在启动时，向注册中心订阅自己所需的服务。  \n（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。  \n（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。  \n（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n# Dubbo Hello world\n\n## 环境准备\n\nDubbo学习前必须掌握以下内容：  \nZookeeper的使用经验  \nSpring框架的使用经验  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11\n\n注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。\n\n## 提出需求\n\n某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；\n\n我们现在需要创建两个服务模块进行测试：  \n订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。  \norder-web（订单模块，web，服务消费者）  \nuser-service（用户模块，service，服务提供者）\n\n## 工程架构\n\n根据 dubbo《服务化最佳实践》 \n\n### 分包\n\n建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。\n\n如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。\n\n### 粒度\n\n服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。  \n服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。  \n不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。\n\n### 结构\n\nuser模块：  \nuser-api 提供接口  \nuser-impl 接口实现层，服务提供者\n\n\norder模块：  \norder-web：服务消费者\n\n## 服务提供者\n\nuser项目总览：  \n创建user项目，这是一个聚合工程。  \n创建user-api，这是user公共接口层（提供接口）。  \n创建user-imp，这是user接口的实现层（服务提供者）。\n\n### user-api（提供user公共接口）\n\n（1）用户地址DTO：\n```java\npublic class UserAddressDto implements Serializable {\n\n    private Integer id;\n    private String userId;\n    private String userAddress;\n    private String consignee;\n    private String phone;\n    private String isDefault;\n}\n```\n\n（2）用户地址接口定义\n```java\npublic interface UserService {\n    List<UserAddressDto> getUserAddress(String userId);\n}\n```\n\n### user-impl（接口实现，服务提供者）\n\n（1）pom.xml导入依赖：\n```xml\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!--\n        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n        dubbo 2.6以前的版本引入zkclient操作zookeeper\n        dubbo 2.6及以后的版本引入curator操作zookeeper\n        下面两个zk客户端根据dubbo版本2选1即可\n    -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）实现用户地址接口：\n```java\npublic class UserServiceImpl implements UserService {\n\n    public final static Map<String, List<UserAddressDto>> map;\n\n    static {\n        List<UserAddressDto> list1 = Stream.of(new UserAddressDto(1, \"1\", \"江西赣州\", \"欧阳\", \"152*****\", false),\n                new UserAddressDto(2, \"1\", \"广东深圳\", \"欧阳\", \"152*****\", true),\n                new UserAddressDto(1, \"1\", \"浙江上海\", \"欧阳\", \"152*****\", false))\n                .collect(Collectors.toList());\n        List<UserAddressDto> list2 = Stream.of(new UserAddressDto(3, \"2\", \"江西赣州\", \"东华\", \"152*****\", false),\n                new UserAddressDto(4, \"2\", \"广东深圳\", \"东华\", \"152*****\", true),\n                new UserAddressDto(5, \"2\", \"浙江上海\", \"东华\", \"152*****\", false))\n                .collect(Collectors.toList());\n\n        map = new HashMap<>();\n        map.put(\"1\", list1);\n        map.put(\"2\", list2);\n    }\n\n    @Override\n    public List<UserAddressDto> getUserAddress(String userId) {\n        return map.get(userId);\n    }\n\n}\n```\n\n（3）服务提供者配置：\n新增provider.xml文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://code.alibabatech.com/schema/dubbo\n       http://code.alibabatech.com/schema/dubbo/dubbo.xsd \">\n\n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"user-provider\" />\n\n    <!-- 指定注册中心地址，使用zookeeper暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 用dubbo协议，将服务暴露在20880端口 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n\n    <!-- 声明需要暴露的服务接口 -->\n    <dubbo:service interface=\"com.oyr.user.service.UserService\"\n                   ref=\"userServiceImpl\" />\n\n    <!-- 将接口实现类提交到容器中 -->\n    <bean id=\"userServiceImpl\" class=\"com.oyr.user.service.impl.UserServiceImpl\" />\n</beans>\n```\n\n（4）启动服务提供者\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:provider.xml\");\n        System.in.read();\n    }\n\n}\n```\n注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。\n\n## 服务消费者\n\n（1）pom.xml导入依赖\n```xml\n<!-- 依赖user-api -->\n<dependency>\n    <groupId>com.oyr</groupId>\n    <artifactId>user-api</artifactId>\n    <version>${parent.version}</version>\n</dependency>\n\n<!-- dubbo -->\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.7.7</version>\n</dependency>\n<!--\n    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n    dubbo 2.6以前的版本引入zkclient操作zookeeper\n    dubbo 2.6及以后的版本引入curator操作zookeeper\n    下面两个zk客户端根据dubbo版本2选1即可\n-->\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>2.12.0</version>\n</dependency>\n```\n\n（2）服务消费者配置\n新增consumer.xml文件\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 -->\n    <dubbo:application name=\"order-consumer\" />\n\n    <!-- 指定注册中心，通过注册中心发现服务提供者地址 -->\n    <dubbo:registry protocol=\"zookeeper\" address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 生成远程服务代理，可以和本地bean一样使用userService -->\n    <dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" />\n\n</beans>\n```\n\n（3）启动消费者，尝试调用服务提供者\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:consumer.xml\");\n        UserService userService = context.getBean(UserService.class);\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。  \n说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。\n\n## 注解版\n\n@DubboComponentScan  \n使用dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n## Dubbo支持哪些协议\n\n### Dubbo协议\n\nDubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\n\n### Hessian协议\n\nHessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。Hessian是Caucho开源的一个RPC框架：http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。\n\n基于Hessian的远程调用协议:\n连接个数：多连接  \n连接方式：短连接  \n传输协议：HTTP  \n传输方式：同步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。  \n适用场景：页面传输，文件传输，或与原生hessian服务互操作\n\n### HTTP协议\n\n此协议采用 spring 的HttpInvoker的功能实现，\n\n基于HTTP的远程调用协议:  \n连接个数：多个  \n连接方式：长连接  \n连接协议：http  \n传输方式：同步传输  \n序列化：表单序列化  \n适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。  \n适用场景：需同时给应用程序和浏览器JS使用的服务。\n\n### RMI协议\n\n采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式\n\n基于RMI协议的远程调用协议:  \n连接个数：多连接  \n连接方式：短连接  \n传输协议：TCP  \n传输方式：同步传输\n序列化：Java标准二进制序列化  \n适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  \n适用场景：常规远程服务方法调用，与原生RMI服务互操作\n\n# 整合Spring Boot\n\n基于hello world项目改造成spring boot项目。\n\n## 环境准备\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11  \nSpring Boot 2.2.4.RELEASE\n\n## 服务提供者改造\n\nuser-api不改动，改动user-impl，以下改动都是user-impl的。\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）修改接口实现UserServiceImpl （类上加入DubboService）\n```java\n@DubboService // 暴露当前服务\npublic class UserServiceImpl implements UserService {\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n（4）修改启动类，并且启动服务提供者\n```java\n// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）\n@EnableDubbo\n@SpringBootApplication\npublic class Provider {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Provider.class, args);\n    }\n\n}\n```\n\n修改后，启动成功！！！\n\n## 服务消费者改造\n\n改动order-web（服务消费者）\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）新增controller\n```java\n@RestController\npublic class DubboController {\n\n    @DubboReference\n    private UserService userService;\n\n    @GetMapping(\"/dubbo\")\n    public void dubbo() {\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=cms-wms\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.consumer.client=netty\ndubbo.consumer.check=false\n```\n\n（4）修改启动类\n```java\n@EnableDubbo // 开启dubbo，扫描dubbo注解\n@SpringBootApplication\npublic class Consumer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Consumer.class, args);\n    }\n\n}\n```\n\n（5）测试，尝试远程调用是否成功  \n\n访问http://localhost:8080/dubbo  \n后台成功打印出客户地址列表  \n远程调用成功！！！！\n\n## 配置解释\n\n@EnableDubbo（组合型注解）  \n开启dubbo，扫描dubbo注解。  \n里面有dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n服务提供者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n服务消费者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=order-consumer\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\n```\n\n配置解释：  \ndubbo.application.nam：就是服务名，不能和其他服务提供者重复  \ndubbo.registry.protocol：指定注册中心协议  \ndubbo.registry.address：指定注册中心访问地址（地址加端口号）  \ndubbo.protocol.name：固定是dubbo，不要改  \ndubbo.protocol.port：指定服务提供者暴露的端口\n\n\n# Dubbo 配置详解\n\n注意：以下针对xml配置讲解，注解版差不多一致。\n\n## 重试次数\n\n失败自动重试：  \n当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。\n\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置重试 -->\n<dubbo:provider retries=\"2\" />\n\n<!-- 提供者指定接口重试 -->\n<dubbo:service retries=\"2\" />\n\n<!-- 提供者指定接口某个方法设置重试 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" retries=\"2\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 服务消费者全局配置重试 -->\n<dubbo:consumer retries=\"2\" />\n\n<!-- 服务消费者指定接口设置重试 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" retries=\"2\"/>\n```\n\n## 超时时间\n\n由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置超时时间 -->\n<dubbo:provider timeout=\"5000\" />\n\n<!-- 提供者指定接口以及某个方法配置超时时间 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" timeout=\"5000\" >\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 消费者全局配置超时时间 -->\n<dubbo:consumer timeout=\"3000\"/>\n\n<!-- 消费者指定接口和某个方法配置超时时间 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" timeout=\"5000\">\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\"/>\n</dubbo:reference>\n```\n\n## 版本号\n\n当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。\n\n可以按照以下的步骤进行版本迁移：  \n在低压力时间段，先升级一半提供者为新版本  \n再将所有消费者升级为新版本  \n然后将剩下的一半提供者升级为新版本\n\n```xml\n老版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n老版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n如果不需要区分版本，可以按照以下的方式配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"*\" />\n```\n\n## 配置原则\n\nDubbo推荐在Provider上尽量多配置Consumer端属性。  \n1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等  \n2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的\n\n## 属性配置覆盖规则\n\n![属性配置覆盖规则](https://rong0624.github.io/images/Dubbo/属性配置覆盖规则.png)\n\n1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先 \n2）Consumer端配置优于 Provider配置\n3）最后是Dubbo Hard Code的配置值（见配置文档）\n\n## 配置文件覆盖规则\n\n![配置文件覆盖规则](https://rong0624.github.io/images/Dubbo/配置文件覆盖规则.png)\n\n1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。  \n2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。  \n3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。\n\n# Dubbo-Admin监控中心\n\n## 监控中心简介\n\n监控中心：\n图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。\n\n监控中心：\n是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。\n\n## 搭建监控中心\n\n注意：dubbo-admin有多种启动方式  \n通过jar包方式启动，jar包形式。  \n通过war包方式启动，依赖tomcat容器。  \n通过导入eclipse或idea启动\n\n最新的dubbo-admin是前后端分离的（新版本），可以看教程：  \nhttps://blog.csdn.net/muriyue6/article/details/109304584\n\n**注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）**\n\n下载dubbo-admin项目：https://github.com/apache/incubator-dubbo-ops\n![incubator-dubbo-ops](https://rong0624.github.io/images/Dubbo/incubator-dubbo-ops.png)\n\n### war包启动\n\n1）先准备好dubbo-admin项目\n\n2）准备好tomcat，将dubbo-admin放到webapps目录下\n\n3）修改dubbo.properties文件内容\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root123\n# 指定guest账号密码\ndubbo.admin.guest.password=guest123\n```\n\n4）启动tomcat测试，尝试访问监控中心  \n在tomcat下，bin目录，通过startup.bat启动tomcat。  \n访问http://localhost:8080/dubbo-admin  \n![dubbo监控中心登录页面](https://rong0624.github.io/images/Dubbo/dubbo监控中心登录页面.png)  \n注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。  \n![dubbo监控中心页面](https://rong0624.github.io/images/Dubbo/dubbo监控中心页面.png)  \n最后成功进入监控中心界面！！！\n\n### jar包启动\n\n1）先准备好dubbo-admin项目\n\n2）修改application.properties配置\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root\n# 指定guest账号密码\ndubbo.admin.guest.password=guest\n```\n\n3）打包dubbo-admin\nmvn clean package -Dmaven.test.skip=true\n\n4）运行dubbo-admin.jar，尝试访问监控中心  \njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar  \n使用root/root登录  \n![dubbo监控中心页面](https://rong0624.github.io/images/Dubbo/dubbo监控中心页面.png)\n\n# Dubbo 高可用\n\n## 集群\n\nDubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的application.name相同，Dubbo则会认为是同一集群。\n\n## 集群容错\n\n集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。\n\n### 集群容错\n\n```\nFailover Cluster\n失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。\n\n重试次数配置如下：\n<dubbo:service retries=\"2\" />\n或\n<dubbo:reference retries=\"2\" />\n或\n<dubbo:reference>\n    <dubbo:method name=\"findFoo\" retries=\"2\" />\n</dubbo:reference>\n\nFailfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\nFailsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\nFailback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\nForking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\nBroadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n```\n\n### 集群模式配置\n\n按照以下示例在服务提供方和消费方配置集群模式\n```\n<dubbo:service cluster=\"failsafe\" />\n或\n<dubbo:reference cluster=\"failsafe\" />\n```\n\n## 负债均衡策略\n\n集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。\n\n### 负载均衡策略\n\n```\nRandom LoadBalance\n随机均衡算法，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n权重轮循均衡算法，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\nLeastActive LoadBalance\n最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```\n\n### 负债均衡配置\n\n负债均衡配置很简单。\n服务端和客户端都可以配置服务级别或者方法级别的策略。\n\n服务提供者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:provider loadbalance=\"roundrobin\" />\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" loadbalance=\"roundrobin\" >\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:service>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:service>\n```\n\n服务消费者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:consumer timeout=\"3000\" loadbalance=\"roundrobin\"/>\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" loadbalance=\"roundrobin\">\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:reference>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:reference>\n```\n\n## 注册中心宕机与Dubbo直连\n\n### 注册中心宕机问题\n\n在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。\n\n健壮性  \n监控中心宕掉不影响使用，只是丢失部分采样数据  \n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务  \n注册中心对等集群，任意一台宕掉后，将自动切换到另一台  \n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯  \n服务提供者无状态，任意一台宕掉后，不影响使用  \n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n### 直连模式\n\n注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。  \n点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。\n\nxml配置方式：\n```xml\n<dubbo:reference id=\"userService\" \ninterface=\"com.zang.gmall.service.UserService\" url=\"dubbo://localhost:20880\" />\n```\n\n注解方式：\n```java\n@Reference(url = \"127.0.0.1:20880\")   \n UserService userService;\n```\n\n# Hystrix 断路器\n\n## 服务降级\n\n服务降级概念：  \n当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。\n\n## 服务熔断\n\n服务熔断概念：  \n我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。\n\n同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n服务熔断机制和服务降级是一起使用。\n\n# Dubbo原理\n\n## RPC原理\n\n## Dubbo原理\n","slug":"Dubbo/Dubbo","published":1,"updated":"2021-06-25T14:40:05.637Z","_id":"ckqcfpmk9000thowmge1723lh","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>分布式系统原理与泛型中定义：<br>分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统</p>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"发展演变\"><a href=\"#发展演变\" class=\"headerlink\" title=\"发展演变\"></a>发展演变</h2><p><img src=\"https://rong0624.github.io/images/Dubbo/%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png\" alt=\"架构发展演变\"></p>\n<p>单一应用架构：<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p>\n<p>垂直应用架构：<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 <br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p>\n<p>分布式服务架构：<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p>\n<p>流动计算架构：<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 <br>此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。</p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><p>什么叫PRC：<br>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>\n<p>RPC原理：<br><img src=\"https://rong0624.github.io/images/Dubbo/rpc%E9%80%9A%E8%AE%AF.png\" alt=\"rpc通讯\"><br><img src=\"https://rong0624.github.io/images/Dubbo/rpc%E5%BA%8F%E5%88%97%E5%8C%96.png\" alt=\"rpc序列化\"><br>RPC两个核心模块：通讯，序列化。</p>\n<h1 id=\"Dubbo入门\"><a href=\"#Dubbo入门\" class=\"headerlink\" title=\"Dubbo入门\"></a>Dubbo入门</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dubbo 是一款高性能、轻量级的开源Java RPC框架。<br>Dubbo 是分布式服务治理框架。</p>\n<p>提供了三大核心能力：<br>面向接口的远程方法调用<br>集群容错（容错与负债均衡）<br>服务自动注册与发现</p>\n<p>官网：<a href=\"http://dubbo.apache.org/\">http://dubbo.apache.org/</a></p>\n<h2 id=\"Dubbo能做什么\"><a href=\"#Dubbo能做什么\" class=\"headerlink\" title=\"Dubbo能做什么\"></a>Dubbo能做什么</h2><p>问题:<br>服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)<br>各个服务之间依赖管理非常复杂<br>各个服务之间如何进行监控</p>\n<p>（1）面向接口的远程方法调用：<br>就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。</p>\n<p>（2）智能容错与负债均衡：<br>可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。</p>\n<p>（3）服务自动注册与发现：<br>不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p>\n<p>（4）服务监控：<br>监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。</p>\n<h2 id=\"Dubbo架构\"><a href=\"#Dubbo架构\" class=\"headerlink\" title=\"Dubbo架构\"></a>Dubbo架构</h2><p><img src=\"https://rong0624.github.io/images/Dubbo/dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"dubbo架构图\">  </p>\n<h3 id=\"节点角色说明\"><a href=\"#节点角色说明\" class=\"headerlink\" title=\"节点角色说明\"></a>节点角色说明</h3><p>服务提供者（Provider）：<br>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>\n<p>服务消费者（Consumer）:<br>调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n<p>注册中心（Registry）：<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>\n<p>监控中心（Monitor）：<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>\n<h3 id=\"调用关系说明\"><a href=\"#调用关系说明\" class=\"headerlink\" title=\"调用关系说明\"></a>调用关系说明</h3><p>（1）服务容器负责启动，加载，运行服务提供者。<br>（2）服务提供者在启动时，向注册中心注册自己提供的服务。<br>（3）服务消费者在启动时，向注册中心订阅自己所需的服务。<br>（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>\n<h1 id=\"Dubbo-Hello-world\"><a href=\"#Dubbo-Hello-world\" class=\"headerlink\" title=\"Dubbo Hello world\"></a>Dubbo Hello world</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>Dubbo学习前必须掌握以下内容：<br>Zookeeper的使用经验<br>Spring框架的使用经验<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具</p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11</p>\n<p>注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。</p>\n<h2 id=\"提出需求\"><a href=\"#提出需求\" class=\"headerlink\" title=\"提出需求\"></a>提出需求</h2><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>\n<p>我们现在需要创建两个服务模块进行测试：<br>订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。<br>order-web（订单模块，web，服务消费者）<br>user-service（用户模块，service，服务提供者）</p>\n<h2 id=\"工程架构\"><a href=\"#工程架构\" class=\"headerlink\" title=\"工程架构\"></a>工程架构</h2><p>根据 dubbo《服务化最佳实践》 </p>\n<h3 id=\"分包\"><a href=\"#分包\" class=\"headerlink\" title=\"分包\"></a>分包</h3><p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>\n<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>\n<h3 id=\"粒度\"><a href=\"#粒度\" class=\"headerlink\" title=\"粒度\"></a>粒度</h3><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。<br>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。<br>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>user模块：<br>user-api 提供接口<br>user-impl 接口实现层，服务提供者</p>\n<p>order模块：<br>order-web：服务消费者</p>\n<h2 id=\"服务提供者\"><a href=\"#服务提供者\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h2><p>user项目总览：<br>创建user项目，这是一个聚合工程。<br>创建user-api，这是user公共接口层（提供接口）。<br>创建user-imp，这是user接口的实现层（服务提供者）。</p>\n<h3 id=\"user-api（提供user公共接口）\"><a href=\"#user-api（提供user公共接口）\" class=\"headerlink\" title=\"user-api（提供user公共接口）\"></a>user-api（提供user公共接口）</h3><p>（1）用户地址DTO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAddressDto</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userAddress;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String consignee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String isDefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）用户地址接口定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"user-impl（接口实现，服务提供者）\"><a href=\"#user-impl（接口实现，服务提供者）\" class=\"headerlink\" title=\"user-impl（接口实现，服务提供者）\"></a>user-impl（接口实现，服务提供者）</h3><p>（1）pom.xml导入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）实现用户地址接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;UserAddressDto&gt;&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list1 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">2</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list2 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">3</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">4</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">5</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;1&quot;</span>, list1);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;2&quot;</span>, list2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）服务提供者配置：<br>新增provider.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd &quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user-provider&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心地址，使用zookeeper暴露服务地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 用dubbo协议，将服务暴露在20880端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                   <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 将接口实现类提交到容器中 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.user.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:provider.xml&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。</p>\n<h2 id=\"服务消费者\"><a href=\"#服务消费者\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h2><p>（1）pom.xml导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）服务消费者配置<br>新增consumer.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order-consumer&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心，通过注册中心发现服务提供者地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;zookeeper&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 生成远程服务代理，可以和本地bean一样使用userService --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）启动消费者，尝试调用服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:consumer.xml&quot;</span>);</span><br><span class=\"line\">        UserService userService = context.getBean(UserService.class);</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。<br>说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。</p>\n<h2 id=\"注解版\"><a href=\"#注解版\" class=\"headerlink\" title=\"注解版\"></a>注解版</h2><p>@DubboComponentScan<br>使用dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<h2 id=\"Dubbo支持哪些协议\"><a href=\"#Dubbo支持哪些协议\" class=\"headerlink\" title=\"Dubbo支持哪些协议\"></a>Dubbo支持哪些协议</h2><h3 id=\"Dubbo协议\"><a href=\"#Dubbo协议\" class=\"headerlink\" title=\"Dubbo协议\"></a>Dubbo协议</h3><p>Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>\n<h3 id=\"Hessian协议\"><a href=\"#Hessian协议\" class=\"headerlink\" title=\"Hessian协议\"></a>Hessian协议</h3><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。Hessian是Caucho开源的一个RPC框架：<a href=\"http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./\">http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a></p>\n<p>基于Hessian的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>此协议采用 spring 的HttpInvoker的功能实现，</p>\n<p>基于HTTP的远程调用协议:<br>连接个数：多个<br>连接方式：长连接<br>连接协议：http<br>传输方式：同步传输<br>序列化：表单序列化<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器JS使用的服务。</p>\n<h3 id=\"RMI协议\"><a href=\"#RMI协议\" class=\"headerlink\" title=\"RMI协议\"></a>RMI协议</h3><p>采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式</p>\n<p>基于RMI协议的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：TCP<br>传输方式：同步传输<br>序列化：Java标准二进制序列化<br>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>\n<h1 id=\"整合Spring-Boot\"><a href=\"#整合Spring-Boot\" class=\"headerlink\" title=\"整合Spring Boot\"></a>整合Spring Boot</h1><p>基于hello world项目改造成spring boot项目。</p>\n<h2 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11<br>Spring Boot 2.2.4.RELEASE</p>\n<h2 id=\"服务提供者改造\"><a href=\"#服务提供者改造\" class=\"headerlink\" title=\"服务提供者改造\"></a>服务提供者改造</h2><p>user-api不改动，改动user-impl，以下改动都是user-impl的。</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）修改接口实现UserServiceImpl （类上加入DubboService）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DubboService</span> <span class=\"comment\">// 暴露当前服务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类，并且启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDubbo</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Provider.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后，启动成功！！！</p>\n<h2 id=\"服务消费者改造\"><a href=\"#服务消费者改造\" class=\"headerlink\" title=\"服务消费者改造\"></a>服务消费者改造</h2><p>改动order-web（服务消费者）</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）新增controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DubboReference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/dubbo&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dubbo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">cms-wms</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.client</span>=<span class=\"string\">netty</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.check</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableDubbo</span> <span class=\"comment\">// 开启dubbo，扫描dubbo注解</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Consumer.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（5）测试，尝试远程调用是否成功  </p>\n<p>访问<a href=\"http://localhost:8080/dubbo\">http://localhost:8080/dubbo</a><br>后台成功打印出客户地址列表<br>远程调用成功！！！！</p>\n<h2 id=\"配置解释\"><a href=\"#配置解释\" class=\"headerlink\" title=\"配置解释\"></a>配置解释</h2><p>@EnableDubbo（组合型注解）<br>开启dubbo，扫描dubbo注解。<br>里面有dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<p>服务提供者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">order-consumer</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br></pre></td></tr></table></figure>\n\n<p>配置解释：<br>dubbo.application.nam：就是服务名，不能和其他服务提供者重复<br>dubbo.registry.protocol：指定注册中心协议<br>dubbo.registry.address：指定注册中心访问地址（地址加端口号）<br>dubbo.protocol.name：固定是dubbo，不要改<br>dubbo.protocol.port：指定服务提供者暴露的端口</p>\n<h1 id=\"Dubbo-配置详解\"><a href=\"#Dubbo-配置详解\" class=\"headerlink\" title=\"Dubbo 配置详解\"></a>Dubbo 配置详解</h1><p>注意：以下针对xml配置讲解，注解版差不多一致。</p>\n<h2 id=\"重试次数\"><a href=\"#重试次数\" class=\"headerlink\" title=\"重试次数\"></a>重试次数</h2><p>失败自动重试：<br>当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。</p>\n<h3 id=\"服务提供者-1\"><a href=\"#服务提供者-1\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口某个方法设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-1\"><a href=\"#服务消费者-1\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者指定接口设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h2><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>\n<h3 id=\"服务提供者-2\"><a href=\"#服务提供者-2\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口以及某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-2\"><a href=\"#服务消费者-2\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者指定接口和某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>\n<p>可以按照以下的步骤进行版本迁移：<br>在低压力时间段，先升级一半提供者为新版本<br>再将所有消费者升级为新版本<br>然后将剩下的一半提供者升级为新版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">老版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">老版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">如果不需要区分版本，可以按照以下的方式配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置原则\"><a href=\"#配置原则\" class=\"headerlink\" title=\"配置原则\"></a>配置原则</h2><p>Dubbo推荐在Provider上尽量多配置Consumer端属性。<br>1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等<br>2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>\n<h2 id=\"属性配置覆盖规则\"><a href=\"#属性配置覆盖规则\" class=\"headerlink\" title=\"属性配置覆盖规则\"></a>属性配置覆盖规则</h2><p><img src=\"https://rong0624.github.io/images/Dubbo/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"属性配置覆盖规则\"></p>\n<p>1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先<br>2）Consumer端配置优于 Provider配置<br>3）最后是Dubbo Hard Code的配置值（见配置文档）</p>\n<h2 id=\"配置文件覆盖规则\"><a href=\"#配置文件覆盖规则\" class=\"headerlink\" title=\"配置文件覆盖规则\"></a>配置文件覆盖规则</h2><p><img src=\"https://rong0624.github.io/images/Dubbo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"配置文件覆盖规则\"></p>\n<p>1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>\n<h1 id=\"Dubbo-Admin监控中心\"><a href=\"#Dubbo-Admin监控中心\" class=\"headerlink\" title=\"Dubbo-Admin监控中心\"></a>Dubbo-Admin监控中心</h1><h2 id=\"监控中心简介\"><a href=\"#监控中心简介\" class=\"headerlink\" title=\"监控中心简介\"></a>监控中心简介</h2><p>监控中心：<br>图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。</p>\n<p>监控中心：<br>是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。</p>\n<h2 id=\"搭建监控中心\"><a href=\"#搭建监控中心\" class=\"headerlink\" title=\"搭建监控中心\"></a>搭建监控中心</h2><p>注意：dubbo-admin有多种启动方式<br>通过jar包方式启动，jar包形式。<br>通过war包方式启动，依赖tomcat容器。<br>通过导入eclipse或idea启动</p>\n<p>最新的dubbo-admin是前后端分离的（新版本），可以看教程：<br><a href=\"https://blog.csdn.net/muriyue6/article/details/109304584\">https://blog.csdn.net/muriyue6/article/details/109304584</a></p>\n<p><strong>注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）</strong></p>\n<p>下载dubbo-admin项目：<a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a><br><img src=\"https://rong0624.github.io/images/Dubbo/incubator-dubbo-ops.png\" alt=\"incubator-dubbo-ops\"></p>\n<h3 id=\"war包启动\"><a href=\"#war包启动\" class=\"headerlink\" title=\"war包启动\"></a>war包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）准备好tomcat，将dubbo-admin放到webapps目录下</p>\n<p>3）修改dubbo.properties文件内容</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root123</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest123</span></span><br></pre></td></tr></table></figure>\n\n<p>4）启动tomcat测试，尝试访问监控中心<br>在tomcat下，bin目录，通过startup.bat启动tomcat。<br>访问<a href=\"http://localhost:8080/dubbo-admin\">http://localhost:8080/dubbo-admin</a><br><img src=\"https://rong0624.github.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心登录页面\"><br>注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。<br><img src=\"https://rong0624.github.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"><br>最后成功进入监控中心界面！！！</p>\n<h3 id=\"jar包启动\"><a href=\"#jar包启动\" class=\"headerlink\" title=\"jar包启动\"></a>jar包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）修改application.properties配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest</span></span><br></pre></td></tr></table></figure>\n\n<p>3）打包dubbo-admin<br>mvn clean package -Dmaven.test.skip=true</p>\n<p>4）运行dubbo-admin.jar，尝试访问监控中心<br>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar<br>使用root/root登录<br><img src=\"https://rong0624.github.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"></p>\n<h1 id=\"Dubbo-高可用\"><a href=\"#Dubbo-高可用\" class=\"headerlink\" title=\"Dubbo 高可用\"></a>Dubbo 高可用</h1><h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>Dubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的application.name相同，Dubbo则会认为是同一集群。</p>\n<h2 id=\"集群容错\"><a href=\"#集群容错\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h2><p>集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>\n<h3 id=\"集群容错-1\"><a href=\"#集群容错-1\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failover Cluster</span><br><span class=\"line\">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</span><br><span class=\"line\"></span><br><span class=\"line\">重试次数配置如下：</span><br><span class=\"line\">&lt;dubbo:service retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Failfast Cluster</span><br><span class=\"line\">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</span><br><span class=\"line\"></span><br><span class=\"line\">Failsafe Cluster</span><br><span class=\"line\">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Failback Cluster</span><br><span class=\"line\">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Forking Cluster</span><br><span class=\"line\">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</span><br><span class=\"line\"></span><br><span class=\"line\">Broadcast Cluster</span><br><span class=\"line\">广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群模式配置\"><a href=\"#集群模式配置\" class=\"headerlink\" title=\"集群模式配置\"></a>集群模式配置</h3><p>按照以下示例在服务提供方和消费方配置集群模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"负债均衡策略\"><a href=\"#负债均衡策略\" class=\"headerlink\" title=\"负债均衡策略\"></a>负债均衡策略</h2><p>集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>\n<h3 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random LoadBalance</span><br><span class=\"line\">随机均衡算法，按权重设置随机概率。</span><br><span class=\"line\">在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</span><br><span class=\"line\"></span><br><span class=\"line\">RoundRobin LoadBalance</span><br><span class=\"line\">权重轮循均衡算法，按公约后的权重设置轮循比率。</span><br><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br><span class=\"line\"></span><br><span class=\"line\">LeastActive LoadBalance</span><br><span class=\"line\">最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。</span><br><span class=\"line\">使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsistentHash LoadBalance</span><br><span class=\"line\">一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</span><br><span class=\"line\">缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br><span class=\"line\">缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"负债均衡配置\"><a href=\"#负债均衡配置\" class=\"headerlink\" title=\"负债均衡配置\"></a>负债均衡配置</h3><p>负债均衡配置很简单。<br>服务端和客户端都可以配置服务级别或者方法级别的策略。</p>\n<p>服务提供者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注册中心宕机与Dubbo直连\"><a href=\"#注册中心宕机与Dubbo直连\" class=\"headerlink\" title=\"注册中心宕机与Dubbo直连\"></a>注册中心宕机与Dubbo直连</h2><h3 id=\"注册中心宕机问题\"><a href=\"#注册中心宕机问题\" class=\"headerlink\" title=\"注册中心宕机问题\"></a>注册中心宕机问题</h3><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。</p>\n<p>健壮性<br>监控中心宕掉不影响使用，只是丢失部分采样数据<br>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务<br>注册中心对等集群，任意一台宕掉后，将自动切换到另一台<br>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯<br>服务提供者无状态，任意一台宕掉后，不影响使用<br>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>\n<h3 id=\"直连模式\"><a href=\"#直连模式\" class=\"headerlink\" title=\"直连模式\"></a>直连模式</h3><p>注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。<br>点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>\n<p>xml配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.zang.gmall.service.UserService&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注解方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reference(url = &quot;127.0.0.1:20880&quot;)</span>   </span><br><span class=\"line\"> UserService userService;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Hystrix-断路器\"><a href=\"#Hystrix-断路器\" class=\"headerlink\" title=\"Hystrix 断路器\"></a>Hystrix 断路器</h1><h2 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h2><p>服务降级概念：<br>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。</p>\n<h2 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h2><p>服务熔断概念：<br>我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。</p>\n<p>同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>\n<p>服务熔断机制和服务降级是一起使用。</p>\n<h1 id=\"Dubbo原理\"><a href=\"#Dubbo原理\" class=\"headerlink\" title=\"Dubbo原理\"></a>Dubbo原理</h1><h2 id=\"RPC原理\"><a href=\"#RPC原理\" class=\"headerlink\" title=\"RPC原理\"></a>RPC原理</h2><h2 id=\"Dubbo原理-1\"><a href=\"#Dubbo原理-1\" class=\"headerlink\" title=\"Dubbo原理\"></a>Dubbo原理</h2>","site":{"data":{}},"excerpt":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>分布式系统原理与泛型中定义：<br>分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统</p>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。</p>","more":"<h2 id=\"发展演变\"><a href=\"#发展演变\" class=\"headerlink\" title=\"发展演变\"></a>发展演变</h2><p><img src=\"https://rong0624.github.io/images/Dubbo/%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png\" alt=\"架构发展演变\"></p>\n<p>单一应用架构：<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p>\n<p>垂直应用架构：<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 <br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p>\n<p>分布式服务架构：<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p>\n<p>流动计算架构：<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 <br>此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。</p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><p>什么叫PRC：<br>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>\n<p>RPC原理：<br><img src=\"https://rong0624.github.io/images/Dubbo/rpc%E9%80%9A%E8%AE%AF.png\" alt=\"rpc通讯\"><br><img src=\"https://rong0624.github.io/images/Dubbo/rpc%E5%BA%8F%E5%88%97%E5%8C%96.png\" alt=\"rpc序列化\"><br>RPC两个核心模块：通讯，序列化。</p>\n<h1 id=\"Dubbo入门\"><a href=\"#Dubbo入门\" class=\"headerlink\" title=\"Dubbo入门\"></a>Dubbo入门</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dubbo 是一款高性能、轻量级的开源Java RPC框架。<br>Dubbo 是分布式服务治理框架。</p>\n<p>提供了三大核心能力：<br>面向接口的远程方法调用<br>集群容错（容错与负债均衡）<br>服务自动注册与发现</p>\n<p>官网：<a href=\"http://dubbo.apache.org/\">http://dubbo.apache.org/</a></p>\n<h2 id=\"Dubbo能做什么\"><a href=\"#Dubbo能做什么\" class=\"headerlink\" title=\"Dubbo能做什么\"></a>Dubbo能做什么</h2><p>问题:<br>服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)<br>各个服务之间依赖管理非常复杂<br>各个服务之间如何进行监控</p>\n<p>（1）面向接口的远程方法调用：<br>就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。</p>\n<p>（2）智能容错与负债均衡：<br>可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。</p>\n<p>（3）服务自动注册与发现：<br>不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p>\n<p>（4）服务监控：<br>监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。</p>\n<h2 id=\"Dubbo架构\"><a href=\"#Dubbo架构\" class=\"headerlink\" title=\"Dubbo架构\"></a>Dubbo架构</h2><p><img src=\"https://rong0624.github.io/images/Dubbo/dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"dubbo架构图\">  </p>\n<h3 id=\"节点角色说明\"><a href=\"#节点角色说明\" class=\"headerlink\" title=\"节点角色说明\"></a>节点角色说明</h3><p>服务提供者（Provider）：<br>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>\n<p>服务消费者（Consumer）:<br>调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n<p>注册中心（Registry）：<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>\n<p>监控中心（Monitor）：<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>\n<h3 id=\"调用关系说明\"><a href=\"#调用关系说明\" class=\"headerlink\" title=\"调用关系说明\"></a>调用关系说明</h3><p>（1）服务容器负责启动，加载，运行服务提供者。<br>（2）服务提供者在启动时，向注册中心注册自己提供的服务。<br>（3）服务消费者在启动时，向注册中心订阅自己所需的服务。<br>（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>\n<h1 id=\"Dubbo-Hello-world\"><a href=\"#Dubbo-Hello-world\" class=\"headerlink\" title=\"Dubbo Hello world\"></a>Dubbo Hello world</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>Dubbo学习前必须掌握以下内容：<br>Zookeeper的使用经验<br>Spring框架的使用经验<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具</p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11</p>\n<p>注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。</p>\n<h2 id=\"提出需求\"><a href=\"#提出需求\" class=\"headerlink\" title=\"提出需求\"></a>提出需求</h2><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>\n<p>我们现在需要创建两个服务模块进行测试：<br>订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。<br>order-web（订单模块，web，服务消费者）<br>user-service（用户模块，service，服务提供者）</p>\n<h2 id=\"工程架构\"><a href=\"#工程架构\" class=\"headerlink\" title=\"工程架构\"></a>工程架构</h2><p>根据 dubbo《服务化最佳实践》 </p>\n<h3 id=\"分包\"><a href=\"#分包\" class=\"headerlink\" title=\"分包\"></a>分包</h3><p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>\n<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>\n<h3 id=\"粒度\"><a href=\"#粒度\" class=\"headerlink\" title=\"粒度\"></a>粒度</h3><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。<br>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。<br>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>user模块：<br>user-api 提供接口<br>user-impl 接口实现层，服务提供者</p>\n<p>order模块：<br>order-web：服务消费者</p>\n<h2 id=\"服务提供者\"><a href=\"#服务提供者\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h2><p>user项目总览：<br>创建user项目，这是一个聚合工程。<br>创建user-api，这是user公共接口层（提供接口）。<br>创建user-imp，这是user接口的实现层（服务提供者）。</p>\n<h3 id=\"user-api（提供user公共接口）\"><a href=\"#user-api（提供user公共接口）\" class=\"headerlink\" title=\"user-api（提供user公共接口）\"></a>user-api（提供user公共接口）</h3><p>（1）用户地址DTO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAddressDto</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userAddress;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String consignee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String isDefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）用户地址接口定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"user-impl（接口实现，服务提供者）\"><a href=\"#user-impl（接口实现，服务提供者）\" class=\"headerlink\" title=\"user-impl（接口实现，服务提供者）\"></a>user-impl（接口实现，服务提供者）</h3><p>（1）pom.xml导入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）实现用户地址接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;UserAddressDto&gt;&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list1 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">2</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list2 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">3</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">4</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">5</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;1&quot;</span>, list1);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;2&quot;</span>, list2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）服务提供者配置：<br>新增provider.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd &quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user-provider&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心地址，使用zookeeper暴露服务地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 用dubbo协议，将服务暴露在20880端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                   <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 将接口实现类提交到容器中 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.user.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:provider.xml&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。</p>\n<h2 id=\"服务消费者\"><a href=\"#服务消费者\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h2><p>（1）pom.xml导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）服务消费者配置<br>新增consumer.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order-consumer&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心，通过注册中心发现服务提供者地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;zookeeper&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 生成远程服务代理，可以和本地bean一样使用userService --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）启动消费者，尝试调用服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:consumer.xml&quot;</span>);</span><br><span class=\"line\">        UserService userService = context.getBean(UserService.class);</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。<br>说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。</p>\n<h2 id=\"注解版\"><a href=\"#注解版\" class=\"headerlink\" title=\"注解版\"></a>注解版</h2><p>@DubboComponentScan<br>使用dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<h2 id=\"Dubbo支持哪些协议\"><a href=\"#Dubbo支持哪些协议\" class=\"headerlink\" title=\"Dubbo支持哪些协议\"></a>Dubbo支持哪些协议</h2><h3 id=\"Dubbo协议\"><a href=\"#Dubbo协议\" class=\"headerlink\" title=\"Dubbo协议\"></a>Dubbo协议</h3><p>Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>\n<h3 id=\"Hessian协议\"><a href=\"#Hessian协议\" class=\"headerlink\" title=\"Hessian协议\"></a>Hessian协议</h3><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。Hessian是Caucho开源的一个RPC框架：<a href=\"http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./\">http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a></p>\n<p>基于Hessian的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>此协议采用 spring 的HttpInvoker的功能实现，</p>\n<p>基于HTTP的远程调用协议:<br>连接个数：多个<br>连接方式：长连接<br>连接协议：http<br>传输方式：同步传输<br>序列化：表单序列化<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器JS使用的服务。</p>\n<h3 id=\"RMI协议\"><a href=\"#RMI协议\" class=\"headerlink\" title=\"RMI协议\"></a>RMI协议</h3><p>采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式</p>\n<p>基于RMI协议的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：TCP<br>传输方式：同步传输<br>序列化：Java标准二进制序列化<br>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>\n<h1 id=\"整合Spring-Boot\"><a href=\"#整合Spring-Boot\" class=\"headerlink\" title=\"整合Spring Boot\"></a>整合Spring Boot</h1><p>基于hello world项目改造成spring boot项目。</p>\n<h2 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11<br>Spring Boot 2.2.4.RELEASE</p>\n<h2 id=\"服务提供者改造\"><a href=\"#服务提供者改造\" class=\"headerlink\" title=\"服务提供者改造\"></a>服务提供者改造</h2><p>user-api不改动，改动user-impl，以下改动都是user-impl的。</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）修改接口实现UserServiceImpl （类上加入DubboService）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DubboService</span> <span class=\"comment\">// 暴露当前服务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类，并且启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDubbo</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Provider.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后，启动成功！！！</p>\n<h2 id=\"服务消费者改造\"><a href=\"#服务消费者改造\" class=\"headerlink\" title=\"服务消费者改造\"></a>服务消费者改造</h2><p>改动order-web（服务消费者）</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）新增controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DubboReference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/dubbo&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dubbo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">cms-wms</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.client</span>=<span class=\"string\">netty</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.check</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableDubbo</span> <span class=\"comment\">// 开启dubbo，扫描dubbo注解</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Consumer.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（5）测试，尝试远程调用是否成功  </p>\n<p>访问<a href=\"http://localhost:8080/dubbo\">http://localhost:8080/dubbo</a><br>后台成功打印出客户地址列表<br>远程调用成功！！！！</p>\n<h2 id=\"配置解释\"><a href=\"#配置解释\" class=\"headerlink\" title=\"配置解释\"></a>配置解释</h2><p>@EnableDubbo（组合型注解）<br>开启dubbo，扫描dubbo注解。<br>里面有dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<p>服务提供者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">order-consumer</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br></pre></td></tr></table></figure>\n\n<p>配置解释：<br>dubbo.application.nam：就是服务名，不能和其他服务提供者重复<br>dubbo.registry.protocol：指定注册中心协议<br>dubbo.registry.address：指定注册中心访问地址（地址加端口号）<br>dubbo.protocol.name：固定是dubbo，不要改<br>dubbo.protocol.port：指定服务提供者暴露的端口</p>\n<h1 id=\"Dubbo-配置详解\"><a href=\"#Dubbo-配置详解\" class=\"headerlink\" title=\"Dubbo 配置详解\"></a>Dubbo 配置详解</h1><p>注意：以下针对xml配置讲解，注解版差不多一致。</p>\n<h2 id=\"重试次数\"><a href=\"#重试次数\" class=\"headerlink\" title=\"重试次数\"></a>重试次数</h2><p>失败自动重试：<br>当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。</p>\n<h3 id=\"服务提供者-1\"><a href=\"#服务提供者-1\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口某个方法设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-1\"><a href=\"#服务消费者-1\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者指定接口设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h2><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>\n<h3 id=\"服务提供者-2\"><a href=\"#服务提供者-2\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口以及某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-2\"><a href=\"#服务消费者-2\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者指定接口和某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>\n<p>可以按照以下的步骤进行版本迁移：<br>在低压力时间段，先升级一半提供者为新版本<br>再将所有消费者升级为新版本<br>然后将剩下的一半提供者升级为新版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">老版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">老版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">如果不需要区分版本，可以按照以下的方式配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置原则\"><a href=\"#配置原则\" class=\"headerlink\" title=\"配置原则\"></a>配置原则</h2><p>Dubbo推荐在Provider上尽量多配置Consumer端属性。<br>1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等<br>2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>\n<h2 id=\"属性配置覆盖规则\"><a href=\"#属性配置覆盖规则\" class=\"headerlink\" title=\"属性配置覆盖规则\"></a>属性配置覆盖规则</h2><p><img src=\"https://rong0624.github.io/images/Dubbo/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"属性配置覆盖规则\"></p>\n<p>1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先<br>2）Consumer端配置优于 Provider配置<br>3）最后是Dubbo Hard Code的配置值（见配置文档）</p>\n<h2 id=\"配置文件覆盖规则\"><a href=\"#配置文件覆盖规则\" class=\"headerlink\" title=\"配置文件覆盖规则\"></a>配置文件覆盖规则</h2><p><img src=\"https://rong0624.github.io/images/Dubbo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"配置文件覆盖规则\"></p>\n<p>1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>\n<h1 id=\"Dubbo-Admin监控中心\"><a href=\"#Dubbo-Admin监控中心\" class=\"headerlink\" title=\"Dubbo-Admin监控中心\"></a>Dubbo-Admin监控中心</h1><h2 id=\"监控中心简介\"><a href=\"#监控中心简介\" class=\"headerlink\" title=\"监控中心简介\"></a>监控中心简介</h2><p>监控中心：<br>图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。</p>\n<p>监控中心：<br>是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。</p>\n<h2 id=\"搭建监控中心\"><a href=\"#搭建监控中心\" class=\"headerlink\" title=\"搭建监控中心\"></a>搭建监控中心</h2><p>注意：dubbo-admin有多种启动方式<br>通过jar包方式启动，jar包形式。<br>通过war包方式启动，依赖tomcat容器。<br>通过导入eclipse或idea启动</p>\n<p>最新的dubbo-admin是前后端分离的（新版本），可以看教程：<br><a href=\"https://blog.csdn.net/muriyue6/article/details/109304584\">https://blog.csdn.net/muriyue6/article/details/109304584</a></p>\n<p><strong>注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）</strong></p>\n<p>下载dubbo-admin项目：<a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a><br><img src=\"https://rong0624.github.io/images/Dubbo/incubator-dubbo-ops.png\" alt=\"incubator-dubbo-ops\"></p>\n<h3 id=\"war包启动\"><a href=\"#war包启动\" class=\"headerlink\" title=\"war包启动\"></a>war包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）准备好tomcat，将dubbo-admin放到webapps目录下</p>\n<p>3）修改dubbo.properties文件内容</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root123</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest123</span></span><br></pre></td></tr></table></figure>\n\n<p>4）启动tomcat测试，尝试访问监控中心<br>在tomcat下，bin目录，通过startup.bat启动tomcat。<br>访问<a href=\"http://localhost:8080/dubbo-admin\">http://localhost:8080/dubbo-admin</a><br><img src=\"https://rong0624.github.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心登录页面\"><br>注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。<br><img src=\"https://rong0624.github.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"><br>最后成功进入监控中心界面！！！</p>\n<h3 id=\"jar包启动\"><a href=\"#jar包启动\" class=\"headerlink\" title=\"jar包启动\"></a>jar包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）修改application.properties配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest</span></span><br></pre></td></tr></table></figure>\n\n<p>3）打包dubbo-admin<br>mvn clean package -Dmaven.test.skip=true</p>\n<p>4）运行dubbo-admin.jar，尝试访问监控中心<br>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar<br>使用root/root登录<br><img src=\"https://rong0624.github.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"></p>\n<h1 id=\"Dubbo-高可用\"><a href=\"#Dubbo-高可用\" class=\"headerlink\" title=\"Dubbo 高可用\"></a>Dubbo 高可用</h1><h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>Dubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的application.name相同，Dubbo则会认为是同一集群。</p>\n<h2 id=\"集群容错\"><a href=\"#集群容错\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h2><p>集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>\n<h3 id=\"集群容错-1\"><a href=\"#集群容错-1\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failover Cluster</span><br><span class=\"line\">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</span><br><span class=\"line\"></span><br><span class=\"line\">重试次数配置如下：</span><br><span class=\"line\">&lt;dubbo:service retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Failfast Cluster</span><br><span class=\"line\">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</span><br><span class=\"line\"></span><br><span class=\"line\">Failsafe Cluster</span><br><span class=\"line\">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Failback Cluster</span><br><span class=\"line\">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Forking Cluster</span><br><span class=\"line\">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</span><br><span class=\"line\"></span><br><span class=\"line\">Broadcast Cluster</span><br><span class=\"line\">广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群模式配置\"><a href=\"#集群模式配置\" class=\"headerlink\" title=\"集群模式配置\"></a>集群模式配置</h3><p>按照以下示例在服务提供方和消费方配置集群模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"负债均衡策略\"><a href=\"#负债均衡策略\" class=\"headerlink\" title=\"负债均衡策略\"></a>负债均衡策略</h2><p>集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>\n<h3 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random LoadBalance</span><br><span class=\"line\">随机均衡算法，按权重设置随机概率。</span><br><span class=\"line\">在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</span><br><span class=\"line\"></span><br><span class=\"line\">RoundRobin LoadBalance</span><br><span class=\"line\">权重轮循均衡算法，按公约后的权重设置轮循比率。</span><br><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br><span class=\"line\"></span><br><span class=\"line\">LeastActive LoadBalance</span><br><span class=\"line\">最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。</span><br><span class=\"line\">使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsistentHash LoadBalance</span><br><span class=\"line\">一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</span><br><span class=\"line\">缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br><span class=\"line\">缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"负债均衡配置\"><a href=\"#负债均衡配置\" class=\"headerlink\" title=\"负债均衡配置\"></a>负债均衡配置</h3><p>负债均衡配置很简单。<br>服务端和客户端都可以配置服务级别或者方法级别的策略。</p>\n<p>服务提供者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注册中心宕机与Dubbo直连\"><a href=\"#注册中心宕机与Dubbo直连\" class=\"headerlink\" title=\"注册中心宕机与Dubbo直连\"></a>注册中心宕机与Dubbo直连</h2><h3 id=\"注册中心宕机问题\"><a href=\"#注册中心宕机问题\" class=\"headerlink\" title=\"注册中心宕机问题\"></a>注册中心宕机问题</h3><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。</p>\n<p>健壮性<br>监控中心宕掉不影响使用，只是丢失部分采样数据<br>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务<br>注册中心对等集群，任意一台宕掉后，将自动切换到另一台<br>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯<br>服务提供者无状态，任意一台宕掉后，不影响使用<br>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>\n<h3 id=\"直连模式\"><a href=\"#直连模式\" class=\"headerlink\" title=\"直连模式\"></a>直连模式</h3><p>注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。<br>点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>\n<p>xml配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.zang.gmall.service.UserService&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注解方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reference(url = &quot;127.0.0.1:20880&quot;)</span>   </span><br><span class=\"line\"> UserService userService;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Hystrix-断路器\"><a href=\"#Hystrix-断路器\" class=\"headerlink\" title=\"Hystrix 断路器\"></a>Hystrix 断路器</h1><h2 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h2><p>服务降级概念：<br>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。</p>\n<h2 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h2><p>服务熔断概念：<br>我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。</p>\n<p>同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>\n<p>服务熔断机制和服务降级是一起使用。</p>\n<h1 id=\"Dubbo原理\"><a href=\"#Dubbo原理\" class=\"headerlink\" title=\"Dubbo原理\"></a>Dubbo原理</h1><h2 id=\"RPC原理\"><a href=\"#RPC原理\" class=\"headerlink\" title=\"RPC原理\"></a>RPC原理</h2><h2 id=\"Dubbo原理-1\"><a href=\"#Dubbo原理-1\" class=\"headerlink\" title=\"Dubbo原理\"></a>Dubbo原理</h2>"},{"title":"MySQL基础","date":"2021-06-22T15:30:00.000Z","author":"神奇的荣荣","summary":"","_content":"\nMysql数据库\n\n# MySql基础\n\n## 数据库的好处\n\n可以持久化到本地  \n结构化查询\n\n***\n\n## 主流的数据库介绍（了解）\n\nSql server 数据库  \n是微软，.net程序员最爱，中型和大型项目，性能高\n\nOracle数据库  \n是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。\n\nMysql数据库  \n是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。\n\ndb2数据库  \n是ibm公司，处理海量数据，大型项目。很强悍。\n\nInformix数据库  \n是ibm公司。在银行系统，安全性高\n\nSybase数据库\n\n***\n\n## mysql的优点\n\n开源，免费成本低  \n性能高，移植性也好  \n体积小，便于安装\n\n## mysql数据库的安装和配置\n\n看MySQL-5.7.17安装与配置.docx\n\n## mysql的基本使用\n\n（1）连接到mysql\nCmd>mysql -h 主机名 -u 用户名 -p 密码 回车\n举例：\n\n说明：\n如果你没有写-h localhost 默认是连接本地\n\n如果你需要远程登录到另一个mysql,则需要修改配置。\n一般情况下部让远程登录。\n\n（2）sql服务的退出\nexit或ctrl+c\n\n（3）关闭和启动mysql服务\n界面操作：\n\n命令模式：\n启动：net stop mysql\n停止：net start mysql\n举例：\n\n说明：这里mysql不是固定的，是安装时取的服务名称。\n\n## mysql数据库三层架构介绍\n\n专业术语\n\nDb：  \n数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。\n\nDbms：  \n数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。\n\nSql:  \n结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。\n\n数据库服务器，数据库和表的关系如图所示：\n\n\n示意图：\n\n## mysql常见命令\n\n```\n1.查看当前所有的数据库\nshow databases;\n\n2.打开指定的库\nuse 库名;\n\n3.查看所在的数据库名\nselect database();\n\n4.查看当前库的所有表\nshow tables;\n\n5.查看其它库的所有表\nshow tables from 库名;\n\n6.创建表\ncreate table user(id int, name varchar(20));\n\n7.查看表结构\ndesc 表名;\t\t\n\n8.查看服务器的版本\n方式一：登录到mysql服务端\nSelect version();\n方式二：没有登录到mysql服务端\nMysql --version或mysql --V\n\n9.查看当前时区\nSHOW VARIABLES LIKE 'time_zone'\nSET time_zone='+9:00';\n```\n\n## Mysql的语法规范\n\n1.不区分大小写，单建议关键字大写，表名，列名小写。  \n2.每条语句最好用分号结尾。  \n3.每条命令根据需要，可以进行缩进或换行  \n4.注释  \n单行注释：两种  \n第一种：#注释文字  \n第二种：-- 注释文字  \n多行注释：/* 注释文字 */\n\n\n\n# 常用数据类型\n\n## 数值型\n\n2.1.1.整型\n\n\n\n特点：\n（1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字\n（2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值\n（4）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！\n\n\n2.1.2.小数\n\n\n浮点型：\nFloat(m, d)，double(m, d)\n4\t\t\t8\n\n定点型：\nDec(m, d)，decimal(m, d)\nM+2\t\tm+2\n\n特点：\n（1）\nM：整数部位+小数部位（总长度）\nD：小数部位\n如果超出范围插入临界值\n\n（2）\nM和D都可以省略\n如果是decimal，则m默认为10，d默认为0\n如果是double和float，则会随着插入的数值的精度来决定精度\n\n（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用\n\n\n2.2.字符型\n\n较短的文本：\nChar\nVarchar\n\n特点：\n\n写法\t\tm的意思\t\t\t特点\t\t\t空间的耗费\t\t效率\nChar\tchar(m)\t\t最大的字符数\t固定长度\t\t比较耗费\t\t高\nVarchar\tvarchar(m)\t最大的字符数\t可变长度的字符\t比较节省\t\t低\n\n\n较长的文本：\nText\nBlob（较大的二进制）\n\n\nEnum类型：\n说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。\n如果列表成员为1~255，则需要1个字节存储\n如果列表成员为255~65535，则需要2个字节存储\n最多需要65535个成员\n\n\nSet类型：\n说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区\n别是：SET类型一次可以选取多个成员，而Enum只能选一个\n根据成员个数不同，存储所占的字节也不同\n\n\n2.3.日期型\n\n\n总结：\nDate：只保存日期，并没有保存到时分秒\nTime：只保存时间（时分秒）\nYear：只保存年\n\nDatetime：保存日期+时间\nTimestamp：保存日期+时间\n\n\nDatetime VS Timestamp\n\n字节\t范围\t\t时区等的影响\nDatetime \t8\t\t1000-9999\t\t不受\nTimestamp\t4\t\t1970-2038\t\t受\n\n# DQL语言（select）\n\n## 基础查询\n\n### 语法\n\nselect 查询列表 from 表名\n\n### 特点\n查询列表开源是字段，常量表达式，函数，也可以有多个。  \n查询结构是一个虚拟表。\n\n### 示例\n\n1.查询单个字段  \nSelect 字段名 from 表名\n\n2.查询多个字段  \nSelect 字段名,字段名 from 表名\n\n3.查询所有的字段  \nSelect * from 表名\n\n4.查询常量  \nSelect 常量值  \n注意：字符型和日期型常量值必须用单引号用起来，数值类不需要\n\n5.查询函数 \nSelect 函数名（实例参数）;\n\n6.查询表达式  \nSelect 100*10;\n\n7.取别名  \n两种方式  \nAs  \nSelect last_name as 姓名 from 表名  \n\n空格  \nSelect last_name 姓名 from 表名\n\n8.去重  \nSelect distinct 字段名 from 表名\n\n9.+  \n作用：加法运算  \nSelect 数值+数值;直接运算  \nSelect 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，\t再做运算。\n\n10.补充Concat函数  \n功能：拼接字符  \nSelect concat(字符1,字符2,字符3,....)\n\n11.补充ifnull函数  \nSelect ifnull(name, 0) from user\n\n12.补充isnull函数  \nSelect isnull(name) from user  \n功能：拍的某个字段是否为null，如果是返回1，如果不是返回0\n\n\n## 条件查询\n\n### 语法\n\nSelect 查询列表  \nFrom 表名  \nWhere 筛选条件\n\n### 筛选条件的分类\n\n（1）简单条件运算符  \n\n```> < = <> != >= <= <=>```\n\nSelect * from user where age>15;\n\nSelect * from user where age<15;\n\nSelect * from user where age<>15;\n\n<=>:安全等于，可以判断普通数值，也可以判断是否为null  \nSelect * from user where age<=> null;\n\n（2）逻辑运算符\n\n```and or not```\n\nAnd:  \nSELECT last_name FROM employees WHERE salary>=10000 AND salary<=20000;\n\nOr:  \nSELECT * FROM employees WHERE department_id<90 OR department_id>110 OR salary>15000;\n\nNot:  \nSELECT * FROM employees WHERE NOT(department_id>=90 AND department_id<=110) OR salary>15000;\n\n（3）模糊查询\n\n```Like, between and, in, is null, is not null ```\n\nlike：  \nSelect * from user where name like’%a%’;  \nSelect * from user where name like’_a%’;\n\n\nbetween and:  \n作用：在哪两个数之间  \nSelect * from user where age between 10 and 20;\n\nin:  \nSelect * from user where id in(1,2,3);\n\nis null:  \n作用：判断是否为null  \nSelect * from user where age is null;\n\nis not null:  \n作用：判断是否不为空  \nSelect * from user where age is not null;\n\n## 排序查询\n\n### 语法\n\nSelect * from 表名  \n[Where 筛选条件]  \nOrder by 排序列表[asc desc]\n\n### 特点\n（1）asc代表升序，desc代表降序，如果不写是升序。  \n（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名  \n（3）order by子句一般是放查询语句的最后面，limit子句除外\n\n### 案例\n\n#案例：查询员工信息，要求工资冲高到底排序  \n```sql\nSELECT * FROM employees ORDER BY salary DESC;\n```\n\n#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  \n```sql\nSELECT *, salary*12*(1+IFNULL(commission_pct, 0)) AS 年薪 \nFROM employees \nORDER BY 年薪 DESC;\n```\n\n#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 \n``` sql\nSELECT * FROM employees \nWHERE email LIKE '%e%' \nORDER BY LENGTH(email) DESC, department_id ASC;\n```\n\n## 常见函数\n\n功能：类似java中的方法  \n好处：提高重用性和隐藏实现细节  \n调用：select 函数名(参数列表)  \n\n### 字符函数\n\nLENGTH：  \n作用：获取参数的字节个数  \nSELECT LENGTH('oyr');  \nSELECT LENGTH('欧阳荣');\n\n\nCONCAT：  \n作用：拼接字符串  \nSELECT CONCAT('abc', 'jkl');  \nSELECT CONCAT(first_name, last_name) out_put FROM employees;\n\n\nUPPER：  \n作用：字符串变大写  \nSELECT UPPER(\"asc\");\n\n\nLower：  \n作用：字符串变小写\nSELECT LOWER(\"ASC\");\n\n\nSubstr:  \n作用：截取字符串，两种使用方式\n``` sql\n#第一种：截取从指定索引处后面所有字符  \nSELECT SUBSTR(\"欧阳荣真的帅哦\", 4);  \n结果：真的帅哦\n\n#第二种：截取从指定索引处指定字符串的字符  \nSELECT SUBSTR(\"欧阳荣不是一般帅哦\", 1, 3);  \n结果：欧阳荣\n\n# 案例1：姓名首字母大写，其他字符小写然后用_拼接，显示出来\nSELECT CONCAT(UPPER(SUBSTR(last_name, 1, 1)), '_', LOWER(SUBSTR(last_name, 2))) FROM employees;\n```\n\nTrim:\n作用：去除两边空格或去除两边指定字符\n``` sql\n#去除两边空格：\nSELECT LENGTH(TRIM('   欧阳荣 '));\n结果：欧阳荣\n\n#去除两边指定字符：\nSELECT TRIM('a' FROM 'aaaaaaaa欧阳aaa荣aaaaaa');\n结果：欧阳aaa荣\n```\n\nLpad：  \n作用：lpad 用指定的字符实现左填充指定长度  \nSELECT LPAD('欧阳荣', 10, 'a') out_put;\n\nRpad：  \n作用：用指定的字符实现右填充指定长度  \nSELECT LPAD('欧阳荣', 12, 'ab') out_put;\n\nReplace：  \n作用：替换字符串  \nSELECT REPLACE('赵吊彬是zz赵吊彬赵吊彬赵吊彬', '赵吊彬', '李执志');\n\nInstr:  \n作用：获取子串第一次出现的索引\nSELECT INSTR('欧阳荣多对多', '欧阳');\n结果为：1\n\n### 数学函数\n\nRound:  \n作用：四舍五入\n```\n第一种使用：\nSELECT ROUND(1.65);\n结果：2\n\n第二种使用：\nSELECT ROUND(1.657, 2);\n结果：1.66\n```\n\nCeil：  \n作用：向上取整  \nSELECT CEIL(1.52);  \n结果：2\n\n\nFloor：  \n作用：向下取整  \nSELECT FLOOR(9.99);  \n结果：9\n\nTruncate：  \n作用：截断  \nSELECT TRUNCATE(10.19, 1);  \n结果：10.1\n\n\nMod：  \n作用：取余  \nSELECT MOD(10, 3);  \n结果：1\n\nRand：  \n作用：获取随机数，返回0-1之间的小数  \nSELECT RAND();\n\n### 日期函数\n\nNOW：  \n作用：返回当前系统日期+时间  \nSELECT NOW();\n\nCurdate：  \n作用：返回当前系统日期，不包含时间  \nSELECT CURDATE();\n\nCurtime：  \n作用：返回当前时间，不包含日期  \nSELECT CURTIME();\n\nYear：  \n作用：获取年  \nSelect year(now());  \nSELECT YEAR('1999-1-1') 年;\n\nMonth:  \n作用：获取月  \nSELECT MONTH(NOW()) 月;\n\nDay:  \n作用：获取日  \nSelect DAY(now()) 日;\n\n\n日期格式符：\n\n\n\n\n\nStr_to_date:  \n作用：将日期格式的字符转换成指定格式的日期  \nSELECT STR_TO_DATE('1999-6-2', '%Y-%c-%d') out_put;  \nSELECT * FROM employees WHERE hiredate=STR_TO_DATE('4-3 1992', '%c-%d %Y');\n\n\nDate_format：  \n作用：将日期转换成字符  \nSELECT DATE_FORMAT(NOW(), '%y年%m月%d日') AS out_put;\n\n案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）\nSELECT last_name, DATE_FORMAT(hiredate, '%M月/%d日 %y年') \nFROM employees \nWHERE commission_pct IS NOT NULL;\n\nDatediff：  \n作用：返回两个日期相差的天数  \nSELECT DATEDIFF(NOW(), '1999-06-24');\n\n\n### 其他函数\n\nVERSION：  \n作用：查看当前mysql版本号  \nSELECT VERSION();\n\nDATABASE：  \n作用：查看当前打开的数据库  \nSelect DATABASE();\n\nUSER：  \n作用：查看当前登录的用户  \nSelect USER();\n\n### 流程控制函数\n\nIf：  \n作用：判断真假  \nSELECT IF(10<5, '小', '大');\n\nCase:  \n作用：判断  \n语法：  \ncase 要带的字段或表达式  \nwhen 常量1 then 要显示的值1或语句1;  \nwhen 常量1 then 要显示的值1或语句1;  \n.....  \nelse 要显示的值n或语句n  \nEnd\n\n``` sql\n案例：查询员工的工资，要求\n部门号=30,显示的工资为1.1倍\n部门号=40，显示的工资为1.2倍\n部门号=50，显示的工资为1.3倍\n其他部门，显示的工资为原工资\n\nSELECT last_name, salary 原工资, \nCASE department_id\nWHEN 30 THEN salary*1.1\nWHEN 40 THEN salary*1.2\nWHEN 50 THEN salary*1.3\nELSE salary\nEND AS 新工资\nFROM employees;\n\n案例：查询员工的工资的情况\n如果工资>20000，显示A级别\n如果工资>15000，显示B级别\n如果工资>10000,显示C级别\n否则，显示D级别\n\nSELECT last_name,salary,\nCASE\nWHEN salary>20000 THEN 'A'\nWHEN salary>15000 THEN 'B'\nWHEN salary>10000 THEN 'C'\nELSE 'D'\nEND AS 级别\nFROM employees;\n```\n\n## 分组\n\n### 分组函数\n\nsum:\n作用：求和\nSELECT SUM(salary) FROM employees;\n\n\nmax:\n作用：最大值\nSelect max(salary) from employees;\n\n\nmin：\n作用：最小值\nSELECT MIN(salary) FROM employees;\n\n\navg：\n作用：平均数\nSELECT AVG(salary) FROM employees;\n\n\ncount：\n作用：计算个数\nSelect count(*) from user;\n\n\n注意事项：\nsum，avg一般用于数值型\nmax，min，count可以处理任何类型\n以上分组函数都忽略null值\n\n### 分组查询\n\n语法：\nselect 分组函数，列（要求出现在group by的后面）\nfrom 表\n[where 筛选条件]\ngroup by 分组的列表\n[having 分组后的筛选]\n[order by 子句]\n\n注意：\n查询列表必须特殊，要求是分组函数或group by后出现的字段\n分组后筛选在group by子句的后面使用 having 关键字\n分组函数做条件肯定是放在having子句中\n能用分组前筛选，就优先使用分组前筛选\ngroup by 子句支持单个字段分组，多个字段分组（用逗号隔开）\n\n简单分组：\n```sql\n#案例1：查询每个部门的平均工资\nSELECT department_id,AVG(salary) 平均工资 FROM employees GROUP BY department_id; \n\n#案例2：查询每个工种的最高工资\nSELECT job_id, MAX(salary) FROM employees GROUP BY job_id;\n\n#案例3：查询每个位置上的部门个数\nSELECT location_id, COUNT(*) FROM departments GROUP BY location_id;\n```\n\n添加筛选条件：\n```sql\n#案例1：查询邮箱中包含a字符的，每个部门的平均工资\nSELECT department_id, AVG(salary) \nFROM employees \nWHERE email LIKE '%a%' \nGROUP BY department_id;\n\n#案例2：查询有奖金的每个领导手下的最高工资\nSELECT manager_id, MAX(salary)\nFROM employees \nWHERE commission_pct IS NOT NULL \nGROUP BY manager_id;\n\n#案例3：查询哪个部门的员工个数>2\nSelect department_id, count(*) \nfrom employees\ngroup by department_id having count(*)>2;\n\n#案例4：查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT job_id, MAX(salary) \nFROM employees\nGROUP BY job_id HAVING MAX(salary)>12000;\n\n#案例5：查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个\nSELECT manager_id, MIN(salary) \nFROM employees \nWHERE manager_id>102 \nGROUP BY manager_id HAVING MIN(salary)>5000;\n\n#案例6：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些\nSELECT last_name, LENGTH(last_name), COUNT(*) 员工个数 \nFROM employees \nGROUP BY LENGTH(last_name) HAVING COUNT(*)>5;\n```\n\n## 连接查询\n\n什么是连接查询：  \n又称多表查询，当查询的字段来自多个表时，就会用到连接查询。\n\n笛卡尔积:  \n笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行\n\n\n### 分类\n\t\n按年代分类：  \nsql92标准：仅仅支持内连接  \nsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\n按功能分类：\n- 内连接：  \n    - 等值连接  \n    - 非等值连接  \n    - 自连接  \n- 外连接：  \n    - 左外连接  \n    - 右外连接  \n    - 全外连接（mysql不支持）  \n- 交叉连接：  \n\n### 语法\n\nSelect 查询列表\nFrom 表1 别名 【连接类型】\nJoin 表2 别名\nOn 连接条件\n【where 筛选条件】\n【group by 分组】\n【having 分组后筛选】\n【order by 排序列表】\n\n### 内连接\n\nSql192语法：\n```\n（1）等值连接\n案例：\n查询女神名和对应男生名\nSELECT b.name,bs.boyName \nFROM beauty b, boys bs \nWHERE b.boyfriend_id = bs.id;\n\n查询员工名和对应的部门名\nSELECT e.last_name, e.department_id, d.department_name \nFROM employees e, departments d \nWHERE e.department_id=d.department_id;\n\n查询有奖金的员工名，部门名\nSELECT e.`last_name`, d.`department_id`, e.`commission_pct` \nFROM employees e,departments d \nWHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;\n\n查询每个工种的工种名和员工的个数，并且按员工个数降序\nSELECT j.job_title, COUNT(*) \nFROM employees e, jobs j \nWHERE e.`job_id`=j.`job_id` \nGROUP BY j.`job_title` ORDER BY COUNT(*) DESC;\n\n（2）非等值连接\n案例：\n查询员工的工资和工资级别\nSELECT e.`salary`, j.`grade_level` \nFROM employees e, job_grades j\nWHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`='E';\n\n（3）自连接\n查询员工名和上级的名称\nSELECT e1.last_name, e2.`last_name` \nFROM employees e1,  employees e2\nWHERE e1.`manager_id`=e2.`employee_id`;\n\n三表连接：查询员工名，部门名和所在的城市\nSELECT e.last_name, d.`department_name`, l.`city` \nFROM employees e, departments d, locations l\nWHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;\n```\n\nsql99语法：Inner \n```sql\n查询员工名，部门名\nSELECT e.last_name, d.`department_name` FROM employees e \nINNER JOIN departments d ON e.`department_id`=d.`department_id`;\n\n查询名字中只能包含e的员工名和工种名\nSELECT e.last_name, j.`job_title` FROM employees e \nINNER JOIN jobs j ON e.`job_id`=j.`job_id`\nWHERE e.`last_name` LIKE '%e%';\n\n查询部门个数>3的城市名和部门个数\nSELECT l.`city`, COUNT(*) FROM locations l \nINNER JOIN departments d ON l.`location_id` = d.`location_id`\nGROUP BY l.`city` HAVING COUNT(*)>3;\n\n查询工资级别的个数>2的个数，并按工资级别降序\nSELECT j.`grade_level`, COUNT(*) 个数 FROM job_grades j\nINNER JOIN employees e ON e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal`\nGROUP BY j.`grade_level` HAVING 个数>2 \nORDER BY 个数 DESC;\n```\n\n### 外连接\n\n应用场景：用于查询一个表中有，另一个表没有\n\n1.外连接的查询结构为主表中的所有记录  \n如果从表中有和它匹配的，则显示匹配值  \n如果从表中没有和它匹配的，则显示为null  \n外连接查询结果=内连接结果+主表中有而从表没有的数据\n\t\n2.左外连接，left join左边的是主表  \n右外连接，right join右边的是主表  \n\n3.左外和右外交换两个表的顺序，可以实现同样的效果\n\n（1）左连接：  \n语法：Left 【outer】\n```sql\n查询没有男朋友的女神名\nSELECT * FROM beauty b \nLEFT JOIN boys bo ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM departments d\nLEFT JOIN employees e ON d.`department_id`=e.`department_id`\nWHERE e.`employee_id` IS NULL\nGROUP BY d.`department_id`;\n```\n（2）右连接  \n语法：Right 【outer】\n```sql\n#查询没有男朋友的女神名\nSELECT * FROM boys bo \nRIGHT JOIN beauty b ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM employees e \nRIGHT JOIN departments d ON e.`department_id`=d.`department_id`\nWHERE e.`employee_id` IS NULL \nGROUP BY d.`department_id`;\n```\n\n（3）全外（mysql不支持）  \n语法：Full 【outer】\n\n### 交叉连接\n\n语法：Cross\n```sql\n女神男神表交叉连接\nSELECT b.*, bo.* FROM beauty b\nCROSS JOIN boys bo;\n```\n\n## 子查询\n\n### 含义\n\n出现在其他语句的select语句，称为子查询或内出现  \n内部嵌套其他select语句的查询，称为外查询或主查询\n\n### 分类：\n\n按子查询出现的位置：  \n1）select 后面  \n2）from 后面  \n3）wehre 或 having后面  \n4）exists后面（相关子查询）  \n\n按结果集的行列数不同：  \n1）标量子查询（结果集只有一行一列）  \n2）列子查询（结果集只有一列多行）  \n3）行子查询（结果集有多行多列）  \n4）表子查询（结果集一般为多行多列）\n\n### 用法\n\n```> < <> = ```\n\n```sql\n\n谁的工资比 Abel 高？\nSELECT last_name, salary\nFROM employees WHERE salary>(\n\tSELECT salary FROM employees WHERE last_name='Abel'\n);\n\n返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资\nSELECT last_name,job_id,salary FROM employees \nWHERE job_id =(\n\tSELECT job_id FROM employees WHERE employee_id=141\n) AND salary>(\n\tSELECT salary FROM employees WHERE employee_id=141\n);\n\n案例3：返回公司工资最少的员工的last_name,job_id和salary\nSELECT last_name, job_id, salary FROM employees \nWHERE salary = (\n\tSELECT MIN(salary) FROM employees\n);\n\nIn（常用）：\n作用：可以是子查询中的任一一个\n返回location_id是1400或1700的部们中的所有员工姓名\nSELECT last_name\nFROM employees\nWHERE department_id IN (\n\tSELECT department_id FROM departments WHERE location_id IN(1400, 1700)\n);\n\nAny（不常用）：\n作用：任一一个\n\n返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ANY(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n\nAll（不常用）：\n作用：所有的\n\n返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ALL(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n```\n\n## 分页查询（常用）\n\n应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。\n\n### 语法：\n\nselect 参数列表  \nfrom 表  \nleft join 表名 on 连接条件  \nwhere 筛选条件  \ngroup by 分组字段 having 分组后筛选  \norder by 排序字段  \nlimit 【offset,】 size；\n\noffset 要显示条目的起始索引（起始索引从0开始）  \nsize 要显示的条目个数\n特点：limit语句放在查询语句的最后\n\n### 案例：\n\n查询第二页，一页10条记录  \nSelect * from user limit 10, 10;\n\n## Union联合查询\n\nunion 联合 合并：将多条查询语句的结果合并成一个结果\n\n应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时\n\n### 语法\n\n查询语句1\nunion\n查询语句2\nunion\n....\n\n特点：  \n1.要求多条查询语句的查询列数是一致的  \n2.要求多条查询语句的查询的每一列的类型和顺序最好一致  \n3.union关键字默认去重，如果使用union all 可以包含重复项\n\n### 案例\n\n```sql\n--Union\nSelect id, name from user\nUnion\nSelect id,name from emp;\n\n--Union all\nSelect id, name from user\nUnion all\nSelect id,name from emp;\n```\n\n# DML语言\n\n数据库操作语言：  \n插入：insert  \n修改：update  \n删除：delete\n\n## 插入语句\n\n### 方式1\n\n语法：  \nInser into 表名(列名, ...) values(值1, ...);\n\n使用：  \nINSERT INTO users VALUES(1, '欧阳荣', '男', 166842.5);  \nINSERT INTO users(id, NAME, sex, gz) VALUES(2, '赵云彬', '欧阳荣', NULL);\n\n### 方式2\n\n语法：  \ninsert into 表名 set 列名=值,列名=值,....;\n\n使用：  \nINSERT INTO boys SET id=6, boyName='侄子', userCp=147258;\n\n### 两种开发方式pk\n\ninsert方式一次可以加多条，第二种方式不行  \nINSERT INTO boys VALUES(7, '欧阳荣', 10000000), (8, '欧阳荣', 10000000);\n\ninsert方式可以用子查询  \nINSERT INTO boys SELECT 10, 'ii', 150044;\n\n## 修改语句\n\n### 修改单表的记录（常用）\n\n语法：\nUpdate 表名 set 列=新值, 列=新值.... where 筛选条件;\n\n案例：\n修改beauty表中姓唐的女神电话为1389988889\nUPDATE beauty SET phone='1389988889' WHERE NAME LIKE '唐%';\n\n修改boys表中id号为2的名称为张飞，魅力值10\nUPDATE boys SET boyName='张飞', userCP=10 WHERE id=2;\n\n\n4.2.2.修改多表的记录（补充）\n192语法：\nUPDATE 表名 别名,表名 别名 \nSET 列=值,列=值 ... \nWHERE 连接添加 AND 筛选条件\n\n\n\n199语法:\nUPDATE 表名 别名\nINNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件\nSET 列=值，列=值 ...\nWHERE 筛选条件\n\n\n案例（以下实现都为199语法）：\n\n修改张无忌的女朋友的手机号为114\nUPDATE boys bo \nINNER JOIN beauty b ON bo.id=b.boyfriend_id \nSET phone='114' \nWHERE bo.boyName='张无忌';\n\n\n\n修改没有男朋友的女神的男朋友的编号都为2号\nUPDATE boys bo \nRIGHT JOIN beauty b ON bo.id=b.boyfriend_id \nSET b.boyfriend_id=2 \nWHERE bo.id IS NULL;\n\n\n\n4.3.删除语句\n\n4.3.1.方式1：delete\n语法：\n（1）单表删除（重要）：\nDelete from 表名 where 筛选条件;\n\n（2）多表删除（补充）\n192：\nDelete 表1别名, 表2别名 \nfrom 表一 别名, 表二别名\nWhere 连接条件 and 筛选条件\n\n199：\nDelete 表1别名, 表2别名\nFrom 表一 别名\ninner|Left|right| join 表2 别名 on 连接条件\nWhere 筛选条件\n\n\n案例：\n\n删除手机号以9结尾的女神信息\nDELETE FROM beauty WHERE phone LIKE '%9';\n\n\n删除张无忌的女朋友的信息\nDELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id\nWHERE bo.`boyName`='张无忌';\n\n删除黄晓明的信息以及他女朋友的信息\nDELETE b, bo FROM boys bo \nINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id` \nWHERE bo.`boyName`='黄晓明';\n\n4.3.2.方式2：truncate\n语法：\nTruncate table 表名;\n\n特点：\n不能加筛选条件，也叫做清空。\n\n4.3.3.delete pk truncate（面试题）\n\n1.delete可以加where条件，truncate不可以\n2.truncate删除，效率高一丢丢\n3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。\n如果使用truncate删除后，再插入值，自增长列的值从1开始。\n4.truncate删除没有返回值，delete删除有返回值\n5.truncate删除不能回滚，delete删除可以回滚。\n\n\n5.DDL语言\n数据库定义语言，也就是库和表的管理\n\n5.1.库的管理\n\n5.1.1.库的创建\n\n语法：\ncreate database [if not exists] 库名 [character set 字符集]\n\n案例：\n\n创建一个db_book库\nCREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;\n\n\n5.1.2.库的修改\n\n修改库名（现在不能用了）：\n语法：\nrename database 库名 to 新库名;\n\n案例\n把db_oyr库名改成my_oyr\nRENAME DATABASE db_oyr TO my_oyr;\n\n\n修改字符集：\n语法：\nalert database 库名 character set 字符集;\n\n案例：\n\n修改db_oyr的字符集为gbk\nALTER DATABASE db_oyr CHARACTER SET gbk;\n\n5.1.3.库的删除\n\n语法：\nDROP DATABASE [IF EXISTS] 库名;\n\n案例:\n删除db_oyr\nDROP DATABASE db_oyr; \n\n5.2.表的管理\n\n5.2.1.表的创建\n\n语法：\ncreate table 表名(\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t...\n\t列名 列类型【（类型长度） 约束】\n);\n\n案例：\n创建book表\nCREATE TABLE book(\n\tid INT,#编号\n\tbName VARCHAR(20),#图书名\n\tprice DOUBLE,#价格\n\tauthorId INT,#作者编号\n\tpublishDate DATETIME#出版日期\n);\n\n\n5.2.2.表的修改\n\n语法：\nAlter table 表名 add|drop|modify|change column 列名 【列类型 约束】\n\n（1）修改列名\n\nALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);\n\n（2）修改列的类型或约束\n\nALTER TABLE my_book MODIFY COLUMN myName INT;\n\n（3）添加新列\n\nALTER TABLE book ADD COLUMN oo VARCHAR(20);\n\n（4）删除列\n\nALTER TABLE book DROP COLUMN oo;\n\n（5）修改表名\n\nALTER TABLE book RENAME TO my_book;\n\n\n5.2.3.表的删除\n\n语法：\nDROP TABLE 【IF EXISTS】 表名;\n\n案例：\n\n删除my_book表\nDROP TABLE IF EXISTS my_book;\n\n\n5.2.4.表的复制\n1)复制表的结构\n语法：\nCreate table 新表名 like 被复制的表名;\n\n复制boys的结构\nCREATE TABLE copy LIKE boys;\n\n2)复制表的结构和数据\n语法：\nCreate table 新表名\nSelect * from 被复制表的表名\n\n复制boys表的结构和数据\nCREATE TABLE copy2 \nSELECT * FROM boys;\n\n复制boys部门数据和部分列\nCREATE TABLE copy3\nSELECT id,boyName FROM boys WHERE id<5; \nSELECT * FROM copy3;\n\n复制几个字段的结构\nCREATE TABLE copy4\nSELECT id, boyName FROM boys\nWHERE 1=2;\n\n\n5.3.常见的约束\n\n5.3.1.约束介绍\n\n六大约束：\nNOT NULL：非空约束，用于保证该字段的值不能为空\nUNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空\nPRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空\nCHEACK：检查约束【MYSQL中不支持，没有效果】\nFOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值\nDEFAULT：默认值，用于保证字段有默认值\n\n\n添加约束的时机：\n创建表时\n修改表时\n\n\n约束的添加分类：\n列级约束：\n六大约束语法上都支持，单外检约束没有效果\n表级约束：\n除了非空，默认，其他都支持\n\n列级约束 VS 表级约束\n位置\t\t\t支持的约束类型\t\t\t\t\t是否可以起别名\n列级：\t列的后面\t\t都支持，但外键没有效果\t\t\t不可以\n表级：\t所有列的下面\t默认和非空不支持，其他都支持\t可以主键（没有效果）\n\n\n\n\n5.3.2.添加列级约束\n\n新建一个库students，在里面测试添加列级约束\n\n\n\n# 新建主修表\ncreate table major(\n\tid bigint(20) primary key, #主键约束\n\tmajor_name varchar(25) NOT NULL #非空约束\n)\n\n# 新建学生表\ncreate table student(\n\tid bigint(20) primary key, #主键约束\n\tstu_name varchar(25) NOT NULL, #非空约束\n\tsex char(2) CHECK(sex = '男' or sex = '女'), #检查约束\n\tage int default 20, #默认约束\n\tcard varchar(25) unique,#唯一约束\n\tmajor_id bigint(20) REFERENCES major(id) #外键约束\n)\n\n经过测试后发现，检查约束是无效的，而且外检约束也是无效的。\n其他都是ok的。\n\n\n5.3.3.添加表级约束\n\n语法：\n在表字段的最下面\n[constraint 约束名] 约束类型(字段名)\n表级约束添加外键是有效的。\n\n指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效\n  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束\nCONSTRAINT ch_sex CHECK(sex = '女' or sex ='男'),\n  CONSTRAINT `pk_student_major` FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n\n不指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  PRIMARY KEY(id), #主键，约束名不生效\n  UNIQUE KEY(card), #唯一约束\n\tCHECK(sex = '女' or sex ='男'),\n  FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n5.3.4.主键约束 VS 唯一约束\n\n保证唯一性\t是否允许为空\t一个表中有几个\t是否允许出现组合\n主键\t\t√\t\t\t×\t\t\t\t最多一个\t\t√，但不推荐\n唯一\t\t√\t\t\t×\t\t\t\t可以多个\t\t√，但不推荐\n\n唯一约束可以允许为空，但null只能出现一次。\n组合就是组合主键或组合唯一约束。\n\n\n5.3.5.外键的特点\n\n从表：当前表\n主表：被关联的表\n\n1.要求在从表中设置外键关系\n2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求\n3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）\n4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表\n\n\n5.3.6.修改表时添加约束\n\n\n语法：\n1.添加列级约束\nalter table 表名 modify column 字段名 字段类型 新约束\n\n2.添加表级约束\nalter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]\n\n\n添加非空约束：\n列级：\nalter table student modify column stu_name varchar(25) not null;\n\n\n添加默认约束：\n列级：\nalter table student modify column age int default 20\n\n\n添加主键约束：\n列级：\nalter table student modify column id bigint(20) primary key\n表级：\nalter table student add primary key(id)\n\n\n添加唯一约束：\n列级：\nalter table student modify column card varchar(25) unique\n表级：\nalter table student add constraint un_card unique(card)\n\n\n添加外键约束：\n表级：\nalter table student add constraint fk_student_major foreign key(id) references major(id)\n\n\n5.3.7.修改表时删除约束\n\n1.删除非空约束（直接不写就是删除）\nalter table student modify column stu_name varchar(25)\n\n2.删除默认约束（不写即是删除）\nalter table student modify column age int default 20\n\n3.删除主键约束\naler table 表名 drop primary key\n\n4.删除唯一约束\nalter table 表名 drop index 约束名\n\n5.删除外键约束\nalter table 表名 drop foreign key 约束名\n\n\n5.4.标识列\n\n什么是标识列？\n标识列是自增长列\n含义：可以不手动的插入值，系统提供默认的序列值\n\n特点：\n1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）\n2.一个表只能有一个标识列\n3.标识类的类型只能是数值型\n4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值\n\n\n创建表时设置标识列\ncreate table tb_user(\n\tid int primary key auto_increment, #主键并且设置标识列\n\tname varchar(25) not null\n)\n\n\n修改表时设置标识列\nalter table tb_user modify column id int primary key auto_increment\n\n修改表时删除标识列\nalter table tb_user modify column id int primary key\n\n\n6.TCL 语言\nTCL：Transaction Control Language 事物控制语言\n\n事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。\n\n\n6.1.MySQL 中的存储引擎\n\n1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。\n2、通过show engines；来查看mysql支持的存储引擎。\n3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务\n\n\n6.2.事务的ACID属性\n\n1. 原子性（Atomicity）\n原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。\n\n2. 一致性（Consistency）\n事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。\n\n3. 隔离性（Isolation）\n并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。\n\n4. 持久性（Durability）\n持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n\n6.3.事物的使用步骤\n\n事物又分两种：隐式事物和显式事物\n隐式事物：事物没有明显的开启和结束的标记\n列如insert，update，delete\n\n显式事物：事物具有明显的开启和结束的标记\n前提：必须设置自动提交功能为禁用\n\n查看当前自动提交功能开关\nshow variables like 'autocommit'\n\n关闭自动提交功能，并不是永久的，只是当前回话被关闭\nset autocommit=0;\n\n\n开启事物的语法：\n#步骤1：开启事物\nset autocommit=0;\nstart transaction;#开启事物，可选的\n#步骤2：编写事物中的sql语句（select insert update delete）\n语句1;\n语句2;\n.......\n#步骤3：结束事物\ncommit;#提交事物\nrollback;回滚事物\n\n\n实战操作：\n初始化\ncreate table account(\n\tid bigint(20) primary key auto_increment,\n\tacc_name varchar(25),\n\tmoney double\n)\nINSERT INTO account (id, acc_name, money) VALUES (1, '欧阳荣', 1500);\nINSERT INTO account (id, acc_name, money) VALUES (2, '罗总', 500);\n\n\n\n\n\n转账成功提交：执行后可以看到数据库数据已经改变了\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\ncommit;\n\n\n转账失败回滚：执行后会发现数据并没有改变\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\nrollback;\n\n\n\n6.4.数据库的隔离级别\n\n6.4.1.并发问题\n\n对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n\n脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. \n之后, 若 T2 回滚, T1读取的内容就是临时且无效的.\n\n不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. \n之后, T1再次读取同一个字段, 值就不同了.\n\n幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插\n入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n\n\n\n6.4.2.四种事务隔离级别\n\n\n\nOracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。\n\nMysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。\n\n6.5.回滚点使用（savepotion）\n\nset autocommit=0;#设置不自动提交\nstart transaction;#开启事物\ndelete form account where id=1;\nsavepoint a;#保存点\ndelete from account where id=2;\nrollback to a;#回滚到保存点\n这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。\n\n\n7.视图\n7.1.什么是视图\n\n含义：虚拟表，和普通表一样使用\nMySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。\n\n\n应用场景：\n1.多个地方用到同样的查询结果\n2.该查询结果使用的sql语句较复杂\n\n\n7.2.视图的创建\n\n语法：\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\nOR REPLACE：表示替换已有视图\n\nALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表\n\n[WITH [CASCADED | LOCAL] CHECK OPTION]：\n表示视图在更新时保证在视图的权限范围之内\ncascade是默认值，表示更新视图的时候，要满足视图和表的相关条件\nlocal表示更新视图的时候，要满足该视图定义的一个条件即可\n推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 \n\n\n实际操作：\n\n1.查询邮箱中包含a字符的员工名，部门名，工种信息\n-- 创建视图\ncreate view view_test1\nAS\nSELECT\n\tCONCAT(e.first_name, e.last_name) 员工名,\n\tdept.department_name 部门名,\n\tj.job_title 工种信息\nFROM\n\temployees e\nLEFT JOIN departments dept ON dept.department_id = e.department_id\nLEFT JOIN jobs j ON j.job_id = e.job_id\nwhere email LIKE '%a%'\n-- 查询视图\nselect * from view_test1\n\n\n2.查询各部门的平均工资级别\ncreate view view_test2\nas \nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name\n\nSELECT\n\tvt.dept_name,\n\tjb.grade_level\nFROM\n\tview_test2 vt\nLEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal\nAND jb.highest_sal\n\n\n3.查询平均工资最低的部门\ncreate view view_test3\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n4.查询平均工资最低的部门名和工资\ncreate view view_test4\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n视图的好处：\n重用sql语句\n简化复杂的sql操作，不必知道它的查询细节\n保护数据，提高安全性\n\n\n7.3.视图的修改\n\n方式一：如果存在，则覆盖\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\n\n方式二：指定修改视图\nalter\n[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n    [DEFINER = { user | CURRENT_USER }]\n    [SQL SECURITY { DEFINER | INVOKER }]\nview 视图名\nas\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION];\n\n\n方式一实际操作：\ncreate or replace view view_test4\nas \nselect * from employees where employee_id > 105\n\n\n方式二实际操作：\nalter view view_test4\nas\nselect * from employees where employee_id > 120\n\n\n\n7.4.视图的删除\n\n语法：\ndrop view 视图名,视图名,视图名........\n\n实际操作：\ndrop view view_test4, view_test3\n\n\n7.5.查看视图\n方式1：desc 视图名\n\n方式2：show create view 视图名\n\n\n方式1实际操作：\ndesc view_test2\n\n可以看到实际上能看到的是当前视图可以查询出的字段信息\n\n\n方式2实际操作：\nshow create view view_test2\n\n可以看到的是当前拿到的是创建视图的逻辑sql。\n\n\n7.6.视图VS表\n\n创建语法的关键字\t是否实际占用物理空间\t使用\n视图\tcreate view\t\t\t只是保存了逻辑sql\t\t增删改查，一般不能增删改查\n\n表\t\tcreate table\t\t\t保存了数据\t\t\t\t增删改查\n\n\n\n8.变量\n\n8.1.系统变量\n\n说明：变量由系统提供的，不是银行定义，属于服务器层面\n系统变量又可以细分为全局变量和局部变量\n\n使用的语法：\n1.查看所有的系统变量\nshow global|[session] variables\n\n2.查看满足条件的部分系统变量\nshow global | [session] variables like '%char%';\n\n3.查看指定的某个系统变量的值\nselect @@global | [session] .系统变量名\n\n4.为某个系统变量赋值\n方式一：\nset global | [session] 系统变量名 = 值;\n\n方式二：\nSet @@global | [session] .系统变量名 = 值;\n\n注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别\n\n\n8.1.1.全局变量实际操作\n\n作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）\n\n（1）查看所有的全局变量\nshow global variables;\n\n（2）查看部分的全局变量\nshow global variables like '%char%';\n\n（3）查看指定的全局变量的值\nselect @@global.autocommit;\n\n\n（4）为某个指定的全局变量赋值\nset @@global.autocommit = 0;\n\n8.1.2.局部变量实际操作\n\n作用域：仅仅针对于当前会话（连接）有效\n\n（1）查看所有的会话变量\nshow variables\nshow session variables\n\n（2）查看部分的会话变量\nshow variables like '%char%'\nshow session variables like '%char%'\n\n（3）指定查看某个会话变量\nselect @@character_set_client\nselect @@session.character_set_client\n\n（4）为某个会话变量赋值\nset autocommit=0\nset @@session.autocommit=1\n\n8.2.自定义变量\n\n说明：变量是用户自定义的，不是由系统自动生成的。\n自定义变量又可以细分成用户变量（当前会话有效），局部变量\n使用步骤：\n声明\n赋值\n使用（查看，比较，运算等）\n\n8.2.1.用户变量\n\n作用域：针对于电器干会话（连接）有效，同于会话变量的作用域\n应用在任何地方，也就是begin end里面或begin end外面\n\n\n\n使用语法：\n\n（1）声明并初始化：\nset @用户变量名=值 或\nset @用户变量名:=值 或\nselect @用户变量名:=值\n\n（2）赋值（更新用户变量的值）\n方式一：通过set和select\nset @变量名=值 或\nset @变量名:=值 或\nselect @变量名:=值\n\n方式二：通过select into\nselect 字段 INTO @变量名\nfrom 表\n\n（3）使用（查看用户变量的值）\nselect @用户变量名\n\n\n实际操作：\n\n声明并且初始化：\n# 声明并且初始化\nset @name='欧阳荣';\nset @name:=10;\nselect @name:='罗总';\n\n赋值：\n#赋值\nset @count = 10;\nset @count := 15;\nselect @count := 20;\nselect count(*) into @count from account;\n\n使用：\nselect @count;\n\n\n\n\n\n8.2.2.局部变量\n\n作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句\n\n（1）声明\ndeclare 变量名 类型;\ndeclare 变量名 类型 default 值;\n\n（2）赋值\n方式一：通过set和select\nset 局部变量名=值 或\nset 局部变量名:=值 或\nselect @局部变量名:=值\n\n方式二：通过select into\nselect 字段 INTO 局部变量名\nfrom 表\n\n（3）使用\nselect 局部变量名\n\n8.2.3.用户变量 VS 局部变量\n\n作用域\t\t定义和使用的位置\t\t\t\t语法\n用户变量\t当前会话\t会话中的任何地方\t\t\t\t必须加@符，不限定类型\n局部变量\tbegin end中\t只能在begin end中，且为第一句\t不用加@符，需要限定类型\n\n9.存储过程和函数\n存储过程和函数：类似于java中的方法\n好处：\n1、提高代码的重用性\n2、简化操作\n\n\n9.1.存储过程\n\n\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n\n9.1.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate procedure 存储过程名(参数列表)\nbegin\n存储过程体（一组合法的SQL语句）\nend\n\n注意：\n1.参数列表包含三部分\n参数模式\t参数名\t参数类型\nin\t\t\tstudent\tvarchar(20)\n\n参数模式：\nin：\t该参数可以作为输入，也就是该参数需要调用方法传入值\t\nout：\t该参数可以作为输出，也就是该参数可以作为返回值\ninout：\t该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值\n\n2.如果存储过程体仅仅只有一句话，begin end可以省略。\n存储过程的每条SQL语句的结尾要求必须加上分号。\n存储过程的结尾可以使用delimiter重新设置\n语法：\nDELIMITER 结束标记\nDELIMITER $\n\n\n调用语法：\nCALL 存储过程名（实参列表）\n\n\n查看语法：\nshow create procedure 存储过程名;\n\n\n删除语法：\ndrop procedure 存储过程名;\n\n9.1.2.存储过程实战\n\n（1）空参的存储过程：\n# 创建存储过程\ncreate procedure myp1()\nbegin\n\tinsert into admin(name, money) values('z1', 11), ('z2', 22), ('z3', 33), ('z4', 44), ('z5', 55);\nend;\n\n#调用存储过程\nCALL myp1();\n\n\n带in模式参数的存储过程：\n根据女神名获取男神信息\n# 创建存储过程\ncreate procedure myp1(in beauty_name varchar(25))\nbegin\n\tselect bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n# 调用\ncall myp1('赵敏')\n\n根据用户名和密码判断是否能登录成功\n-- 创建存储过程\ncreate procedure myp2(in username varchar(25), in password varchar(25))\nbegin\n\tdeclare result int default '0';\n\tselect count(*) INTO result from admin a where a.username = username and a.`password` = password;\n\tselect if(result > 0, '成功', '失败');\nend;\n-- 调用\ncall myp2('john', '8888')\n\n\n（2）带out模式的存储过程：\n\n根据女神名，返回对应的男神名\n#创建\ncreate procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))\nbegin\n\tselect bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n-- 调用\nset @boy_name='';\ncall myp3('赵敏', @boy_name);\nselect @boy_name;\n\n根据女神名，返回对应的男神名和男神魅力值\n创建\ncreate procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)\nbegin\n\tselect bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n\n-- 调用\nset @boy_name='';\nset @user_cp=0;\ncall myp4('赵敏', @boy_name, @user_cp);\nselect @boy_name, @user_cp;\n\n\n（3）带inout模式参数的存储过程\n\n传入a和b两个值，最终a和b都翻倍并返回\n#创建\ncreate procedure myp5(inout x int, inout y int)\nbegin\n\tset x = x*2;\n\tset y = y*2;\nend;\n#调用\nset @x = 10;\nset @y = 20;\ncall myp5(@x, @y);\nselect @x, @y;\n\n\n\n\n\n9.2.函数\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n存储过程与函数的区别：\n存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新\n函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果\n\n\n9.2.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate function 函数名(参数列表) returns 返回类型\nbegin\n函数体\nend\n\n注意：\n1.参数列表包含两部分：参数名 参数类型\n2.函数体：肯定会有return语句，如果没有会报错。\n如果return语句没有放在函数体的最后也不报错，但不建议。\n3.函数体重仅有一句话，则可以省略begin end\n4.使用delimiter语句设置结束标记\n\n\n调用语法：\nselect 函数名（参数列表）\n\n\n查看语法：\nshow create function 函数名\n\n\n删除语法：\ndorp function 函数名\n\n\n\n9.2.2.函数实战\n\n（1）无参有返回\n\n返回公司的员工个数：\n#创建\ncreate function myf1() returns int\nbegin\n\tdeclare count int default 0;\n\tselect COUNT(*) into count from employees;\n\treturn count;\nend;\n#调用\nselect myf1();\n\n\n（2）有参返回\n\n根据员工名返回工资：\n#创建\ncreate function myf2(username varchar(25)) returns double\nbegin\n\tdeclare money double default 0;\n\tselect salary into money from employees where last_name = username;\n\treturn money;\nend;\n#调用\nselect myf2('Kochhar');\n\n\n根据部门名，发挥该部门的平均工资\n#创建\ncreate function myf3(dept_name varchar(25)) returns double\nbegin\n\tdeclare ave_salary double default 0;\n\tselect avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id\n\twhere dept.department_name = dept_name group by dept.department_id;\n\treturn ave_salary;\nend;\n#调用\nselect myf3('Adm');\n\n实现传入两个float，返回两者之和：\n\n#创建\ncreate function myf1(x float, y float) returns float\nbegin\n\tdeclare sum float default 0;\n\tset sum = x + y;\n\treturn sum;\nend;\n#调用\nselect myf1(1, 5.1);\n\n\n（3）查看函数\nshow create function myf3;\n\n\n\n（4）删除函数\ndrop function myf3\n\n\n10.流程控制结构\n顺序结构：程序从上往下依次执行\n分支结构：程序从两条或多条路径中选择一条去执行\n循环结构：程序在满足一定条件的基础上重复执行一段代码\n\n\n10.1.分支结构\n\n（1）if函数\n功能：实现简单的双分支\n语法：\nIf(表达式1, 表达式2, 表达式3)\n执行顺序：\n如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值\n应用：任何地方\n实战操作：\nselect if(1 > 2, 1, 2)\n当前sql执行后会返回2\n\n\n（2）case结构\n\n在begin end 外面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 返回的值1\nwhen 要判断的值 then 返回的值2\n....\nelse 返回的值n\nend\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 返回的值1\nwhen 要判断的条件2 then 返回的值2\n....\nelse 返回的值n\nend\n\n\n在begin end里面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 要执行的语句1\nwhen 要判断的值 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 要执行的语句1\nwhen 要判断的条件2 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate procedure show_grade(in grade int)\nbegin\n\tdeclare result varchar(2);\n\tCASE \n\tWHEN grade>=90 and grade<=100 THEN set result = 'A';\n\tWHEN grade>=80 THEN set result = 'B';\n\tWHEN grade>=60 THEN set result = 'C';\n\tELSE set result = 'D';\n\tEND CASE;\n\tselect result;\nend;\n\nCALL show_grade(99);\n\n\n#根据传递的数据库类型，显示对应的数据库名\ncreate procedure show_database_type(in val int)\nbegin\n\tdeclare result varchar(20);\n\tCASE val\n\tWHEN 1 THEN set result = 'mysql';\n\tWHEN 2 THEN set result = 'oracle';\n\tWHEN 3 THEN set result = 'sql server';\n\tELSE set result = '不认识的类型，滚啊。。。';\n\tEND CASE;\n\tselect result;\nend;\n\ncall show_database_type(1);\n\n\n（3）if结构\n功能：实现多重分类\n语法：\nif 条件1 then 语法1;\nesleif 条件2 then 语法2;\n...\n[else 语句n;]\nend if;\n\n应用场景：应用在begin end中\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate function show_grade(grade int) returns char(1)\nbegin\n\tdeclare result char(1);\n\tif grade>=90 and grade<=100 THEN set result = 'A';\n\telseif grade>=80 THEN set result = 'B';\n\telseif grade>=60 THEN set result = 'C';\n\telse set result = 'D';\n\tend if;\n\treturn result;\nend;\n\nselect show_grade(55);\n\n\n#批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止\ncreate procedure pro_while_insert2(in count int)\nbegin\n\tdeclare i int default 1;\n\ta:while i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tif i>=20 then leave a;\n\t\tend if;\n\t\tset i=i+1;\n\tend while a;\nend;\n\ncall pro_while_insert2(30);\n\n\n\n10.2.循环结构\n\n循环分类：\nwhile、 loop、repeat\n\n循环控制：\niterate类似于continue，结束本次循环，继续下一次循环\nleave类似于break，结束当前所在循环。\n\n\n三种循环语法：\n\n（1）while\n[标签:] while 循环条件 do\n循环体\nend while [标签]\n\n（2）loop\n[标签:] loop\n循环体\nend loop [标签]\n\n（3）repeat\n[标签:] repeat\n循环体\nuntil 结束循环的条件\nend repeat [标签]\n\n\n循环实战操作：\n\n#批量插入，根据次数插入到amdin表中多条数据\ncreate procedure pro_while_insert(in count int)\nbegin\n\tdeclare i int default 1;\n\twhile i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tset i=i+1;\n\tend while;\nend;\n\ncall pro_while_insert(10);\n\n\n\nwhile VS repeat VS loop\nwhile：先判断后执行\nrepeat：先执行后判断\nloop：没有条件的死循环\n\n# 博客园所学\n\n## 索引\n\n索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.  \n单列索引:一个索引只包含一个列,一个表可以有多个单列索引.   \n组合索引:一个组合索引包含两个或两个以上的列。\n\n### 索引的创建\n\n1）单列索引\n\n普通索引：\n第一种方式 :\nCREATE INDEX 索引名ON 表名(`字段名`(length))\n\n第二种方式: \nALTER TABLE award ADD INDEX account_Index(`account`)\n\n唯一索引：\nCREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));\nALTER TABLE TableName ADD UNIQUE (column_list)\n\n主键索引：不允许有空值\n\n2）组合索引：\n\n语法：\nCREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...);\n\n\n### 索引的删除\n语法：\nDORP INDEX IndexName ON `TableName`\n\n## 触发器\n\n触发器：监视某种情况，并触发某种操作。\n\n### 创建语法\n\n触发器创建语法四要素：1.监视地点(table)\n　　　　　　　　　　　2.监视事件(insert/update/delete)\n　　　　　　　　　　 3.触发时间(after/before)\n　　　　　　　　　　　4.触发事件(insert/update/delete)\n\n语法：\ncreate trigger triggerName after/before insert/update/delete\non 表名 for each row #这句话是固定的\n begin\n     #需要执行的sql语句\n end\n注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发\n注意2:insert/update/delete:只能选一个\n\n创建一个视图：\ncreate trigger tag1 after insert on order_table\nfor each row\nbegin\n\tupdate goods set num=num-3 where id=1;\nend;\n\n\n我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。\n对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。\n所以现在我们可以这样来改我们的触发器:\ncreate trigger tg1 after insert on order_table\nfor each row\nBEGIN\n\tupdate goods set num = num-new.much where id=new.gid; \nEND;\n\n当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？\n 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。\ncreate trigger tg2 after delete on order_table\nfor each ROW\nBEGIN\n\tupdate goods set num = num+old.much where id=old.gid;\nEND;\n\n### 删除触发器\n语法：drop trigger 触发器名称;\n使用：drop trigger dg1;","source":"_posts/MySQL/MySQL-基础.md","raw":"---\ntitle: MySQL基础\ndate: 2021-06-22 23:30:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: MySQL\ncategories: MySQL\n---\n\nMysql数据库\n\n# MySql基础\n\n## 数据库的好处\n\n可以持久化到本地  \n结构化查询\n\n***\n\n## 主流的数据库介绍（了解）\n\nSql server 数据库  \n是微软，.net程序员最爱，中型和大型项目，性能高\n\nOracle数据库  \n是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。\n\nMysql数据库  \n是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。\n\ndb2数据库  \n是ibm公司，处理海量数据，大型项目。很强悍。\n\nInformix数据库  \n是ibm公司。在银行系统，安全性高\n\nSybase数据库\n\n***\n\n## mysql的优点\n\n开源，免费成本低  \n性能高，移植性也好  \n体积小，便于安装\n\n## mysql数据库的安装和配置\n\n看MySQL-5.7.17安装与配置.docx\n\n## mysql的基本使用\n\n（1）连接到mysql\nCmd>mysql -h 主机名 -u 用户名 -p 密码 回车\n举例：\n\n说明：\n如果你没有写-h localhost 默认是连接本地\n\n如果你需要远程登录到另一个mysql,则需要修改配置。\n一般情况下部让远程登录。\n\n（2）sql服务的退出\nexit或ctrl+c\n\n（3）关闭和启动mysql服务\n界面操作：\n\n命令模式：\n启动：net stop mysql\n停止：net start mysql\n举例：\n\n说明：这里mysql不是固定的，是安装时取的服务名称。\n\n## mysql数据库三层架构介绍\n\n专业术语\n\nDb：  \n数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。\n\nDbms：  \n数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。\n\nSql:  \n结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。\n\n数据库服务器，数据库和表的关系如图所示：\n\n\n示意图：\n\n## mysql常见命令\n\n```\n1.查看当前所有的数据库\nshow databases;\n\n2.打开指定的库\nuse 库名;\n\n3.查看所在的数据库名\nselect database();\n\n4.查看当前库的所有表\nshow tables;\n\n5.查看其它库的所有表\nshow tables from 库名;\n\n6.创建表\ncreate table user(id int, name varchar(20));\n\n7.查看表结构\ndesc 表名;\t\t\n\n8.查看服务器的版本\n方式一：登录到mysql服务端\nSelect version();\n方式二：没有登录到mysql服务端\nMysql --version或mysql --V\n\n9.查看当前时区\nSHOW VARIABLES LIKE 'time_zone'\nSET time_zone='+9:00';\n```\n\n## Mysql的语法规范\n\n1.不区分大小写，单建议关键字大写，表名，列名小写。  \n2.每条语句最好用分号结尾。  \n3.每条命令根据需要，可以进行缩进或换行  \n4.注释  \n单行注释：两种  \n第一种：#注释文字  \n第二种：-- 注释文字  \n多行注释：/* 注释文字 */\n\n\n\n# 常用数据类型\n\n## 数值型\n\n2.1.1.整型\n\n\n\n特点：\n（1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字\n（2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值\n（4）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！\n\n\n2.1.2.小数\n\n\n浮点型：\nFloat(m, d)，double(m, d)\n4\t\t\t8\n\n定点型：\nDec(m, d)，decimal(m, d)\nM+2\t\tm+2\n\n特点：\n（1）\nM：整数部位+小数部位（总长度）\nD：小数部位\n如果超出范围插入临界值\n\n（2）\nM和D都可以省略\n如果是decimal，则m默认为10，d默认为0\n如果是double和float，则会随着插入的数值的精度来决定精度\n\n（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用\n\n\n2.2.字符型\n\n较短的文本：\nChar\nVarchar\n\n特点：\n\n写法\t\tm的意思\t\t\t特点\t\t\t空间的耗费\t\t效率\nChar\tchar(m)\t\t最大的字符数\t固定长度\t\t比较耗费\t\t高\nVarchar\tvarchar(m)\t最大的字符数\t可变长度的字符\t比较节省\t\t低\n\n\n较长的文本：\nText\nBlob（较大的二进制）\n\n\nEnum类型：\n说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。\n如果列表成员为1~255，则需要1个字节存储\n如果列表成员为255~65535，则需要2个字节存储\n最多需要65535个成员\n\n\nSet类型：\n说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区\n别是：SET类型一次可以选取多个成员，而Enum只能选一个\n根据成员个数不同，存储所占的字节也不同\n\n\n2.3.日期型\n\n\n总结：\nDate：只保存日期，并没有保存到时分秒\nTime：只保存时间（时分秒）\nYear：只保存年\n\nDatetime：保存日期+时间\nTimestamp：保存日期+时间\n\n\nDatetime VS Timestamp\n\n字节\t范围\t\t时区等的影响\nDatetime \t8\t\t1000-9999\t\t不受\nTimestamp\t4\t\t1970-2038\t\t受\n\n# DQL语言（select）\n\n## 基础查询\n\n### 语法\n\nselect 查询列表 from 表名\n\n### 特点\n查询列表开源是字段，常量表达式，函数，也可以有多个。  \n查询结构是一个虚拟表。\n\n### 示例\n\n1.查询单个字段  \nSelect 字段名 from 表名\n\n2.查询多个字段  \nSelect 字段名,字段名 from 表名\n\n3.查询所有的字段  \nSelect * from 表名\n\n4.查询常量  \nSelect 常量值  \n注意：字符型和日期型常量值必须用单引号用起来，数值类不需要\n\n5.查询函数 \nSelect 函数名（实例参数）;\n\n6.查询表达式  \nSelect 100*10;\n\n7.取别名  \n两种方式  \nAs  \nSelect last_name as 姓名 from 表名  \n\n空格  \nSelect last_name 姓名 from 表名\n\n8.去重  \nSelect distinct 字段名 from 表名\n\n9.+  \n作用：加法运算  \nSelect 数值+数值;直接运算  \nSelect 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，\t再做运算。\n\n10.补充Concat函数  \n功能：拼接字符  \nSelect concat(字符1,字符2,字符3,....)\n\n11.补充ifnull函数  \nSelect ifnull(name, 0) from user\n\n12.补充isnull函数  \nSelect isnull(name) from user  \n功能：拍的某个字段是否为null，如果是返回1，如果不是返回0\n\n\n## 条件查询\n\n### 语法\n\nSelect 查询列表  \nFrom 表名  \nWhere 筛选条件\n\n### 筛选条件的分类\n\n（1）简单条件运算符  \n\n```> < = <> != >= <= <=>```\n\nSelect * from user where age>15;\n\nSelect * from user where age<15;\n\nSelect * from user where age<>15;\n\n<=>:安全等于，可以判断普通数值，也可以判断是否为null  \nSelect * from user where age<=> null;\n\n（2）逻辑运算符\n\n```and or not```\n\nAnd:  \nSELECT last_name FROM employees WHERE salary>=10000 AND salary<=20000;\n\nOr:  \nSELECT * FROM employees WHERE department_id<90 OR department_id>110 OR salary>15000;\n\nNot:  \nSELECT * FROM employees WHERE NOT(department_id>=90 AND department_id<=110) OR salary>15000;\n\n（3）模糊查询\n\n```Like, between and, in, is null, is not null ```\n\nlike：  \nSelect * from user where name like’%a%’;  \nSelect * from user where name like’_a%’;\n\n\nbetween and:  \n作用：在哪两个数之间  \nSelect * from user where age between 10 and 20;\n\nin:  \nSelect * from user where id in(1,2,3);\n\nis null:  \n作用：判断是否为null  \nSelect * from user where age is null;\n\nis not null:  \n作用：判断是否不为空  \nSelect * from user where age is not null;\n\n## 排序查询\n\n### 语法\n\nSelect * from 表名  \n[Where 筛选条件]  \nOrder by 排序列表[asc desc]\n\n### 特点\n（1）asc代表升序，desc代表降序，如果不写是升序。  \n（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名  \n（3）order by子句一般是放查询语句的最后面，limit子句除外\n\n### 案例\n\n#案例：查询员工信息，要求工资冲高到底排序  \n```sql\nSELECT * FROM employees ORDER BY salary DESC;\n```\n\n#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  \n```sql\nSELECT *, salary*12*(1+IFNULL(commission_pct, 0)) AS 年薪 \nFROM employees \nORDER BY 年薪 DESC;\n```\n\n#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 \n``` sql\nSELECT * FROM employees \nWHERE email LIKE '%e%' \nORDER BY LENGTH(email) DESC, department_id ASC;\n```\n\n## 常见函数\n\n功能：类似java中的方法  \n好处：提高重用性和隐藏实现细节  \n调用：select 函数名(参数列表)  \n\n### 字符函数\n\nLENGTH：  \n作用：获取参数的字节个数  \nSELECT LENGTH('oyr');  \nSELECT LENGTH('欧阳荣');\n\n\nCONCAT：  \n作用：拼接字符串  \nSELECT CONCAT('abc', 'jkl');  \nSELECT CONCAT(first_name, last_name) out_put FROM employees;\n\n\nUPPER：  \n作用：字符串变大写  \nSELECT UPPER(\"asc\");\n\n\nLower：  \n作用：字符串变小写\nSELECT LOWER(\"ASC\");\n\n\nSubstr:  \n作用：截取字符串，两种使用方式\n``` sql\n#第一种：截取从指定索引处后面所有字符  \nSELECT SUBSTR(\"欧阳荣真的帅哦\", 4);  \n结果：真的帅哦\n\n#第二种：截取从指定索引处指定字符串的字符  \nSELECT SUBSTR(\"欧阳荣不是一般帅哦\", 1, 3);  \n结果：欧阳荣\n\n# 案例1：姓名首字母大写，其他字符小写然后用_拼接，显示出来\nSELECT CONCAT(UPPER(SUBSTR(last_name, 1, 1)), '_', LOWER(SUBSTR(last_name, 2))) FROM employees;\n```\n\nTrim:\n作用：去除两边空格或去除两边指定字符\n``` sql\n#去除两边空格：\nSELECT LENGTH(TRIM('   欧阳荣 '));\n结果：欧阳荣\n\n#去除两边指定字符：\nSELECT TRIM('a' FROM 'aaaaaaaa欧阳aaa荣aaaaaa');\n结果：欧阳aaa荣\n```\n\nLpad：  \n作用：lpad 用指定的字符实现左填充指定长度  \nSELECT LPAD('欧阳荣', 10, 'a') out_put;\n\nRpad：  \n作用：用指定的字符实现右填充指定长度  \nSELECT LPAD('欧阳荣', 12, 'ab') out_put;\n\nReplace：  \n作用：替换字符串  \nSELECT REPLACE('赵吊彬是zz赵吊彬赵吊彬赵吊彬', '赵吊彬', '李执志');\n\nInstr:  \n作用：获取子串第一次出现的索引\nSELECT INSTR('欧阳荣多对多', '欧阳');\n结果为：1\n\n### 数学函数\n\nRound:  \n作用：四舍五入\n```\n第一种使用：\nSELECT ROUND(1.65);\n结果：2\n\n第二种使用：\nSELECT ROUND(1.657, 2);\n结果：1.66\n```\n\nCeil：  \n作用：向上取整  \nSELECT CEIL(1.52);  \n结果：2\n\n\nFloor：  \n作用：向下取整  \nSELECT FLOOR(9.99);  \n结果：9\n\nTruncate：  \n作用：截断  \nSELECT TRUNCATE(10.19, 1);  \n结果：10.1\n\n\nMod：  \n作用：取余  \nSELECT MOD(10, 3);  \n结果：1\n\nRand：  \n作用：获取随机数，返回0-1之间的小数  \nSELECT RAND();\n\n### 日期函数\n\nNOW：  \n作用：返回当前系统日期+时间  \nSELECT NOW();\n\nCurdate：  \n作用：返回当前系统日期，不包含时间  \nSELECT CURDATE();\n\nCurtime：  \n作用：返回当前时间，不包含日期  \nSELECT CURTIME();\n\nYear：  \n作用：获取年  \nSelect year(now());  \nSELECT YEAR('1999-1-1') 年;\n\nMonth:  \n作用：获取月  \nSELECT MONTH(NOW()) 月;\n\nDay:  \n作用：获取日  \nSelect DAY(now()) 日;\n\n\n日期格式符：\n\n\n\n\n\nStr_to_date:  \n作用：将日期格式的字符转换成指定格式的日期  \nSELECT STR_TO_DATE('1999-6-2', '%Y-%c-%d') out_put;  \nSELECT * FROM employees WHERE hiredate=STR_TO_DATE('4-3 1992', '%c-%d %Y');\n\n\nDate_format：  \n作用：将日期转换成字符  \nSELECT DATE_FORMAT(NOW(), '%y年%m月%d日') AS out_put;\n\n案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）\nSELECT last_name, DATE_FORMAT(hiredate, '%M月/%d日 %y年') \nFROM employees \nWHERE commission_pct IS NOT NULL;\n\nDatediff：  \n作用：返回两个日期相差的天数  \nSELECT DATEDIFF(NOW(), '1999-06-24');\n\n\n### 其他函数\n\nVERSION：  \n作用：查看当前mysql版本号  \nSELECT VERSION();\n\nDATABASE：  \n作用：查看当前打开的数据库  \nSelect DATABASE();\n\nUSER：  \n作用：查看当前登录的用户  \nSelect USER();\n\n### 流程控制函数\n\nIf：  \n作用：判断真假  \nSELECT IF(10<5, '小', '大');\n\nCase:  \n作用：判断  \n语法：  \ncase 要带的字段或表达式  \nwhen 常量1 then 要显示的值1或语句1;  \nwhen 常量1 then 要显示的值1或语句1;  \n.....  \nelse 要显示的值n或语句n  \nEnd\n\n``` sql\n案例：查询员工的工资，要求\n部门号=30,显示的工资为1.1倍\n部门号=40，显示的工资为1.2倍\n部门号=50，显示的工资为1.3倍\n其他部门，显示的工资为原工资\n\nSELECT last_name, salary 原工资, \nCASE department_id\nWHEN 30 THEN salary*1.1\nWHEN 40 THEN salary*1.2\nWHEN 50 THEN salary*1.3\nELSE salary\nEND AS 新工资\nFROM employees;\n\n案例：查询员工的工资的情况\n如果工资>20000，显示A级别\n如果工资>15000，显示B级别\n如果工资>10000,显示C级别\n否则，显示D级别\n\nSELECT last_name,salary,\nCASE\nWHEN salary>20000 THEN 'A'\nWHEN salary>15000 THEN 'B'\nWHEN salary>10000 THEN 'C'\nELSE 'D'\nEND AS 级别\nFROM employees;\n```\n\n## 分组\n\n### 分组函数\n\nsum:\n作用：求和\nSELECT SUM(salary) FROM employees;\n\n\nmax:\n作用：最大值\nSelect max(salary) from employees;\n\n\nmin：\n作用：最小值\nSELECT MIN(salary) FROM employees;\n\n\navg：\n作用：平均数\nSELECT AVG(salary) FROM employees;\n\n\ncount：\n作用：计算个数\nSelect count(*) from user;\n\n\n注意事项：\nsum，avg一般用于数值型\nmax，min，count可以处理任何类型\n以上分组函数都忽略null值\n\n### 分组查询\n\n语法：\nselect 分组函数，列（要求出现在group by的后面）\nfrom 表\n[where 筛选条件]\ngroup by 分组的列表\n[having 分组后的筛选]\n[order by 子句]\n\n注意：\n查询列表必须特殊，要求是分组函数或group by后出现的字段\n分组后筛选在group by子句的后面使用 having 关键字\n分组函数做条件肯定是放在having子句中\n能用分组前筛选，就优先使用分组前筛选\ngroup by 子句支持单个字段分组，多个字段分组（用逗号隔开）\n\n简单分组：\n```sql\n#案例1：查询每个部门的平均工资\nSELECT department_id,AVG(salary) 平均工资 FROM employees GROUP BY department_id; \n\n#案例2：查询每个工种的最高工资\nSELECT job_id, MAX(salary) FROM employees GROUP BY job_id;\n\n#案例3：查询每个位置上的部门个数\nSELECT location_id, COUNT(*) FROM departments GROUP BY location_id;\n```\n\n添加筛选条件：\n```sql\n#案例1：查询邮箱中包含a字符的，每个部门的平均工资\nSELECT department_id, AVG(salary) \nFROM employees \nWHERE email LIKE '%a%' \nGROUP BY department_id;\n\n#案例2：查询有奖金的每个领导手下的最高工资\nSELECT manager_id, MAX(salary)\nFROM employees \nWHERE commission_pct IS NOT NULL \nGROUP BY manager_id;\n\n#案例3：查询哪个部门的员工个数>2\nSelect department_id, count(*) \nfrom employees\ngroup by department_id having count(*)>2;\n\n#案例4：查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT job_id, MAX(salary) \nFROM employees\nGROUP BY job_id HAVING MAX(salary)>12000;\n\n#案例5：查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个\nSELECT manager_id, MIN(salary) \nFROM employees \nWHERE manager_id>102 \nGROUP BY manager_id HAVING MIN(salary)>5000;\n\n#案例6：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些\nSELECT last_name, LENGTH(last_name), COUNT(*) 员工个数 \nFROM employees \nGROUP BY LENGTH(last_name) HAVING COUNT(*)>5;\n```\n\n## 连接查询\n\n什么是连接查询：  \n又称多表查询，当查询的字段来自多个表时，就会用到连接查询。\n\n笛卡尔积:  \n笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行\n\n\n### 分类\n\t\n按年代分类：  \nsql92标准：仅仅支持内连接  \nsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\n按功能分类：\n- 内连接：  \n    - 等值连接  \n    - 非等值连接  \n    - 自连接  \n- 外连接：  \n    - 左外连接  \n    - 右外连接  \n    - 全外连接（mysql不支持）  \n- 交叉连接：  \n\n### 语法\n\nSelect 查询列表\nFrom 表1 别名 【连接类型】\nJoin 表2 别名\nOn 连接条件\n【where 筛选条件】\n【group by 分组】\n【having 分组后筛选】\n【order by 排序列表】\n\n### 内连接\n\nSql192语法：\n```\n（1）等值连接\n案例：\n查询女神名和对应男生名\nSELECT b.name,bs.boyName \nFROM beauty b, boys bs \nWHERE b.boyfriend_id = bs.id;\n\n查询员工名和对应的部门名\nSELECT e.last_name, e.department_id, d.department_name \nFROM employees e, departments d \nWHERE e.department_id=d.department_id;\n\n查询有奖金的员工名，部门名\nSELECT e.`last_name`, d.`department_id`, e.`commission_pct` \nFROM employees e,departments d \nWHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;\n\n查询每个工种的工种名和员工的个数，并且按员工个数降序\nSELECT j.job_title, COUNT(*) \nFROM employees e, jobs j \nWHERE e.`job_id`=j.`job_id` \nGROUP BY j.`job_title` ORDER BY COUNT(*) DESC;\n\n（2）非等值连接\n案例：\n查询员工的工资和工资级别\nSELECT e.`salary`, j.`grade_level` \nFROM employees e, job_grades j\nWHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`='E';\n\n（3）自连接\n查询员工名和上级的名称\nSELECT e1.last_name, e2.`last_name` \nFROM employees e1,  employees e2\nWHERE e1.`manager_id`=e2.`employee_id`;\n\n三表连接：查询员工名，部门名和所在的城市\nSELECT e.last_name, d.`department_name`, l.`city` \nFROM employees e, departments d, locations l\nWHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;\n```\n\nsql99语法：Inner \n```sql\n查询员工名，部门名\nSELECT e.last_name, d.`department_name` FROM employees e \nINNER JOIN departments d ON e.`department_id`=d.`department_id`;\n\n查询名字中只能包含e的员工名和工种名\nSELECT e.last_name, j.`job_title` FROM employees e \nINNER JOIN jobs j ON e.`job_id`=j.`job_id`\nWHERE e.`last_name` LIKE '%e%';\n\n查询部门个数>3的城市名和部门个数\nSELECT l.`city`, COUNT(*) FROM locations l \nINNER JOIN departments d ON l.`location_id` = d.`location_id`\nGROUP BY l.`city` HAVING COUNT(*)>3;\n\n查询工资级别的个数>2的个数，并按工资级别降序\nSELECT j.`grade_level`, COUNT(*) 个数 FROM job_grades j\nINNER JOIN employees e ON e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal`\nGROUP BY j.`grade_level` HAVING 个数>2 \nORDER BY 个数 DESC;\n```\n\n### 外连接\n\n应用场景：用于查询一个表中有，另一个表没有\n\n1.外连接的查询结构为主表中的所有记录  \n如果从表中有和它匹配的，则显示匹配值  \n如果从表中没有和它匹配的，则显示为null  \n外连接查询结果=内连接结果+主表中有而从表没有的数据\n\t\n2.左外连接，left join左边的是主表  \n右外连接，right join右边的是主表  \n\n3.左外和右外交换两个表的顺序，可以实现同样的效果\n\n（1）左连接：  \n语法：Left 【outer】\n```sql\n查询没有男朋友的女神名\nSELECT * FROM beauty b \nLEFT JOIN boys bo ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM departments d\nLEFT JOIN employees e ON d.`department_id`=e.`department_id`\nWHERE e.`employee_id` IS NULL\nGROUP BY d.`department_id`;\n```\n（2）右连接  \n语法：Right 【outer】\n```sql\n#查询没有男朋友的女神名\nSELECT * FROM boys bo \nRIGHT JOIN beauty b ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM employees e \nRIGHT JOIN departments d ON e.`department_id`=d.`department_id`\nWHERE e.`employee_id` IS NULL \nGROUP BY d.`department_id`;\n```\n\n（3）全外（mysql不支持）  \n语法：Full 【outer】\n\n### 交叉连接\n\n语法：Cross\n```sql\n女神男神表交叉连接\nSELECT b.*, bo.* FROM beauty b\nCROSS JOIN boys bo;\n```\n\n## 子查询\n\n### 含义\n\n出现在其他语句的select语句，称为子查询或内出现  \n内部嵌套其他select语句的查询，称为外查询或主查询\n\n### 分类：\n\n按子查询出现的位置：  \n1）select 后面  \n2）from 后面  \n3）wehre 或 having后面  \n4）exists后面（相关子查询）  \n\n按结果集的行列数不同：  \n1）标量子查询（结果集只有一行一列）  \n2）列子查询（结果集只有一列多行）  \n3）行子查询（结果集有多行多列）  \n4）表子查询（结果集一般为多行多列）\n\n### 用法\n\n```> < <> = ```\n\n```sql\n\n谁的工资比 Abel 高？\nSELECT last_name, salary\nFROM employees WHERE salary>(\n\tSELECT salary FROM employees WHERE last_name='Abel'\n);\n\n返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资\nSELECT last_name,job_id,salary FROM employees \nWHERE job_id =(\n\tSELECT job_id FROM employees WHERE employee_id=141\n) AND salary>(\n\tSELECT salary FROM employees WHERE employee_id=141\n);\n\n案例3：返回公司工资最少的员工的last_name,job_id和salary\nSELECT last_name, job_id, salary FROM employees \nWHERE salary = (\n\tSELECT MIN(salary) FROM employees\n);\n\nIn（常用）：\n作用：可以是子查询中的任一一个\n返回location_id是1400或1700的部们中的所有员工姓名\nSELECT last_name\nFROM employees\nWHERE department_id IN (\n\tSELECT department_id FROM departments WHERE location_id IN(1400, 1700)\n);\n\nAny（不常用）：\n作用：任一一个\n\n返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ANY(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n\nAll（不常用）：\n作用：所有的\n\n返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ALL(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n```\n\n## 分页查询（常用）\n\n应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。\n\n### 语法：\n\nselect 参数列表  \nfrom 表  \nleft join 表名 on 连接条件  \nwhere 筛选条件  \ngroup by 分组字段 having 分组后筛选  \norder by 排序字段  \nlimit 【offset,】 size；\n\noffset 要显示条目的起始索引（起始索引从0开始）  \nsize 要显示的条目个数\n特点：limit语句放在查询语句的最后\n\n### 案例：\n\n查询第二页，一页10条记录  \nSelect * from user limit 10, 10;\n\n## Union联合查询\n\nunion 联合 合并：将多条查询语句的结果合并成一个结果\n\n应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时\n\n### 语法\n\n查询语句1\nunion\n查询语句2\nunion\n....\n\n特点：  \n1.要求多条查询语句的查询列数是一致的  \n2.要求多条查询语句的查询的每一列的类型和顺序最好一致  \n3.union关键字默认去重，如果使用union all 可以包含重复项\n\n### 案例\n\n```sql\n--Union\nSelect id, name from user\nUnion\nSelect id,name from emp;\n\n--Union all\nSelect id, name from user\nUnion all\nSelect id,name from emp;\n```\n\n# DML语言\n\n数据库操作语言：  \n插入：insert  \n修改：update  \n删除：delete\n\n## 插入语句\n\n### 方式1\n\n语法：  \nInser into 表名(列名, ...) values(值1, ...);\n\n使用：  \nINSERT INTO users VALUES(1, '欧阳荣', '男', 166842.5);  \nINSERT INTO users(id, NAME, sex, gz) VALUES(2, '赵云彬', '欧阳荣', NULL);\n\n### 方式2\n\n语法：  \ninsert into 表名 set 列名=值,列名=值,....;\n\n使用：  \nINSERT INTO boys SET id=6, boyName='侄子', userCp=147258;\n\n### 两种开发方式pk\n\ninsert方式一次可以加多条，第二种方式不行  \nINSERT INTO boys VALUES(7, '欧阳荣', 10000000), (8, '欧阳荣', 10000000);\n\ninsert方式可以用子查询  \nINSERT INTO boys SELECT 10, 'ii', 150044;\n\n## 修改语句\n\n### 修改单表的记录（常用）\n\n语法：\nUpdate 表名 set 列=新值, 列=新值.... where 筛选条件;\n\n案例：\n修改beauty表中姓唐的女神电话为1389988889\nUPDATE beauty SET phone='1389988889' WHERE NAME LIKE '唐%';\n\n修改boys表中id号为2的名称为张飞，魅力值10\nUPDATE boys SET boyName='张飞', userCP=10 WHERE id=2;\n\n\n4.2.2.修改多表的记录（补充）\n192语法：\nUPDATE 表名 别名,表名 别名 \nSET 列=值,列=值 ... \nWHERE 连接添加 AND 筛选条件\n\n\n\n199语法:\nUPDATE 表名 别名\nINNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件\nSET 列=值，列=值 ...\nWHERE 筛选条件\n\n\n案例（以下实现都为199语法）：\n\n修改张无忌的女朋友的手机号为114\nUPDATE boys bo \nINNER JOIN beauty b ON bo.id=b.boyfriend_id \nSET phone='114' \nWHERE bo.boyName='张无忌';\n\n\n\n修改没有男朋友的女神的男朋友的编号都为2号\nUPDATE boys bo \nRIGHT JOIN beauty b ON bo.id=b.boyfriend_id \nSET b.boyfriend_id=2 \nWHERE bo.id IS NULL;\n\n\n\n4.3.删除语句\n\n4.3.1.方式1：delete\n语法：\n（1）单表删除（重要）：\nDelete from 表名 where 筛选条件;\n\n（2）多表删除（补充）\n192：\nDelete 表1别名, 表2别名 \nfrom 表一 别名, 表二别名\nWhere 连接条件 and 筛选条件\n\n199：\nDelete 表1别名, 表2别名\nFrom 表一 别名\ninner|Left|right| join 表2 别名 on 连接条件\nWhere 筛选条件\n\n\n案例：\n\n删除手机号以9结尾的女神信息\nDELETE FROM beauty WHERE phone LIKE '%9';\n\n\n删除张无忌的女朋友的信息\nDELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id\nWHERE bo.`boyName`='张无忌';\n\n删除黄晓明的信息以及他女朋友的信息\nDELETE b, bo FROM boys bo \nINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id` \nWHERE bo.`boyName`='黄晓明';\n\n4.3.2.方式2：truncate\n语法：\nTruncate table 表名;\n\n特点：\n不能加筛选条件，也叫做清空。\n\n4.3.3.delete pk truncate（面试题）\n\n1.delete可以加where条件，truncate不可以\n2.truncate删除，效率高一丢丢\n3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。\n如果使用truncate删除后，再插入值，自增长列的值从1开始。\n4.truncate删除没有返回值，delete删除有返回值\n5.truncate删除不能回滚，delete删除可以回滚。\n\n\n5.DDL语言\n数据库定义语言，也就是库和表的管理\n\n5.1.库的管理\n\n5.1.1.库的创建\n\n语法：\ncreate database [if not exists] 库名 [character set 字符集]\n\n案例：\n\n创建一个db_book库\nCREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;\n\n\n5.1.2.库的修改\n\n修改库名（现在不能用了）：\n语法：\nrename database 库名 to 新库名;\n\n案例\n把db_oyr库名改成my_oyr\nRENAME DATABASE db_oyr TO my_oyr;\n\n\n修改字符集：\n语法：\nalert database 库名 character set 字符集;\n\n案例：\n\n修改db_oyr的字符集为gbk\nALTER DATABASE db_oyr CHARACTER SET gbk;\n\n5.1.3.库的删除\n\n语法：\nDROP DATABASE [IF EXISTS] 库名;\n\n案例:\n删除db_oyr\nDROP DATABASE db_oyr; \n\n5.2.表的管理\n\n5.2.1.表的创建\n\n语法：\ncreate table 表名(\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t...\n\t列名 列类型【（类型长度） 约束】\n);\n\n案例：\n创建book表\nCREATE TABLE book(\n\tid INT,#编号\n\tbName VARCHAR(20),#图书名\n\tprice DOUBLE,#价格\n\tauthorId INT,#作者编号\n\tpublishDate DATETIME#出版日期\n);\n\n\n5.2.2.表的修改\n\n语法：\nAlter table 表名 add|drop|modify|change column 列名 【列类型 约束】\n\n（1）修改列名\n\nALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);\n\n（2）修改列的类型或约束\n\nALTER TABLE my_book MODIFY COLUMN myName INT;\n\n（3）添加新列\n\nALTER TABLE book ADD COLUMN oo VARCHAR(20);\n\n（4）删除列\n\nALTER TABLE book DROP COLUMN oo;\n\n（5）修改表名\n\nALTER TABLE book RENAME TO my_book;\n\n\n5.2.3.表的删除\n\n语法：\nDROP TABLE 【IF EXISTS】 表名;\n\n案例：\n\n删除my_book表\nDROP TABLE IF EXISTS my_book;\n\n\n5.2.4.表的复制\n1)复制表的结构\n语法：\nCreate table 新表名 like 被复制的表名;\n\n复制boys的结构\nCREATE TABLE copy LIKE boys;\n\n2)复制表的结构和数据\n语法：\nCreate table 新表名\nSelect * from 被复制表的表名\n\n复制boys表的结构和数据\nCREATE TABLE copy2 \nSELECT * FROM boys;\n\n复制boys部门数据和部分列\nCREATE TABLE copy3\nSELECT id,boyName FROM boys WHERE id<5; \nSELECT * FROM copy3;\n\n复制几个字段的结构\nCREATE TABLE copy4\nSELECT id, boyName FROM boys\nWHERE 1=2;\n\n\n5.3.常见的约束\n\n5.3.1.约束介绍\n\n六大约束：\nNOT NULL：非空约束，用于保证该字段的值不能为空\nUNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空\nPRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空\nCHEACK：检查约束【MYSQL中不支持，没有效果】\nFOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值\nDEFAULT：默认值，用于保证字段有默认值\n\n\n添加约束的时机：\n创建表时\n修改表时\n\n\n约束的添加分类：\n列级约束：\n六大约束语法上都支持，单外检约束没有效果\n表级约束：\n除了非空，默认，其他都支持\n\n列级约束 VS 表级约束\n位置\t\t\t支持的约束类型\t\t\t\t\t是否可以起别名\n列级：\t列的后面\t\t都支持，但外键没有效果\t\t\t不可以\n表级：\t所有列的下面\t默认和非空不支持，其他都支持\t可以主键（没有效果）\n\n\n\n\n5.3.2.添加列级约束\n\n新建一个库students，在里面测试添加列级约束\n\n\n\n# 新建主修表\ncreate table major(\n\tid bigint(20) primary key, #主键约束\n\tmajor_name varchar(25) NOT NULL #非空约束\n)\n\n# 新建学生表\ncreate table student(\n\tid bigint(20) primary key, #主键约束\n\tstu_name varchar(25) NOT NULL, #非空约束\n\tsex char(2) CHECK(sex = '男' or sex = '女'), #检查约束\n\tage int default 20, #默认约束\n\tcard varchar(25) unique,#唯一约束\n\tmajor_id bigint(20) REFERENCES major(id) #外键约束\n)\n\n经过测试后发现，检查约束是无效的，而且外检约束也是无效的。\n其他都是ok的。\n\n\n5.3.3.添加表级约束\n\n语法：\n在表字段的最下面\n[constraint 约束名] 约束类型(字段名)\n表级约束添加外键是有效的。\n\n指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效\n  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束\nCONSTRAINT ch_sex CHECK(sex = '女' or sex ='男'),\n  CONSTRAINT `pk_student_major` FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n\n不指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  PRIMARY KEY(id), #主键，约束名不生效\n  UNIQUE KEY(card), #唯一约束\n\tCHECK(sex = '女' or sex ='男'),\n  FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n5.3.4.主键约束 VS 唯一约束\n\n保证唯一性\t是否允许为空\t一个表中有几个\t是否允许出现组合\n主键\t\t√\t\t\t×\t\t\t\t最多一个\t\t√，但不推荐\n唯一\t\t√\t\t\t×\t\t\t\t可以多个\t\t√，但不推荐\n\n唯一约束可以允许为空，但null只能出现一次。\n组合就是组合主键或组合唯一约束。\n\n\n5.3.5.外键的特点\n\n从表：当前表\n主表：被关联的表\n\n1.要求在从表中设置外键关系\n2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求\n3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）\n4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表\n\n\n5.3.6.修改表时添加约束\n\n\n语法：\n1.添加列级约束\nalter table 表名 modify column 字段名 字段类型 新约束\n\n2.添加表级约束\nalter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]\n\n\n添加非空约束：\n列级：\nalter table student modify column stu_name varchar(25) not null;\n\n\n添加默认约束：\n列级：\nalter table student modify column age int default 20\n\n\n添加主键约束：\n列级：\nalter table student modify column id bigint(20) primary key\n表级：\nalter table student add primary key(id)\n\n\n添加唯一约束：\n列级：\nalter table student modify column card varchar(25) unique\n表级：\nalter table student add constraint un_card unique(card)\n\n\n添加外键约束：\n表级：\nalter table student add constraint fk_student_major foreign key(id) references major(id)\n\n\n5.3.7.修改表时删除约束\n\n1.删除非空约束（直接不写就是删除）\nalter table student modify column stu_name varchar(25)\n\n2.删除默认约束（不写即是删除）\nalter table student modify column age int default 20\n\n3.删除主键约束\naler table 表名 drop primary key\n\n4.删除唯一约束\nalter table 表名 drop index 约束名\n\n5.删除外键约束\nalter table 表名 drop foreign key 约束名\n\n\n5.4.标识列\n\n什么是标识列？\n标识列是自增长列\n含义：可以不手动的插入值，系统提供默认的序列值\n\n特点：\n1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）\n2.一个表只能有一个标识列\n3.标识类的类型只能是数值型\n4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值\n\n\n创建表时设置标识列\ncreate table tb_user(\n\tid int primary key auto_increment, #主键并且设置标识列\n\tname varchar(25) not null\n)\n\n\n修改表时设置标识列\nalter table tb_user modify column id int primary key auto_increment\n\n修改表时删除标识列\nalter table tb_user modify column id int primary key\n\n\n6.TCL 语言\nTCL：Transaction Control Language 事物控制语言\n\n事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。\n\n\n6.1.MySQL 中的存储引擎\n\n1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。\n2、通过show engines；来查看mysql支持的存储引擎。\n3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务\n\n\n6.2.事务的ACID属性\n\n1. 原子性（Atomicity）\n原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。\n\n2. 一致性（Consistency）\n事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。\n\n3. 隔离性（Isolation）\n并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。\n\n4. 持久性（Durability）\n持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n\n6.3.事物的使用步骤\n\n事物又分两种：隐式事物和显式事物\n隐式事物：事物没有明显的开启和结束的标记\n列如insert，update，delete\n\n显式事物：事物具有明显的开启和结束的标记\n前提：必须设置自动提交功能为禁用\n\n查看当前自动提交功能开关\nshow variables like 'autocommit'\n\n关闭自动提交功能，并不是永久的，只是当前回话被关闭\nset autocommit=0;\n\n\n开启事物的语法：\n#步骤1：开启事物\nset autocommit=0;\nstart transaction;#开启事物，可选的\n#步骤2：编写事物中的sql语句（select insert update delete）\n语句1;\n语句2;\n.......\n#步骤3：结束事物\ncommit;#提交事物\nrollback;回滚事物\n\n\n实战操作：\n初始化\ncreate table account(\n\tid bigint(20) primary key auto_increment,\n\tacc_name varchar(25),\n\tmoney double\n)\nINSERT INTO account (id, acc_name, money) VALUES (1, '欧阳荣', 1500);\nINSERT INTO account (id, acc_name, money) VALUES (2, '罗总', 500);\n\n\n\n\n\n转账成功提交：执行后可以看到数据库数据已经改变了\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\ncommit;\n\n\n转账失败回滚：执行后会发现数据并没有改变\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\nrollback;\n\n\n\n6.4.数据库的隔离级别\n\n6.4.1.并发问题\n\n对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n\n脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. \n之后, 若 T2 回滚, T1读取的内容就是临时且无效的.\n\n不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. \n之后, T1再次读取同一个字段, 值就不同了.\n\n幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插\n入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n\n\n\n6.4.2.四种事务隔离级别\n\n\n\nOracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。\n\nMysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。\n\n6.5.回滚点使用（savepotion）\n\nset autocommit=0;#设置不自动提交\nstart transaction;#开启事物\ndelete form account where id=1;\nsavepoint a;#保存点\ndelete from account where id=2;\nrollback to a;#回滚到保存点\n这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。\n\n\n7.视图\n7.1.什么是视图\n\n含义：虚拟表，和普通表一样使用\nMySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。\n\n\n应用场景：\n1.多个地方用到同样的查询结果\n2.该查询结果使用的sql语句较复杂\n\n\n7.2.视图的创建\n\n语法：\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\nOR REPLACE：表示替换已有视图\n\nALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表\n\n[WITH [CASCADED | LOCAL] CHECK OPTION]：\n表示视图在更新时保证在视图的权限范围之内\ncascade是默认值，表示更新视图的时候，要满足视图和表的相关条件\nlocal表示更新视图的时候，要满足该视图定义的一个条件即可\n推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 \n\n\n实际操作：\n\n1.查询邮箱中包含a字符的员工名，部门名，工种信息\n-- 创建视图\ncreate view view_test1\nAS\nSELECT\n\tCONCAT(e.first_name, e.last_name) 员工名,\n\tdept.department_name 部门名,\n\tj.job_title 工种信息\nFROM\n\temployees e\nLEFT JOIN departments dept ON dept.department_id = e.department_id\nLEFT JOIN jobs j ON j.job_id = e.job_id\nwhere email LIKE '%a%'\n-- 查询视图\nselect * from view_test1\n\n\n2.查询各部门的平均工资级别\ncreate view view_test2\nas \nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name\n\nSELECT\n\tvt.dept_name,\n\tjb.grade_level\nFROM\n\tview_test2 vt\nLEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal\nAND jb.highest_sal\n\n\n3.查询平均工资最低的部门\ncreate view view_test3\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n4.查询平均工资最低的部门名和工资\ncreate view view_test4\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n视图的好处：\n重用sql语句\n简化复杂的sql操作，不必知道它的查询细节\n保护数据，提高安全性\n\n\n7.3.视图的修改\n\n方式一：如果存在，则覆盖\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\n\n方式二：指定修改视图\nalter\n[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n    [DEFINER = { user | CURRENT_USER }]\n    [SQL SECURITY { DEFINER | INVOKER }]\nview 视图名\nas\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION];\n\n\n方式一实际操作：\ncreate or replace view view_test4\nas \nselect * from employees where employee_id > 105\n\n\n方式二实际操作：\nalter view view_test4\nas\nselect * from employees where employee_id > 120\n\n\n\n7.4.视图的删除\n\n语法：\ndrop view 视图名,视图名,视图名........\n\n实际操作：\ndrop view view_test4, view_test3\n\n\n7.5.查看视图\n方式1：desc 视图名\n\n方式2：show create view 视图名\n\n\n方式1实际操作：\ndesc view_test2\n\n可以看到实际上能看到的是当前视图可以查询出的字段信息\n\n\n方式2实际操作：\nshow create view view_test2\n\n可以看到的是当前拿到的是创建视图的逻辑sql。\n\n\n7.6.视图VS表\n\n创建语法的关键字\t是否实际占用物理空间\t使用\n视图\tcreate view\t\t\t只是保存了逻辑sql\t\t增删改查，一般不能增删改查\n\n表\t\tcreate table\t\t\t保存了数据\t\t\t\t增删改查\n\n\n\n8.变量\n\n8.1.系统变量\n\n说明：变量由系统提供的，不是银行定义，属于服务器层面\n系统变量又可以细分为全局变量和局部变量\n\n使用的语法：\n1.查看所有的系统变量\nshow global|[session] variables\n\n2.查看满足条件的部分系统变量\nshow global | [session] variables like '%char%';\n\n3.查看指定的某个系统变量的值\nselect @@global | [session] .系统变量名\n\n4.为某个系统变量赋值\n方式一：\nset global | [session] 系统变量名 = 值;\n\n方式二：\nSet @@global | [session] .系统变量名 = 值;\n\n注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别\n\n\n8.1.1.全局变量实际操作\n\n作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）\n\n（1）查看所有的全局变量\nshow global variables;\n\n（2）查看部分的全局变量\nshow global variables like '%char%';\n\n（3）查看指定的全局变量的值\nselect @@global.autocommit;\n\n\n（4）为某个指定的全局变量赋值\nset @@global.autocommit = 0;\n\n8.1.2.局部变量实际操作\n\n作用域：仅仅针对于当前会话（连接）有效\n\n（1）查看所有的会话变量\nshow variables\nshow session variables\n\n（2）查看部分的会话变量\nshow variables like '%char%'\nshow session variables like '%char%'\n\n（3）指定查看某个会话变量\nselect @@character_set_client\nselect @@session.character_set_client\n\n（4）为某个会话变量赋值\nset autocommit=0\nset @@session.autocommit=1\n\n8.2.自定义变量\n\n说明：变量是用户自定义的，不是由系统自动生成的。\n自定义变量又可以细分成用户变量（当前会话有效），局部变量\n使用步骤：\n声明\n赋值\n使用（查看，比较，运算等）\n\n8.2.1.用户变量\n\n作用域：针对于电器干会话（连接）有效，同于会话变量的作用域\n应用在任何地方，也就是begin end里面或begin end外面\n\n\n\n使用语法：\n\n（1）声明并初始化：\nset @用户变量名=值 或\nset @用户变量名:=值 或\nselect @用户变量名:=值\n\n（2）赋值（更新用户变量的值）\n方式一：通过set和select\nset @变量名=值 或\nset @变量名:=值 或\nselect @变量名:=值\n\n方式二：通过select into\nselect 字段 INTO @变量名\nfrom 表\n\n（3）使用（查看用户变量的值）\nselect @用户变量名\n\n\n实际操作：\n\n声明并且初始化：\n# 声明并且初始化\nset @name='欧阳荣';\nset @name:=10;\nselect @name:='罗总';\n\n赋值：\n#赋值\nset @count = 10;\nset @count := 15;\nselect @count := 20;\nselect count(*) into @count from account;\n\n使用：\nselect @count;\n\n\n\n\n\n8.2.2.局部变量\n\n作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句\n\n（1）声明\ndeclare 变量名 类型;\ndeclare 变量名 类型 default 值;\n\n（2）赋值\n方式一：通过set和select\nset 局部变量名=值 或\nset 局部变量名:=值 或\nselect @局部变量名:=值\n\n方式二：通过select into\nselect 字段 INTO 局部变量名\nfrom 表\n\n（3）使用\nselect 局部变量名\n\n8.2.3.用户变量 VS 局部变量\n\n作用域\t\t定义和使用的位置\t\t\t\t语法\n用户变量\t当前会话\t会话中的任何地方\t\t\t\t必须加@符，不限定类型\n局部变量\tbegin end中\t只能在begin end中，且为第一句\t不用加@符，需要限定类型\n\n9.存储过程和函数\n存储过程和函数：类似于java中的方法\n好处：\n1、提高代码的重用性\n2、简化操作\n\n\n9.1.存储过程\n\n\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n\n9.1.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate procedure 存储过程名(参数列表)\nbegin\n存储过程体（一组合法的SQL语句）\nend\n\n注意：\n1.参数列表包含三部分\n参数模式\t参数名\t参数类型\nin\t\t\tstudent\tvarchar(20)\n\n参数模式：\nin：\t该参数可以作为输入，也就是该参数需要调用方法传入值\t\nout：\t该参数可以作为输出，也就是该参数可以作为返回值\ninout：\t该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值\n\n2.如果存储过程体仅仅只有一句话，begin end可以省略。\n存储过程的每条SQL语句的结尾要求必须加上分号。\n存储过程的结尾可以使用delimiter重新设置\n语法：\nDELIMITER 结束标记\nDELIMITER $\n\n\n调用语法：\nCALL 存储过程名（实参列表）\n\n\n查看语法：\nshow create procedure 存储过程名;\n\n\n删除语法：\ndrop procedure 存储过程名;\n\n9.1.2.存储过程实战\n\n（1）空参的存储过程：\n# 创建存储过程\ncreate procedure myp1()\nbegin\n\tinsert into admin(name, money) values('z1', 11), ('z2', 22), ('z3', 33), ('z4', 44), ('z5', 55);\nend;\n\n#调用存储过程\nCALL myp1();\n\n\n带in模式参数的存储过程：\n根据女神名获取男神信息\n# 创建存储过程\ncreate procedure myp1(in beauty_name varchar(25))\nbegin\n\tselect bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n# 调用\ncall myp1('赵敏')\n\n根据用户名和密码判断是否能登录成功\n-- 创建存储过程\ncreate procedure myp2(in username varchar(25), in password varchar(25))\nbegin\n\tdeclare result int default '0';\n\tselect count(*) INTO result from admin a where a.username = username and a.`password` = password;\n\tselect if(result > 0, '成功', '失败');\nend;\n-- 调用\ncall myp2('john', '8888')\n\n\n（2）带out模式的存储过程：\n\n根据女神名，返回对应的男神名\n#创建\ncreate procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))\nbegin\n\tselect bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n-- 调用\nset @boy_name='';\ncall myp3('赵敏', @boy_name);\nselect @boy_name;\n\n根据女神名，返回对应的男神名和男神魅力值\n创建\ncreate procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)\nbegin\n\tselect bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n\n-- 调用\nset @boy_name='';\nset @user_cp=0;\ncall myp4('赵敏', @boy_name, @user_cp);\nselect @boy_name, @user_cp;\n\n\n（3）带inout模式参数的存储过程\n\n传入a和b两个值，最终a和b都翻倍并返回\n#创建\ncreate procedure myp5(inout x int, inout y int)\nbegin\n\tset x = x*2;\n\tset y = y*2;\nend;\n#调用\nset @x = 10;\nset @y = 20;\ncall myp5(@x, @y);\nselect @x, @y;\n\n\n\n\n\n9.2.函数\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n存储过程与函数的区别：\n存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新\n函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果\n\n\n9.2.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate function 函数名(参数列表) returns 返回类型\nbegin\n函数体\nend\n\n注意：\n1.参数列表包含两部分：参数名 参数类型\n2.函数体：肯定会有return语句，如果没有会报错。\n如果return语句没有放在函数体的最后也不报错，但不建议。\n3.函数体重仅有一句话，则可以省略begin end\n4.使用delimiter语句设置结束标记\n\n\n调用语法：\nselect 函数名（参数列表）\n\n\n查看语法：\nshow create function 函数名\n\n\n删除语法：\ndorp function 函数名\n\n\n\n9.2.2.函数实战\n\n（1）无参有返回\n\n返回公司的员工个数：\n#创建\ncreate function myf1() returns int\nbegin\n\tdeclare count int default 0;\n\tselect COUNT(*) into count from employees;\n\treturn count;\nend;\n#调用\nselect myf1();\n\n\n（2）有参返回\n\n根据员工名返回工资：\n#创建\ncreate function myf2(username varchar(25)) returns double\nbegin\n\tdeclare money double default 0;\n\tselect salary into money from employees where last_name = username;\n\treturn money;\nend;\n#调用\nselect myf2('Kochhar');\n\n\n根据部门名，发挥该部门的平均工资\n#创建\ncreate function myf3(dept_name varchar(25)) returns double\nbegin\n\tdeclare ave_salary double default 0;\n\tselect avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id\n\twhere dept.department_name = dept_name group by dept.department_id;\n\treturn ave_salary;\nend;\n#调用\nselect myf3('Adm');\n\n实现传入两个float，返回两者之和：\n\n#创建\ncreate function myf1(x float, y float) returns float\nbegin\n\tdeclare sum float default 0;\n\tset sum = x + y;\n\treturn sum;\nend;\n#调用\nselect myf1(1, 5.1);\n\n\n（3）查看函数\nshow create function myf3;\n\n\n\n（4）删除函数\ndrop function myf3\n\n\n10.流程控制结构\n顺序结构：程序从上往下依次执行\n分支结构：程序从两条或多条路径中选择一条去执行\n循环结构：程序在满足一定条件的基础上重复执行一段代码\n\n\n10.1.分支结构\n\n（1）if函数\n功能：实现简单的双分支\n语法：\nIf(表达式1, 表达式2, 表达式3)\n执行顺序：\n如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值\n应用：任何地方\n实战操作：\nselect if(1 > 2, 1, 2)\n当前sql执行后会返回2\n\n\n（2）case结构\n\n在begin end 外面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 返回的值1\nwhen 要判断的值 then 返回的值2\n....\nelse 返回的值n\nend\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 返回的值1\nwhen 要判断的条件2 then 返回的值2\n....\nelse 返回的值n\nend\n\n\n在begin end里面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 要执行的语句1\nwhen 要判断的值 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 要执行的语句1\nwhen 要判断的条件2 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate procedure show_grade(in grade int)\nbegin\n\tdeclare result varchar(2);\n\tCASE \n\tWHEN grade>=90 and grade<=100 THEN set result = 'A';\n\tWHEN grade>=80 THEN set result = 'B';\n\tWHEN grade>=60 THEN set result = 'C';\n\tELSE set result = 'D';\n\tEND CASE;\n\tselect result;\nend;\n\nCALL show_grade(99);\n\n\n#根据传递的数据库类型，显示对应的数据库名\ncreate procedure show_database_type(in val int)\nbegin\n\tdeclare result varchar(20);\n\tCASE val\n\tWHEN 1 THEN set result = 'mysql';\n\tWHEN 2 THEN set result = 'oracle';\n\tWHEN 3 THEN set result = 'sql server';\n\tELSE set result = '不认识的类型，滚啊。。。';\n\tEND CASE;\n\tselect result;\nend;\n\ncall show_database_type(1);\n\n\n（3）if结构\n功能：实现多重分类\n语法：\nif 条件1 then 语法1;\nesleif 条件2 then 语法2;\n...\n[else 语句n;]\nend if;\n\n应用场景：应用在begin end中\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate function show_grade(grade int) returns char(1)\nbegin\n\tdeclare result char(1);\n\tif grade>=90 and grade<=100 THEN set result = 'A';\n\telseif grade>=80 THEN set result = 'B';\n\telseif grade>=60 THEN set result = 'C';\n\telse set result = 'D';\n\tend if;\n\treturn result;\nend;\n\nselect show_grade(55);\n\n\n#批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止\ncreate procedure pro_while_insert2(in count int)\nbegin\n\tdeclare i int default 1;\n\ta:while i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tif i>=20 then leave a;\n\t\tend if;\n\t\tset i=i+1;\n\tend while a;\nend;\n\ncall pro_while_insert2(30);\n\n\n\n10.2.循环结构\n\n循环分类：\nwhile、 loop、repeat\n\n循环控制：\niterate类似于continue，结束本次循环，继续下一次循环\nleave类似于break，结束当前所在循环。\n\n\n三种循环语法：\n\n（1）while\n[标签:] while 循环条件 do\n循环体\nend while [标签]\n\n（2）loop\n[标签:] loop\n循环体\nend loop [标签]\n\n（3）repeat\n[标签:] repeat\n循环体\nuntil 结束循环的条件\nend repeat [标签]\n\n\n循环实战操作：\n\n#批量插入，根据次数插入到amdin表中多条数据\ncreate procedure pro_while_insert(in count int)\nbegin\n\tdeclare i int default 1;\n\twhile i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tset i=i+1;\n\tend while;\nend;\n\ncall pro_while_insert(10);\n\n\n\nwhile VS repeat VS loop\nwhile：先判断后执行\nrepeat：先执行后判断\nloop：没有条件的死循环\n\n# 博客园所学\n\n## 索引\n\n索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.  \n单列索引:一个索引只包含一个列,一个表可以有多个单列索引.   \n组合索引:一个组合索引包含两个或两个以上的列。\n\n### 索引的创建\n\n1）单列索引\n\n普通索引：\n第一种方式 :\nCREATE INDEX 索引名ON 表名(`字段名`(length))\n\n第二种方式: \nALTER TABLE award ADD INDEX account_Index(`account`)\n\n唯一索引：\nCREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));\nALTER TABLE TableName ADD UNIQUE (column_list)\n\n主键索引：不允许有空值\n\n2）组合索引：\n\n语法：\nCREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...);\n\n\n### 索引的删除\n语法：\nDORP INDEX IndexName ON `TableName`\n\n## 触发器\n\n触发器：监视某种情况，并触发某种操作。\n\n### 创建语法\n\n触发器创建语法四要素：1.监视地点(table)\n　　　　　　　　　　　2.监视事件(insert/update/delete)\n　　　　　　　　　　 3.触发时间(after/before)\n　　　　　　　　　　　4.触发事件(insert/update/delete)\n\n语法：\ncreate trigger triggerName after/before insert/update/delete\non 表名 for each row #这句话是固定的\n begin\n     #需要执行的sql语句\n end\n注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发\n注意2:insert/update/delete:只能选一个\n\n创建一个视图：\ncreate trigger tag1 after insert on order_table\nfor each row\nbegin\n\tupdate goods set num=num-3 where id=1;\nend;\n\n\n我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。\n对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。\n所以现在我们可以这样来改我们的触发器:\ncreate trigger tg1 after insert on order_table\nfor each row\nBEGIN\n\tupdate goods set num = num-new.much where id=new.gid; \nEND;\n\n当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？\n 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。\ncreate trigger tg2 after delete on order_table\nfor each ROW\nBEGIN\n\tupdate goods set num = num+old.much where id=old.gid;\nEND;\n\n### 删除触发器\n语法：drop trigger 触发器名称;\n使用：drop trigger dg1;","slug":"MySQL/MySQL-基础","published":1,"updated":"2021-06-25T13:37:06.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqcfpmkh000yhowm9vc8cx2l","content":"<p>Mysql数据库</p>\n<h1 id=\"MySql基础\"><a href=\"#MySql基础\" class=\"headerlink\" title=\"MySql基础\"></a>MySql基础</h1><h2 id=\"数据库的好处\"><a href=\"#数据库的好处\" class=\"headerlink\" title=\"数据库的好处\"></a>数据库的好处</h2><p>可以持久化到本地<br>结构化查询</p>\n<hr>\n<h2 id=\"主流的数据库介绍（了解）\"><a href=\"#主流的数据库介绍（了解）\" class=\"headerlink\" title=\"主流的数据库介绍（了解）\"></a>主流的数据库介绍（了解）</h2><p>Sql server 数据库<br>是微软，.net程序员最爱，中型和大型项目，性能高</p>\n<p>Oracle数据库<br>是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。</p>\n<p>Mysql数据库<br>是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。</p>\n<p>db2数据库<br>是ibm公司，处理海量数据，大型项目。很强悍。</p>\n<p>Informix数据库<br>是ibm公司。在银行系统，安全性高</p>\n<p>Sybase数据库</p>\n<hr>\n<h2 id=\"mysql的优点\"><a href=\"#mysql的优点\" class=\"headerlink\" title=\"mysql的优点\"></a>mysql的优点</h2><p>开源，免费成本低<br>性能高，移植性也好<br>体积小，便于安装</p>\n<h2 id=\"mysql数据库的安装和配置\"><a href=\"#mysql数据库的安装和配置\" class=\"headerlink\" title=\"mysql数据库的安装和配置\"></a>mysql数据库的安装和配置</h2><p>看MySQL-5.7.17安装与配置.docx</p>\n<h2 id=\"mysql的基本使用\"><a href=\"#mysql的基本使用\" class=\"headerlink\" title=\"mysql的基本使用\"></a>mysql的基本使用</h2><p>（1）连接到mysql<br>Cmd&gt;mysql -h 主机名 -u 用户名 -p 密码 回车<br>举例：</p>\n<p>说明：<br>如果你没有写-h localhost 默认是连接本地</p>\n<p>如果你需要远程登录到另一个mysql,则需要修改配置。<br>一般情况下部让远程登录。</p>\n<p>（2）sql服务的退出<br>exit或ctrl+c</p>\n<p>（3）关闭和启动mysql服务<br>界面操作：</p>\n<p>命令模式：<br>启动：net stop mysql<br>停止：net start mysql<br>举例：</p>\n<p>说明：这里mysql不是固定的，是安装时取的服务名称。</p>\n<h2 id=\"mysql数据库三层架构介绍\"><a href=\"#mysql数据库三层架构介绍\" class=\"headerlink\" title=\"mysql数据库三层架构介绍\"></a>mysql数据库三层架构介绍</h2><p>专业术语</p>\n<p>Db：<br>数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。</p>\n<p>Dbms：<br>数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。</p>\n<p>Sql:<br>结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。</p>\n<p>数据库服务器，数据库和表的关系如图所示：</p>\n<p>示意图：</p>\n<h2 id=\"mysql常见命令\"><a href=\"#mysql常见命令\" class=\"headerlink\" title=\"mysql常见命令\"></a>mysql常见命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看当前所有的数据库</span><br><span class=\"line\">show databases;</span><br><span class=\"line\"></span><br><span class=\"line\">2.打开指定的库</span><br><span class=\"line\">use 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">3.查看所在的数据库名</span><br><span class=\"line\">select database();</span><br><span class=\"line\"></span><br><span class=\"line\">4.查看当前库的所有表</span><br><span class=\"line\">show tables;</span><br><span class=\"line\"></span><br><span class=\"line\">5.查看其它库的所有表</span><br><span class=\"line\">show tables from 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">6.创建表</span><br><span class=\"line\">create table user(id int, name varchar(20));</span><br><span class=\"line\"></span><br><span class=\"line\">7.查看表结构</span><br><span class=\"line\">desc 表名;\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">8.查看服务器的版本</span><br><span class=\"line\">方式一：登录到mysql服务端</span><br><span class=\"line\">Select version();</span><br><span class=\"line\">方式二：没有登录到mysql服务端</span><br><span class=\"line\">Mysql --version或mysql --V</span><br><span class=\"line\"></span><br><span class=\"line\">9.查看当前时区</span><br><span class=\"line\">SHOW VARIABLES LIKE &#x27;time_zone&#x27;</span><br><span class=\"line\">SET time_zone=&#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mysql的语法规范\"><a href=\"#Mysql的语法规范\" class=\"headerlink\" title=\"Mysql的语法规范\"></a>Mysql的语法规范</h2><p>1.不区分大小写，单建议关键字大写，表名，列名小写。<br>2.每条语句最好用分号结尾。<br>3.每条命令根据需要，可以进行缩进或换行<br>4.注释<br>单行注释：两种<br>第一种：#注释文字<br>第二种：– 注释文字<br>多行注释：/* 注释文字 */</p>\n<h1 id=\"常用数据类型\"><a href=\"#常用数据类型\" class=\"headerlink\" title=\"常用数据类型\"></a>常用数据类型</h1><h2 id=\"数值型\"><a href=\"#数值型\" class=\"headerlink\" title=\"数值型\"></a>数值型</h2><p>2.1.1.整型</p>\n<p>特点：<br>（1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>（2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值<br>（4）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！</p>\n<p>2.1.2.小数</p>\n<p>浮点型：<br>Float(m, d)，double(m, d)<br>4            8</p>\n<p>定点型：<br>Dec(m, d)，decimal(m, d)<br>M+2        m+2</p>\n<p>特点：<br>（1）<br>M：整数部位+小数部位（总长度）<br>D：小数部位<br>如果超出范围插入临界值</p>\n<p>（2）<br>M和D都可以省略<br>如果是decimal，则m默认为10，d默认为0<br>如果是double和float，则会随着插入的数值的精度来决定精度</p>\n<p>（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用</p>\n<p>2.2.字符型</p>\n<p>较短的文本：<br>Char<br>Varchar</p>\n<p>特点：</p>\n<p>写法        m的意思            特点            空间的耗费        效率<br>Char    char(m)        最大的字符数    固定长度        比较耗费        高<br>Varchar    varchar(m)    最大的字符数    可变长度的字符    比较节省        低</p>\n<p>较长的文本：<br>Text<br>Blob（较大的二进制）</p>\n<p>Enum类型：<br>说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。<br>如果列表成员为1<del>255，则需要1个字节存储<br>如果列表成员为255</del>65535，则需要2个字节存储<br>最多需要65535个成员</p>\n<p>Set类型：<br>说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区<br>别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>\n<p>2.3.日期型</p>\n<p>总结：<br>Date：只保存日期，并没有保存到时分秒<br>Time：只保存时间（时分秒）<br>Year：只保存年</p>\n<p>Datetime：保存日期+时间<br>Timestamp：保存日期+时间</p>\n<p>Datetime VS Timestamp</p>\n<p>字节    范围        时区等的影响<br>Datetime     8        1000-9999        不受<br>Timestamp    4        1970-2038        受</p>\n<h1 id=\"DQL语言（select）\"><a href=\"#DQL语言（select）\" class=\"headerlink\" title=\"DQL语言（select）\"></a>DQL语言（select）</h1><h2 id=\"基础查询\"><a href=\"#基础查询\" class=\"headerlink\" title=\"基础查询\"></a>基础查询</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>select 查询列表 from 表名</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>查询列表开源是字段，常量表达式，函数，也可以有多个。<br>查询结构是一个虚拟表。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>1.查询单个字段<br>Select 字段名 from 表名</p>\n<p>2.查询多个字段<br>Select 字段名,字段名 from 表名</p>\n<p>3.查询所有的字段<br>Select * from 表名</p>\n<p>4.查询常量<br>Select 常量值<br>注意：字符型和日期型常量值必须用单引号用起来，数值类不需要</p>\n<p>5.查询函数<br>Select 函数名（实例参数）;</p>\n<p>6.查询表达式<br>Select 100*10;</p>\n<p>7.取别名<br>两种方式<br>As<br>Select last_name as 姓名 from 表名  </p>\n<p>空格<br>Select last_name 姓名 from 表名</p>\n<p>8.去重<br>Select distinct 字段名 from 表名</p>\n<p>9.+<br>作用：加法运算<br>Select 数值+数值;直接运算<br>Select 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，    再做运算。</p>\n<p>10.补充Concat函数<br>功能：拼接字符<br>Select concat(字符1,字符2,字符3,….)</p>\n<p>11.补充ifnull函数<br>Select ifnull(name, 0) from user</p>\n<p>12.补充isnull函数<br>Select isnull(name) from user<br>功能：拍的某个字段是否为null，如果是返回1，如果不是返回0</p>\n<h2 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select 查询列表<br>From 表名<br>Where 筛选条件</p>\n<h3 id=\"筛选条件的分类\"><a href=\"#筛选条件的分类\" class=\"headerlink\" title=\"筛选条件的分类\"></a>筛选条件的分类</h3><p>（1）简单条件运算符  </p>\n<p><code>&gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;</code></p>\n<p>Select * from user where age&gt;15;</p>\n<p>Select * from user where age&lt;15;</p>\n<p>Select * from user where age&lt;&gt;15;</p>\n<p>&lt;=&gt;:安全等于，可以判断普通数值，也可以判断是否为null<br>Select * from user where age&lt;=&gt; null;</p>\n<p>（2）逻辑运算符</p>\n<p><code>and or not</code></p>\n<p>And:<br>SELECT last_name FROM employees WHERE salary&gt;=10000 AND salary&lt;=20000;</p>\n<p>Or:<br>SELECT * FROM employees WHERE department_id&lt;90 OR department_id&gt;110 OR salary&gt;15000;</p>\n<p>Not:<br>SELECT * FROM employees WHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;</p>\n<p>（3）模糊查询</p>\n<p><code>Like, between and, in, is null, is not null </code></p>\n<p>like：<br>Select * from user where name like’%a%’;<br>Select * from user where name like’_a%’;</p>\n<p>between and:<br>作用：在哪两个数之间<br>Select * from user where age between 10 and 20;</p>\n<p>in:<br>Select * from user where id in(1,2,3);</p>\n<p>is null:<br>作用：判断是否为null<br>Select * from user where age is null;</p>\n<p>is not null:<br>作用：判断是否不为空<br>Select * from user where age is not null;</p>\n<h2 id=\"排序查询\"><a href=\"#排序查询\" class=\"headerlink\" title=\"排序查询\"></a>排序查询</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select * from 表名<br>[Where 筛选条件]<br>Order by 排序列表[asc desc]</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>（1）asc代表升序，desc代表降序，如果不写是升序。<br>（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名<br>（3）order by子句一般是放查询语句的最后面，limit子句除外</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>#案例：查询员工信息，要求工资冲高到底排序  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span>, salary<span class=\"operator\">*</span><span class=\"number\">12</span><span class=\"operator\">*</span>(<span class=\"number\">1</span><span class=\"operator\">+</span>IFNULL(commission_pct, <span class=\"number\">0</span>)) <span class=\"keyword\">AS</span> 年薪 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 年薪 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> LENGTH(email) <span class=\"keyword\">DESC</span>, department_id <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><p>功能：类似java中的方法<br>好处：提高重用性和隐藏实现细节<br>调用：select 函数名(参数列表)  </p>\n<h3 id=\"字符函数\"><a href=\"#字符函数\" class=\"headerlink\" title=\"字符函数\"></a>字符函数</h3><p>LENGTH：<br>作用：获取参数的字节个数<br>SELECT LENGTH(‘oyr’);<br>SELECT LENGTH(‘欧阳荣’);</p>\n<p>CONCAT：<br>作用：拼接字符串<br>SELECT CONCAT(‘abc’, ‘jkl’);<br>SELECT CONCAT(first_name, last_name) out_put FROM employees;</p>\n<p>UPPER：<br>作用：字符串变大写<br>SELECT UPPER(“asc”);</p>\n<p>Lower：<br>作用：字符串变小写<br>SELECT LOWER(“ASC”);</p>\n<p>Substr:<br>作用：截取字符串，两种使用方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#第一种：截取从指定索引处后面所有字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣真的帅哦&quot;, <span class=\"number\">4</span>);  </span><br><span class=\"line\">结果：真的帅哦</span><br><span class=\"line\"></span><br><span class=\"line\">#第二种：截取从指定索引处指定字符串的字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣不是一般帅哦&quot;, <span class=\"number\">1</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\"># 案例<span class=\"number\">1</span>：姓名首字母大写，其他字符小写然后用_拼接，显示出来</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"built_in\">UPPER</span>(SUBSTR(last_name, <span class=\"number\">1</span>, <span class=\"number\">1</span>)), <span class=\"string\">&#x27;_&#x27;</span>, <span class=\"built_in\">LOWER</span>(SUBSTR(last_name, <span class=\"number\">2</span>))) <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<p>Trim:<br>作用：去除两边空格或去除两边指定字符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#去除两边空格：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;   欧阳荣 &#x27;</span>));</span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\">#去除两边指定字符：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;a&#x27;</span> <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;aaaaaaaa欧阳aaa荣aaaaaa&#x27;</span>);</span><br><span class=\"line\">结果：欧阳aaa荣</span><br></pre></td></tr></table></figure>\n\n<p>Lpad：<br>作用：lpad 用指定的字符实现左填充指定长度<br>SELECT LPAD(‘欧阳荣’, 10, ‘a’) out_put;</p>\n<p>Rpad：<br>作用：用指定的字符实现右填充指定长度<br>SELECT LPAD(‘欧阳荣’, 12, ‘ab’) out_put;</p>\n<p>Replace：<br>作用：替换字符串<br>SELECT REPLACE(‘赵吊彬是zz赵吊彬赵吊彬赵吊彬’, ‘赵吊彬’, ‘李执志’);</p>\n<p>Instr:<br>作用：获取子串第一次出现的索引<br>SELECT INSTR(‘欧阳荣多对多’, ‘欧阳’);<br>结果为：1</p>\n<h3 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h3><p>Round:<br>作用：四舍五入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种使用：</span><br><span class=\"line\">SELECT ROUND(1.65);</span><br><span class=\"line\">结果：2</span><br><span class=\"line\"></span><br><span class=\"line\">第二种使用：</span><br><span class=\"line\">SELECT ROUND(1.657, 2);</span><br><span class=\"line\">结果：1.66</span><br></pre></td></tr></table></figure>\n\n<p>Ceil：<br>作用：向上取整<br>SELECT CEIL(1.52);<br>结果：2</p>\n<p>Floor：<br>作用：向下取整<br>SELECT FLOOR(9.99);<br>结果：9</p>\n<p>Truncate：<br>作用：截断<br>SELECT TRUNCATE(10.19, 1);<br>结果：10.1</p>\n<p>Mod：<br>作用：取余<br>SELECT MOD(10, 3);<br>结果：1</p>\n<p>Rand：<br>作用：获取随机数，返回0-1之间的小数<br>SELECT RAND();</p>\n<h3 id=\"日期函数\"><a href=\"#日期函数\" class=\"headerlink\" title=\"日期函数\"></a>日期函数</h3><p>NOW：<br>作用：返回当前系统日期+时间<br>SELECT NOW();</p>\n<p>Curdate：<br>作用：返回当前系统日期，不包含时间<br>SELECT CURDATE();</p>\n<p>Curtime：<br>作用：返回当前时间，不包含日期<br>SELECT CURTIME();</p>\n<p>Year：<br>作用：获取年<br>Select year(now());<br>SELECT YEAR(‘1999-1-1’) 年;</p>\n<p>Month:<br>作用：获取月<br>SELECT MONTH(NOW()) 月;</p>\n<p>Day:<br>作用：获取日<br>Select DAY(now()) 日;</p>\n<p>日期格式符：</p>\n<p>Str_to_date:<br>作用：将日期格式的字符转换成指定格式的日期<br>SELECT STR_TO_DATE(‘1999-6-2’, ‘%Y-%c-%d’) out_put;<br>SELECT * FROM employees WHERE hiredate=STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’);</p>\n<p>Date_format：<br>作用：将日期转换成字符<br>SELECT DATE_FORMAT(NOW(), ‘%y年%m月%d日’) AS out_put;</p>\n<p>案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）<br>SELECT last_name, DATE_FORMAT(hiredate, ‘%M月/%d日 %y年’)<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p>\n<p>Datediff：<br>作用：返回两个日期相差的天数<br>SELECT DATEDIFF(NOW(), ‘1999-06-24’);</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><p>VERSION：<br>作用：查看当前mysql版本号<br>SELECT VERSION();</p>\n<p>DATABASE：<br>作用：查看当前打开的数据库<br>Select DATABASE();</p>\n<p>USER：<br>作用：查看当前登录的用户<br>Select USER();</p>\n<h3 id=\"流程控制函数\"><a href=\"#流程控制函数\" class=\"headerlink\" title=\"流程控制函数\"></a>流程控制函数</h3><p>If：<br>作用：判断真假<br>SELECT IF(10&lt;5, ‘小’, ‘大’);</p>\n<p>Case:<br>作用：判断<br>语法：<br>case 要带的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量1 then 要显示的值1或语句1;<br>…..<br>else 要显示的值n或语句n<br>End</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：查询员工的工资，要求</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">30</span>,显示的工资为<span class=\"number\">1.1</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">40</span>，显示的工资为<span class=\"number\">1.2</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">50</span>，显示的工资为<span class=\"number\">1.3</span>倍</span><br><span class=\"line\">其他部门，显示的工资为原工资</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary 原工资, </span><br><span class=\"line\"><span class=\"keyword\">CASE</span> department_id</span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">30</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">40</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.2</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">50</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.3</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> salary</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 新工资</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br><span class=\"line\"></span><br><span class=\"line\">案例：查询员工的工资的情况</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">20000</span>，显示A级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">15000</span>，显示B级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">10000</span>,显示C级别</span><br><span class=\"line\">否则，显示D级别</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,salary,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">20000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">15000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">10000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;D&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 级别</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><h3 id=\"分组函数\"><a href=\"#分组函数\" class=\"headerlink\" title=\"分组函数\"></a>分组函数</h3><p>sum:<br>作用：求和<br>SELECT SUM(salary) FROM employees;</p>\n<p>max:<br>作用：最大值<br>Select max(salary) from employees;</p>\n<p>min：<br>作用：最小值<br>SELECT MIN(salary) FROM employees;</p>\n<p>avg：<br>作用：平均数<br>SELECT AVG(salary) FROM employees;</p>\n<p>count：<br>作用：计算个数<br>Select count(*) from user;</p>\n<p>注意事项：<br>sum，avg一般用于数值型<br>max，min，count可以处理任何类型<br>以上分组函数都忽略null值</p>\n<h3 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h3><p>语法：<br>select 分组函数，列（要求出现在group by的后面）<br>from 表<br>[where 筛选条件]<br>group by 分组的列表<br>[having 分组后的筛选]<br>[order by 子句]</p>\n<p>注意：<br>查询列表必须特殊，要求是分组函数或group by后出现的字段<br>分组后筛选在group by子句的后面使用 having 关键字<br>分组函数做条件肯定是放在having子句中<br>能用分组前筛选，就优先使用分组前筛选<br>group by 子句支持单个字段分组，多个字段分组（用逗号隔开）</p>\n<p>简单分组：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id,<span class=\"built_in\">AVG</span>(salary) 平均工资 <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id; </span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询每个工种的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询每个位置上的部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> location_id, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> location_id;</span><br></pre></td></tr></table></figure>\n\n<p>添加筛选条件：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id, <span class=\"built_in\">AVG</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%a%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询有奖金的每个领导手下的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MAX</span>(salary)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> commission_pct <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询哪个部门的员工个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> department_id, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\"><span class=\"keyword\">from</span> employees</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> department_id <span class=\"keyword\">having</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">4</span>：查询每个工种有奖金的员工的最高工资<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>的工种编号和最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MAX</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">5</span>：查询领导编号<span class=\"operator\">&gt;</span><span class=\"number\">102</span>的每个领导手下的最低工资<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>的领导编号是哪个</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MIN</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> manager_id<span class=\"operator\">&gt;</span><span class=\"number\">102</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MIN</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">6</span>：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数<span class=\"operator\">&gt;</span><span class=\"number\">5</span>的有哪些</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, LENGTH(last_name), <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 员工个数 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> LENGTH(last_name) <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接查询\"><a href=\"#连接查询\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h2><p>什么是连接查询：<br>又称多表查询，当查询的字段来自多个表时，就会用到连接查询。</p>\n<p>笛卡尔积:<br>笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</p>\n<p>按功能分类：</p>\n<ul>\n<li>内连接：  <ul>\n<li>等值连接  </li>\n<li>非等值连接  </li>\n<li>自连接  </li>\n</ul>\n</li>\n<li>外连接：  <ul>\n<li>左外连接  </li>\n<li>右外连接  </li>\n<li>全外连接（mysql不支持）  </li>\n</ul>\n</li>\n<li>交叉连接：  </li>\n</ul>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select 查询列表<br>From 表1 别名 【连接类型】<br>Join 表2 别名<br>On 连接条件<br>【where 筛选条件】<br>【group by 分组】<br>【having 分组后筛选】<br>【order by 排序列表】</p>\n<h3 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3><p>Sql192语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询女神名和对应男生名</span><br><span class=\"line\">SELECT b.name,bs.boyName </span><br><span class=\"line\">FROM beauty b, boys bs </span><br><span class=\"line\">WHERE b.boyfriend_id = bs.id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询员工名和对应的部门名</span><br><span class=\"line\">SELECT e.last_name, e.department_id, d.department_name </span><br><span class=\"line\">FROM employees e, departments d </span><br><span class=\"line\">WHERE e.department_id=d.department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询有奖金的员工名，部门名</span><br><span class=\"line\">SELECT e.`last_name`, d.`department_id`, e.`commission_pct` </span><br><span class=\"line\">FROM employees e,departments d </span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class=\"line\">SELECT j.job_title, COUNT(*) </span><br><span class=\"line\">FROM employees e, jobs j </span><br><span class=\"line\">WHERE e.`job_id`=j.`job_id` </span><br><span class=\"line\">GROUP BY j.`job_title` ORDER BY COUNT(*) DESC;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）非等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询员工的工资和工资级别</span><br><span class=\"line\">SELECT e.`salary`, j.`grade_level` </span><br><span class=\"line\">FROM employees e, job_grades j</span><br><span class=\"line\">WHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`=&#x27;E&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）自连接</span><br><span class=\"line\">查询员工名和上级的名称</span><br><span class=\"line\">SELECT e1.last_name, e2.`last_name` </span><br><span class=\"line\">FROM employees e1,  employees e2</span><br><span class=\"line\">WHERE e1.`manager_id`=e2.`employee_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">三表连接：查询员工名，部门名和所在的城市</span><br><span class=\"line\">SELECT e.last_name, d.`department_name`, l.`city` </span><br><span class=\"line\">FROM employees e, departments d, locations l</span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;</span><br></pre></td></tr></table></figure>\n\n<p>sql99语法：Inner </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询员工名，部门名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">查询名字中只能包含e的员工名和工种名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, j.`job_title` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> jobs j <span class=\"keyword\">ON</span> e.`job_id`<span class=\"operator\">=</span>j.`job_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`last_name` <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询部门个数<span class=\"operator\">&gt;</span><span class=\"number\">3</span>的城市名和部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> l.`city`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> locations l </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> l.`location_id` <span class=\"operator\">=</span> d.`location_id`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> l.`city` <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询工资级别的个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span>的个数，并按工资级别降序</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> j.`grade_level`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 个数 <span class=\"keyword\">FROM</span> job_grades j</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> e.`salary` <span class=\"keyword\">BETWEEN</span> j.`lowest_sal` <span class=\"keyword\">AND</span> j.`highest_sal`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> j.`grade_level` <span class=\"keyword\">HAVING</span> 个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 个数 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><p>应用场景：用于查询一个表中有，另一个表没有</p>\n<p>1.外连接的查询结构为主表中的所有记录<br>如果从表中有和它匹配的，则显示匹配值<br>如果从表中没有和它匹配的，则显示为null<br>外连接查询结果=内连接结果+主表中有而从表没有的数据</p>\n<p>2.左外连接，left join左边的是主表<br>右外连接，right join右边的是主表  </p>\n<p>3.左外和右外交换两个表的顺序，可以实现同样的效果</p>\n<p>（1）左连接：<br>语法：Left 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b </span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> boys bo <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> departments d</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> d.`department_id`<span class=\"operator\">=</span>e.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n<p>（2）右连接<br>语法：Right 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> boys bo </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> beauty b <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n\n<p>（3）全外（mysql不支持）<br>语法：Full 【outer】</p>\n<h3 id=\"交叉连接\"><a href=\"#交叉连接\" class=\"headerlink\" title=\"交叉连接\"></a>交叉连接</h3><p>语法：Cross</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女神男神表交叉连接</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> b.<span class=\"operator\">*</span>, bo.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b</span><br><span class=\"line\"><span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><p>出现在其他语句的select语句，称为子查询或内出现<br>内部嵌套其他select语句的查询，称为外查询或主查询</p>\n<h3 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h3><p>按子查询出现的位置：<br>1）select 后面<br>2）from 后面<br>3）wehre 或 having后面<br>4）exists后面（相关子查询）  </p>\n<p>按结果集的行列数不同：<br>1）标量子查询（结果集只有一行一列）<br>2）列子查询（结果集只有一列多行）<br>3）行子查询（结果集有多行多列）<br>4）表子查询（结果集一般为多行多列）</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p><code>&gt; &lt; &lt;&gt; = </code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">谁的工资比 Abel 高？</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> last_name<span class=\"operator\">=</span><span class=\"string\">&#x27;Abel&#x27;</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">返回job_id与<span class=\"number\">141</span>号员工相同，salary比<span class=\"number\">143</span>号员工多的员工姓名，job_id和工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,job_id,salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> job_id <span class=\"operator\">=</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> job_id <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">案例<span class=\"number\">3</span>：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, job_id, salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"operator\">=</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">MIN</span>(salary) <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">In</span>（常用）：</span><br><span class=\"line\">作用：可以是子查询中的任一一个</span><br><span class=\"line\">返回location_id是<span class=\"number\">1400</span>或<span class=\"number\">1700</span>的部们中的所有员工姓名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> department_id <span class=\"keyword\">IN</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> department_id <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">WHERE</span> location_id <span class=\"keyword\">IN</span>(<span class=\"number\">1400</span>, <span class=\"number\">1700</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Any</span>（不常用）：</span><br><span class=\"line\">作用：任一一个</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ANY</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">All</span>（不常用）：</span><br><span class=\"line\">作用：所有的</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ALL</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页查询（常用）\"><a href=\"#分页查询（常用）\" class=\"headerlink\" title=\"分页查询（常用）\"></a>分页查询（常用）</h2><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。</p>\n<h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><p>select 参数列表<br>from 表<br>left join 表名 on 连接条件<br>where 筛选条件<br>group by 分组字段 having 分组后筛选<br>order by 排序字段<br>limit 【offset,】 size；</p>\n<p>offset 要显示条目的起始索引（起始索引从0开始）<br>size 要显示的条目个数<br>特点：limit语句放在查询语句的最后</p>\n<h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>查询第二页，一页10条记录<br>Select * from user limit 10, 10;</p>\n<h2 id=\"Union联合查询\"><a href=\"#Union联合查询\" class=\"headerlink\" title=\"Union联合查询\"></a>Union联合查询</h2><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>\n<p>应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>查询语句1<br>union<br>查询语句2<br>union<br>….</p>\n<p>特点：<br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以包含重复项</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--Union all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"DML语言\"><a href=\"#DML语言\" class=\"headerlink\" title=\"DML语言\"></a>DML语言</h1><p>数据库操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p>\n<h2 id=\"插入语句\"><a href=\"#插入语句\" class=\"headerlink\" title=\"插入语句\"></a>插入语句</h2><h3 id=\"方式1\"><a href=\"#方式1\" class=\"headerlink\" title=\"方式1\"></a>方式1</h3><p>语法：<br>Inser into 表名(列名, …) values(值1, …);</p>\n<p>使用：<br>INSERT INTO users VALUES(1, ‘欧阳荣’, ‘男’, 166842.5);<br>INSERT INTO users(id, NAME, sex, gz) VALUES(2, ‘赵云彬’, ‘欧阳荣’, NULL);</p>\n<h3 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h3><p>语法：<br>insert into 表名 set 列名=值,列名=值,….;</p>\n<p>使用：<br>INSERT INTO boys SET id=6, boyName=’侄子’, userCp=147258;</p>\n<h3 id=\"两种开发方式pk\"><a href=\"#两种开发方式pk\" class=\"headerlink\" title=\"两种开发方式pk\"></a>两种开发方式pk</h3><p>insert方式一次可以加多条，第二种方式不行<br>INSERT INTO boys VALUES(7, ‘欧阳荣’, 10000000), (8, ‘欧阳荣’, 10000000);</p>\n<p>insert方式可以用子查询<br>INSERT INTO boys SELECT 10, ‘ii’, 150044;</p>\n<h2 id=\"修改语句\"><a href=\"#修改语句\" class=\"headerlink\" title=\"修改语句\"></a>修改语句</h2><h3 id=\"修改单表的记录（常用）\"><a href=\"#修改单表的记录（常用）\" class=\"headerlink\" title=\"修改单表的记录（常用）\"></a>修改单表的记录（常用）</h3><p>语法：<br>Update 表名 set 列=新值, 列=新值…. where 筛选条件;</p>\n<p>案例：<br>修改beauty表中姓唐的女神电话为1389988889<br>UPDATE beauty SET phone=’1389988889’ WHERE NAME LIKE ‘唐%’;</p>\n<p>修改boys表中id号为2的名称为张飞，魅力值10<br>UPDATE boys SET boyName=’张飞’, userCP=10 WHERE id=2;</p>\n<p>4.2.2.修改多表的记录（补充）<br>192语法：<br>UPDATE 表名 别名,表名 别名<br>SET 列=值,列=值 …<br>WHERE 连接添加 AND 筛选条件</p>\n<p>199语法:<br>UPDATE 表名 别名<br>INNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件<br>SET 列=值，列=值 …<br>WHERE 筛选条件</p>\n<p>案例（以下实现都为199语法）：</p>\n<p>修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.id=b.boyfriend_id<br>SET phone=’114’<br>WHERE bo.boyName=’张无忌’;</p>\n<p>修改没有男朋友的女神的男朋友的编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.id=b.boyfriend_id<br>SET b.boyfriend_id=2<br>WHERE bo.id IS NULL;</p>\n<p>4.3.删除语句</p>\n<p>4.3.1.方式1：delete<br>语法：<br>（1）单表删除（重要）：<br>Delete from 表名 where 筛选条件;</p>\n<p>（2）多表删除（补充）<br>192：<br>Delete 表1别名, 表2别名<br>from 表一 别名, 表二别名<br>Where 连接条件 and 筛选条件</p>\n<p>199：<br>Delete 表1别名, 表2别名<br>From 表一 别名<br>inner|Left|right| join 表2 别名 on 连接条件<br>Where 筛选条件</p>\n<p>案例：</p>\n<p>删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE ‘%9’;</p>\n<p>删除张无忌的女朋友的信息<br>DELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id<br>WHERE bo.<code>boyName</code>=’张无忌’;</p>\n<p>删除黄晓明的信息以及他女朋友的信息<br>DELETE b, bo FROM boys bo<br>INNER JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p>\n<p>4.3.2.方式2：truncate<br>语法：<br>Truncate table 表名;</p>\n<p>特点：<br>不能加筛选条件，也叫做清空。</p>\n<p>4.3.3.delete pk truncate（面试题）</p>\n<p>1.delete可以加where条件，truncate不可以<br>2.truncate删除，效率高一丢丢<br>3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。<br>如果使用truncate删除后，再插入值，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值<br>5.truncate删除不能回滚，delete删除可以回滚。</p>\n<p>5.DDL语言<br>数据库定义语言，也就是库和表的管理</p>\n<p>5.1.库的管理</p>\n<p>5.1.1.库的创建</p>\n<p>语法：<br>create database [if not exists] 库名 [character set 字符集]</p>\n<p>案例：</p>\n<p>创建一个db_book库<br>CREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;</p>\n<p>5.1.2.库的修改</p>\n<p>修改库名（现在不能用了）：<br>语法：<br>rename database 库名 to 新库名;</p>\n<p>案例<br>把db_oyr库名改成my_oyr<br>RENAME DATABASE db_oyr TO my_oyr;</p>\n<p>修改字符集：<br>语法：<br>alert database 库名 character set 字符集;</p>\n<p>案例：</p>\n<p>修改db_oyr的字符集为gbk<br>ALTER DATABASE db_oyr CHARACTER SET gbk;</p>\n<p>5.1.3.库的删除</p>\n<p>语法：<br>DROP DATABASE [IF EXISTS] 库名;</p>\n<p>案例:<br>删除db_oyr<br>DROP DATABASE db_oyr; </p>\n<p>5.2.表的管理</p>\n<p>5.2.1.表的创建</p>\n<p>语法：<br>create table 表名(<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    …<br>    列名 列类型【（类型长度） 约束】<br>);</p>\n<p>案例：<br>创建book表<br>CREATE TABLE book(<br>    id INT,#编号<br>    bName VARCHAR(20),#图书名<br>    price DOUBLE,#价格<br>    authorId INT,#作者编号<br>    publishDate DATETIME#出版日期<br>);</p>\n<p>5.2.2.表的修改</p>\n<p>语法：<br>Alter table 表名 add|drop|modify|change column 列名 【列类型 约束】</p>\n<p>（1）修改列名</p>\n<p>ALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);</p>\n<p>（2）修改列的类型或约束</p>\n<p>ALTER TABLE my_book MODIFY COLUMN myName INT;</p>\n<p>（3）添加新列</p>\n<p>ALTER TABLE book ADD COLUMN oo VARCHAR(20);</p>\n<p>（4）删除列</p>\n<p>ALTER TABLE book DROP COLUMN oo;</p>\n<p>（5）修改表名</p>\n<p>ALTER TABLE book RENAME TO my_book;</p>\n<p>5.2.3.表的删除</p>\n<p>语法：<br>DROP TABLE 【IF EXISTS】 表名;</p>\n<p>案例：</p>\n<p>删除my_book表<br>DROP TABLE IF EXISTS my_book;</p>\n<p>5.2.4.表的复制<br>1)复制表的结构<br>语法：<br>Create table 新表名 like 被复制的表名;</p>\n<p>复制boys的结构<br>CREATE TABLE copy LIKE boys;</p>\n<p>2)复制表的结构和数据<br>语法：<br>Create table 新表名<br>Select * from 被复制表的表名</p>\n<p>复制boys表的结构和数据<br>CREATE TABLE copy2<br>SELECT * FROM boys;</p>\n<p>复制boys部门数据和部分列<br>CREATE TABLE copy3<br>SELECT id,boyName FROM boys WHERE id&lt;5;<br>SELECT * FROM copy3;</p>\n<p>复制几个字段的结构<br>CREATE TABLE copy4<br>SELECT id, boyName FROM boys<br>WHERE 1=2;</p>\n<p>5.3.常见的约束</p>\n<p>5.3.1.约束介绍</p>\n<p>六大约束：<br>NOT NULL：非空约束，用于保证该字段的值不能为空<br>UNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空<br>PRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空<br>CHEACK：检查约束【MYSQL中不支持，没有效果】<br>FOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值<br>DEFAULT：默认值，用于保证字段有默认值</p>\n<p>添加约束的时机：<br>创建表时<br>修改表时</p>\n<p>约束的添加分类：<br>列级约束：<br>六大约束语法上都支持，单外检约束没有效果<br>表级约束：<br>除了非空，默认，其他都支持</p>\n<p>列级约束 VS 表级约束<br>位置            支持的约束类型                    是否可以起别名<br>列级：    列的后面        都支持，但外键没有效果            不可以<br>表级：    所有列的下面    默认和非空不支持，其他都支持    可以主键（没有效果）</p>\n<p>5.3.2.添加列级约束</p>\n<p>新建一个库students，在里面测试添加列级约束</p>\n<h1 id=\"新建主修表\"><a href=\"#新建主修表\" class=\"headerlink\" title=\"新建主修表\"></a>新建主修表</h1><p>create table major(<br>    id bigint(20) primary key, #主键约束<br>    major_name varchar(25) NOT NULL #非空约束<br>)</p>\n<h1 id=\"新建学生表\"><a href=\"#新建学生表\" class=\"headerlink\" title=\"新建学生表\"></a>新建学生表</h1><p>create table student(<br>    id bigint(20) primary key, #主键约束<br>    stu_name varchar(25) NOT NULL, #非空约束<br>    sex char(2) CHECK(sex = ‘男’ or sex = ‘女’), #检查约束<br>    age int default 20, #默认约束<br>    card varchar(25) unique,#唯一约束<br>    major_id bigint(20) REFERENCES major(id) #外键约束<br>)</p>\n<p>经过测试后发现，检查约束是无效的，而且外检约束也是无效的。<br>其他都是ok的。</p>\n<p>5.3.3.添加表级约束</p>\n<p>语法：<br>在表字段的最下面<br>[constraint 约束名] 约束类型(字段名)<br>表级约束添加外键是有效的。</p>\n<p>指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效<br>  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束<br>CONSTRAINT ch_sex CHECK(sex = ‘女’ or sex =’男’),<br>  CONSTRAINT <code>pk_student_major</code> FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>不指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  PRIMARY KEY(id), #主键，约束名不生效<br>  UNIQUE KEY(card), #唯一约束<br>    CHECK(sex = ‘女’ or sex =’男’),<br>  FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>5.3.4.主键约束 VS 唯一约束</p>\n<p>保证唯一性    是否允许为空    一个表中有几个    是否允许出现组合<br>主键        √            ×                最多一个        √，但不推荐<br>唯一        √            ×                可以多个        √，但不推荐</p>\n<p>唯一约束可以允许为空，但null只能出现一次。<br>组合就是组合主键或组合唯一约束。</p>\n<p>5.3.5.外键的特点</p>\n<p>从表：当前表<br>主表：被关联的表</p>\n<p>1.要求在从表中设置外键关系<br>2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）<br>4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表</p>\n<p>5.3.6.修改表时添加约束</p>\n<p>语法：<br>1.添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束</p>\n<p>2.添加表级约束<br>alter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]</p>\n<p>添加非空约束：<br>列级：<br>alter table student modify column stu_name varchar(25) not null;</p>\n<p>添加默认约束：<br>列级：<br>alter table student modify column age int default 20</p>\n<p>添加主键约束：<br>列级：<br>alter table student modify column id bigint(20) primary key<br>表级：<br>alter table student add primary key(id)</p>\n<p>添加唯一约束：<br>列级：<br>alter table student modify column card varchar(25) unique<br>表级：<br>alter table student add constraint un_card unique(card)</p>\n<p>添加外键约束：<br>表级：<br>alter table student add constraint fk_student_major foreign key(id) references major(id)</p>\n<p>5.3.7.修改表时删除约束</p>\n<p>1.删除非空约束（直接不写就是删除）<br>alter table student modify column stu_name varchar(25)</p>\n<p>2.删除默认约束（不写即是删除）<br>alter table student modify column age int default 20</p>\n<p>3.删除主键约束<br>aler table 表名 drop primary key</p>\n<p>4.删除唯一约束<br>alter table 表名 drop index 约束名</p>\n<p>5.删除外键约束<br>alter table 表名 drop foreign key 约束名</p>\n<p>5.4.标识列</p>\n<p>什么是标识列？<br>标识列是自增长列<br>含义：可以不手动的插入值，系统提供默认的序列值</p>\n<p>特点：<br>1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）<br>2.一个表只能有一个标识列<br>3.标识类的类型只能是数值型<br>4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值</p>\n<p>创建表时设置标识列<br>create table tb_user(<br>    id int primary key auto_increment, #主键并且设置标识列<br>    name varchar(25) not null<br>)</p>\n<p>修改表时设置标识列<br>alter table tb_user modify column id int primary key auto_increment</p>\n<p>修改表时删除标识列<br>alter table tb_user modify column id int primary key</p>\n<p>6.TCL 语言<br>TCL：Transaction Control Language 事物控制语言</p>\n<p>事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>\n<p>6.1.MySQL 中的存储引擎</p>\n<p>1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。<br>2、通过show engines；来查看mysql支持的存储引擎。<br>3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>\n<p>6.2.事务的ACID属性</p>\n<ol>\n<li><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。</p>\n</li>\n<li><p>一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。</p>\n</li>\n<li><p>隔离性（Isolation）<br>并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。</p>\n</li>\n<li><p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>\n</li>\n</ol>\n<p>6.3.事物的使用步骤</p>\n<p>事物又分两种：隐式事物和显式事物<br>隐式事物：事物没有明显的开启和结束的标记<br>列如insert，update，delete</p>\n<p>显式事物：事物具有明显的开启和结束的标记<br>前提：必须设置自动提交功能为禁用</p>\n<p>查看当前自动提交功能开关<br>show variables like ‘autocommit’</p>\n<p>关闭自动提交功能，并不是永久的，只是当前回话被关闭<br>set autocommit=0;</p>\n<p>开启事物的语法：<br>#步骤1：开启事物<br>set autocommit=0;<br>start transaction;#开启事物，可选的<br>#步骤2：编写事物中的sql语句（select insert update delete）<br>语句1;<br>语句2;<br>…….<br>#步骤3：结束事物<br>commit;#提交事物<br>rollback;回滚事物</p>\n<p>实战操作：<br>初始化<br>create table account(<br>    id bigint(20) primary key auto_increment,<br>    acc_name varchar(25),<br>    money double<br>)<br>INSERT INTO account (id, acc_name, money) VALUES (1, ‘欧阳荣’, 1500);<br>INSERT INTO account (id, acc_name, money) VALUES (2, ‘罗总’, 500);</p>\n<p>转账成功提交：执行后可以看到数据库数据已经改变了<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>commit;</p>\n<p>转账失败回滚：执行后会发现数据并没有改变<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>rollback;</p>\n<p>6.4.数据库的隔离级别</p>\n<p>6.4.1.并发问题</p>\n<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>\n<p>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段.<br>之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p>\n<p>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段.<br>之后, T1再次读取同一个字段, 值就不同了.</p>\n<p>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插<br>入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。</p>\n<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>\n<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p>\n<p>6.4.2.四种事务隔离级别</p>\n<p>Oracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。</p>\n<p>Mysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。</p>\n<p>6.5.回滚点使用（savepotion）</p>\n<p>set autocommit=0;#设置不自动提交<br>start transaction;#开启事物<br>delete form account where id=1;<br>savepoint a;#保存点<br>delete from account where id=2;<br>rollback to a;#回滚到保存点<br>这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。</p>\n<p>7.视图<br>7.1.什么是视图</p>\n<p>含义：虚拟表，和普通表一样使用<br>MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</p>\n<p>应用场景：<br>1.多个地方用到同样的查询结果<br>2.该查询结果使用的sql语句较复杂</p>\n<p>7.2.视图的创建</p>\n<p>语法：<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>OR REPLACE：表示替换已有视图</p>\n<p>ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表</p>\n<p>[WITH [CASCADED | LOCAL] CHECK OPTION]：<br>表示视图在更新时保证在视图的权限范围之内<br>cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件<br>local表示更新视图的时候，要满足该视图定义的一个条件即可<br>推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 </p>\n<p>实际操作：</p>\n<p>1.查询邮箱中包含a字符的员工名，部门名，工种信息<br>– 创建视图<br>create view view_test1<br>AS<br>SELECT<br>    CONCAT(e.first_name, e.last_name) 员工名,<br>    dept.department_name 部门名,<br>    j.job_title 工种信息<br>FROM<br>    employees e<br>LEFT JOIN departments dept ON dept.department_id = e.department_id<br>LEFT JOIN jobs j ON j.job_id = e.job_id<br>where email LIKE ‘%a%’<br>– 查询视图<br>select * from view_test1</p>\n<p>2.查询各部门的平均工资级别<br>create view view_test2<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name</p>\n<p>SELECT<br>    vt.dept_name,<br>    jb.grade_level<br>FROM<br>    view_test2 vt<br>LEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal<br>AND jb.highest_sal</p>\n<p>3.查询平均工资最低的部门<br>create view view_test3<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>4.查询平均工资最低的部门名和工资<br>create view view_test4<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>视图的好处：<br>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>\n<p>7.3.视图的修改</p>\n<p>方式一：如果存在，则覆盖<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>方式二：指定修改视图<br>alter<br>[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>    [DEFINER = { user | CURRENT_USER }]<br>    [SQL SECURITY { DEFINER | INVOKER }]<br>view 视图名<br>as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION];</p>\n<p>方式一实际操作：<br>create or replace view view_test4<br>as<br>select * from employees where employee_id &gt; 105</p>\n<p>方式二实际操作：<br>alter view view_test4<br>as<br>select * from employees where employee_id &gt; 120</p>\n<p>7.4.视图的删除</p>\n<p>语法：<br>drop view 视图名,视图名,视图名……..</p>\n<p>实际操作：<br>drop view view_test4, view_test3</p>\n<p>7.5.查看视图<br>方式1：desc 视图名</p>\n<p>方式2：show create view 视图名</p>\n<p>方式1实际操作：<br>desc view_test2</p>\n<p>可以看到实际上能看到的是当前视图可以查询出的字段信息</p>\n<p>方式2实际操作：<br>show create view view_test2</p>\n<p>可以看到的是当前拿到的是创建视图的逻辑sql。</p>\n<p>7.6.视图VS表</p>\n<p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view            只是保存了逻辑sql        增删改查，一般不能增删改查</p>\n<p>表        create table            保存了数据                增删改查</p>\n<p>8.变量</p>\n<p>8.1.系统变量</p>\n<p>说明：变量由系统提供的，不是银行定义，属于服务器层面<br>系统变量又可以细分为全局变量和局部变量</p>\n<p>使用的语法：<br>1.查看所有的系统变量<br>show global|[session] variables</p>\n<p>2.查看满足条件的部分系统变量<br>show global | [session] variables like ‘%char%’;</p>\n<p>3.查看指定的某个系统变量的值<br>select @@global | [session] .系统变量名</p>\n<p>4.为某个系统变量赋值<br>方式一：<br>set global | [session] 系统变量名 = 值;</p>\n<p>方式二：<br>Set @@global | [session] .系统变量名 = 值;</p>\n<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别</p>\n<p>8.1.1.全局变量实际操作</p>\n<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）</p>\n<p>（1）查看所有的全局变量<br>show global variables;</p>\n<p>（2）查看部分的全局变量<br>show global variables like ‘%char%’;</p>\n<p>（3）查看指定的全局变量的值<br>select @@global.autocommit;</p>\n<p>（4）为某个指定的全局变量赋值<br>set @@global.autocommit = 0;</p>\n<p>8.1.2.局部变量实际操作</p>\n<p>作用域：仅仅针对于当前会话（连接）有效</p>\n<p>（1）查看所有的会话变量<br>show variables<br>show session variables</p>\n<p>（2）查看部分的会话变量<br>show variables like ‘%char%’<br>show session variables like ‘%char%’</p>\n<p>（3）指定查看某个会话变量<br>select @@character_set_client<br>select @@session.character_set_client</p>\n<p>（4）为某个会话变量赋值<br>set autocommit=0<br>set @@session.autocommit=1</p>\n<p>8.2.自定义变量</p>\n<p>说明：变量是用户自定义的，不是由系统自动生成的。<br>自定义变量又可以细分成用户变量（当前会话有效），局部变量<br>使用步骤：<br>声明<br>赋值<br>使用（查看，比较，运算等）</p>\n<p>8.2.1.用户变量</p>\n<p>作用域：针对于电器干会话（连接）有效，同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end外面</p>\n<p>使用语法：</p>\n<p>（1）声明并初始化：<br>set @用户变量名=值 或<br>set @用户变量名:=值 或<br>select @用户变量名:=值</p>\n<p>（2）赋值（更新用户变量的值）<br>方式一：通过set和select<br>set @变量名=值 或<br>set @变量名:=值 或<br>select @变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO @变量名<br>from 表</p>\n<p>（3）使用（查看用户变量的值）<br>select @用户变量名</p>\n<p>实际操作：</p>\n<p>声明并且初始化：</p>\n<h1 id=\"声明并且初始化\"><a href=\"#声明并且初始化\" class=\"headerlink\" title=\"声明并且初始化\"></a>声明并且初始化</h1><p>set @name=’欧阳荣’;<br>set @name:=10;<br>select @name:=’罗总’;</p>\n<p>赋值：<br>#赋值<br>set @count = 10;<br>set @count := 15;<br>select @count := 20;<br>select count(*) into @count from account;</p>\n<p>使用：<br>select @count;</p>\n<p>8.2.2.局部变量</p>\n<p>作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句</p>\n<p>（1）声明<br>declare 变量名 类型;<br>declare 变量名 类型 default 值;</p>\n<p>（2）赋值<br>方式一：通过set和select<br>set 局部变量名=值 或<br>set 局部变量名:=值 或<br>select @局部变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO 局部变量名<br>from 表</p>\n<p>（3）使用<br>select 局部变量名</p>\n<p>8.2.3.用户变量 VS 局部变量</p>\n<p>作用域        定义和使用的位置                语法<br>用户变量    当前会话    会话中的任何地方                必须加@符，不限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句    不用加@符，需要限定类型</p>\n<p>9.存储过程和函数<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p>\n<p>9.1.存储过程</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>9.1.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create procedure 存储过程名(参数列表)<br>begin<br>存储过程体（一组合法的SQL语句）<br>end</p>\n<p>注意：<br>1.参数列表包含三部分<br>参数模式    参数名    参数类型<br>in            student    varchar(20)</p>\n<p>参数模式：<br>in：    该参数可以作为输入，也就是该参数需要调用方法传入值<br>out：    该参数可以作为输出，也就是该参数可以作为返回值<br>inout：    该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值</p>\n<p>2.如果存储过程体仅仅只有一句话，begin end可以省略。<br>存储过程的每条SQL语句的结尾要求必须加上分号。<br>存储过程的结尾可以使用delimiter重新设置<br>语法：<br>DELIMITER 结束标记<br>DELIMITER $</p>\n<p>调用语法：<br>CALL 存储过程名（实参列表）</p>\n<p>查看语法：<br>show create procedure 存储过程名;</p>\n<p>删除语法：<br>drop procedure 存储过程名;</p>\n<p>9.1.2.存储过程实战</p>\n<p>（1）空参的存储过程：</p>\n<h1 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1()<br>begin<br>    insert into admin(name, money) values(‘z1’, 11), (‘z2’, 22), (‘z3’, 33), (‘z4’, 44), (‘z5’, 55);<br>end;</p>\n<p>#调用存储过程<br>CALL myp1();</p>\n<p>带in模式参数的存储过程：<br>根据女神名获取男神信息</p>\n<h1 id=\"创建存储过程-1\"><a href=\"#创建存储过程-1\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1(in beauty_name varchar(25))<br>begin<br>    select bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<h1 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h1><p>call myp1(‘赵敏’)</p>\n<p>根据用户名和密码判断是否能登录成功<br>– 创建存储过程<br>create procedure myp2(in username varchar(25), in password varchar(25))<br>begin<br>    declare result int default ‘0’;<br>    select count(*) INTO result from admin a where a.username = username and a.<code>password</code> = password;<br>    select if(result &gt; 0, ‘成功’, ‘失败’);<br>end;<br>– 调用<br>call myp2(‘john’, ‘8888’)</p>\n<p>（2）带out模式的存储过程：</p>\n<p>根据女神名，返回对应的男神名<br>#创建<br>create procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))<br>begin<br>    select bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;<br>– 调用<br>set @boy_name=’’;<br>call myp3(‘赵敏’, @boy_name);<br>select @boy_name;</p>\n<p>根据女神名，返回对应的男神名和男神魅力值<br>创建<br>create procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)<br>begin<br>    select bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<p>– 调用<br>set @boy_name=’’;<br>set @user_cp=0;<br>call myp4(‘赵敏’, @boy_name, @user_cp);<br>select @boy_name, @user_cp;</p>\n<p>（3）带inout模式参数的存储过程</p>\n<p>传入a和b两个值，最终a和b都翻倍并返回<br>#创建<br>create procedure myp5(inout x int, inout y int)<br>begin<br>    set x = x<em>2;<br>    set y = y</em>2;<br>end;<br>#调用<br>set @x = 10;<br>set @y = 20;<br>call myp5(@x, @y);<br>select @x, @y;</p>\n<p>9.2.函数</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>存储过程与函数的区别：<br>存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新<br>函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果</p>\n<p>9.2.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create function 函数名(参数列表) returns 返回类型<br>begin<br>函数体<br>end</p>\n<p>注意：<br>1.参数列表包含两部分：参数名 参数类型<br>2.函数体：肯定会有return语句，如果没有会报错。<br>如果return语句没有放在函数体的最后也不报错，但不建议。<br>3.函数体重仅有一句话，则可以省略begin end<br>4.使用delimiter语句设置结束标记</p>\n<p>调用语法：<br>select 函数名（参数列表）</p>\n<p>查看语法：<br>show create function 函数名</p>\n<p>删除语法：<br>dorp function 函数名</p>\n<p>9.2.2.函数实战</p>\n<p>（1）无参有返回</p>\n<p>返回公司的员工个数：<br>#创建<br>create function myf1() returns int<br>begin<br>    declare count int default 0;<br>    select COUNT(*) into count from employees;<br>    return count;<br>end;<br>#调用<br>select myf1();</p>\n<p>（2）有参返回</p>\n<p>根据员工名返回工资：<br>#创建<br>create function myf2(username varchar(25)) returns double<br>begin<br>    declare money double default 0;<br>    select salary into money from employees where last_name = username;<br>    return money;<br>end;<br>#调用<br>select myf2(‘Kochhar’);</p>\n<p>根据部门名，发挥该部门的平均工资<br>#创建<br>create function myf3(dept_name varchar(25)) returns double<br>begin<br>    declare ave_salary double default 0;<br>    select avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id<br>    where dept.department_name = dept_name group by dept.department_id;<br>    return ave_salary;<br>end;<br>#调用<br>select myf3(‘Adm’);</p>\n<p>实现传入两个float，返回两者之和：</p>\n<p>#创建<br>create function myf1(x float, y float) returns float<br>begin<br>    declare sum float default 0;<br>    set sum = x + y;<br>    return sum;<br>end;<br>#调用<br>select myf1(1, 5.1);</p>\n<p>（3）查看函数<br>show create function myf3;</p>\n<p>（4）删除函数<br>drop function myf3</p>\n<p>10.流程控制结构<br>顺序结构：程序从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上重复执行一段代码</p>\n<p>10.1.分支结构</p>\n<p>（1）if函数<br>功能：实现简单的双分支<br>语法：<br>If(表达式1, 表达式2, 表达式3)<br>执行顺序：<br>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值<br>应用：任何地方<br>实战操作：<br>select if(1 &gt; 2, 1, 2)<br>当前sql执行后会返回2</p>\n<p>（2）case结构</p>\n<p>在begin end 外面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 返回的值1<br>when 要判断的值 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 返回的值1<br>when 要判断的条件2 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>在begin end里面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 要执行的语句1<br>when 要判断的值 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 要执行的语句1<br>when 要判断的条件2 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create procedure show_grade(in grade int)<br>begin<br>    declare result varchar(2);<br>    CASE<br>    WHEN grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    WHEN grade&gt;=80 THEN set result = ‘B’;<br>    WHEN grade&gt;=60 THEN set result = ‘C’;<br>    ELSE set result = ‘D’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>CALL show_grade(99);</p>\n<p>#根据传递的数据库类型，显示对应的数据库名<br>create procedure show_database_type(in val int)<br>begin<br>    declare result varchar(20);<br>    CASE val<br>    WHEN 1 THEN set result = ‘mysql’;<br>    WHEN 2 THEN set result = ‘oracle’;<br>    WHEN 3 THEN set result = ‘sql server’;<br>    ELSE set result = ‘不认识的类型，滚啊。。。’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>call show_database_type(1);</p>\n<p>（3）if结构<br>功能：实现多重分类<br>语法：<br>if 条件1 then 语法1;<br>esleif 条件2 then 语法2;<br>…<br>[else 语句n;]<br>end if;</p>\n<p>应用场景：应用在begin end中</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create function show_grade(grade int) returns char(1)<br>begin<br>    declare result char(1);<br>    if grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    elseif grade&gt;=80 THEN set result = ‘B’;<br>    elseif grade&gt;=60 THEN set result = ‘C’;<br>    else set result = ‘D’;<br>    end if;<br>    return result;<br>end;</p>\n<p>select show_grade(55);</p>\n<p>#批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>create procedure pro_while_insert2(in count int)<br>begin<br>    declare i int default 1;<br>    a:while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        if i&gt;=20 then leave a;<br>        end if;<br>        set i=i+1;<br>    end while a;<br>end;</p>\n<p>call pro_while_insert2(30);</p>\n<p>10.2.循环结构</p>\n<p>循环分类：<br>while、 loop、repeat</p>\n<p>循环控制：<br>iterate类似于continue，结束本次循环，继续下一次循环<br>leave类似于break，结束当前所在循环。</p>\n<p>三种循环语法：</p>\n<p>（1）while<br>[标签:] while 循环条件 do<br>循环体<br>end while [标签]</p>\n<p>（2）loop<br>[标签:] loop<br>循环体<br>end loop [标签]</p>\n<p>（3）repeat<br>[标签:] repeat<br>循环体<br>until 结束循环的条件<br>end repeat [标签]</p>\n<p>循环实战操作：</p>\n<p>#批量插入，根据次数插入到amdin表中多条数据<br>create procedure pro_while_insert(in count int)<br>begin<br>    declare i int default 1;<br>    while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        set i=i+1;<br>    end while;<br>end;</p>\n<p>call pro_while_insert(10);</p>\n<p>while VS repeat VS loop<br>while：先判断后执行<br>repeat：先执行后判断<br>loop：没有条件的死循环</p>\n<h1 id=\"博客园所学\"><a href=\"#博客园所学\" class=\"headerlink\" title=\"博客园所学\"></a>博客园所学</h1><h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.<br>单列索引:一个索引只包含一个列,一个表可以有多个单列索引.<br>组合索引:一个组合索引包含两个或两个以上的列。</p>\n<h3 id=\"索引的创建\"><a href=\"#索引的创建\" class=\"headerlink\" title=\"索引的创建\"></a>索引的创建</h3><p>1）单列索引</p>\n<p>普通索引：<br>第一种方式 :<br>CREATE INDEX 索引名ON 表名(<code>字段名</code>(length))</p>\n<p>第二种方式: <br>ALTER TABLE award ADD INDEX account_Index(<code>account</code>)</p>\n<p>唯一索引：<br>CREATE UNIQUE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length));<br>ALTER TABLE TableName ADD UNIQUE (column_list)</p>\n<p>主键索引：不允许有空值</p>\n<p>2）组合索引：</p>\n<p>语法：<br>CREATE INDEX IndexName On <code>TableName</code>(<code>字段名</code>(length),<code>字段名</code>(length),…);</p>\n<h3 id=\"索引的删除\"><a href=\"#索引的删除\" class=\"headerlink\" title=\"索引的删除\"></a>索引的删除</h3><p>语法：<br>DORP INDEX IndexName ON <code>TableName</code></p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>触发器：监视某种情况，并触发某种操作。</p>\n<h3 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h3><p>触发器创建语法四要素：1.监视地点(table)<br>　　　　　　　　　　　2.监视事件(insert/update/delete)<br>　　　　　　　　　　 3.触发时间(after/before)<br>　　　　　　　　　　　4.触发事件(insert/update/delete)</p>\n<p>语法：<br>create trigger triggerName after/before insert/update/delete<br>on 表名 for each row #这句话是固定的<br> begin<br>     #需要执行的sql语句<br> end<br>注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发<br>注意2:insert/update/delete:只能选一个</p>\n<p>创建一个视图：<br>create trigger tag1 after insert on order_table<br>for each row<br>begin<br>    update goods set num=num-3 where id=1;<br>end;</p>\n<p>我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。<br>对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。<br>所以现在我们可以这样来改我们的触发器:<br>create trigger tg1 after insert on order_table<br>for each row<br>BEGIN<br>    update goods set num = num-new.much where id=new.gid;<br>END;</p>\n<p>当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？<br> 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。<br>create trigger tg2 after delete on order_table<br>for each ROW<br>BEGIN<br>    update goods set num = num+old.much where id=old.gid;<br>END;</p>\n<h3 id=\"删除触发器\"><a href=\"#删除触发器\" class=\"headerlink\" title=\"删除触发器\"></a>删除触发器</h3><p>语法：drop trigger 触发器名称;<br>使用：drop trigger dg1;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Mysql数据库</p>\n<h1 id=\"MySql基础\"><a href=\"#MySql基础\" class=\"headerlink\" title=\"MySql基础\"></a>MySql基础</h1><h2 id=\"数据库的好处\"><a href=\"#数据库的好处\" class=\"headerlink\" title=\"数据库的好处\"></a>数据库的好处</h2><p>可以持久化到本地<br>结构化查询</p>\n<hr>\n<h2 id=\"主流的数据库介绍（了解）\"><a href=\"#主流的数据库介绍（了解）\" class=\"headerlink\" title=\"主流的数据库介绍（了解）\"></a>主流的数据库介绍（了解）</h2><p>Sql server 数据库<br>是微软，.net程序员最爱，中型和大型项目，性能高</p>\n<p>Oracle数据库<br>是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。</p>\n<p>Mysql数据库<br>是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。</p>\n<p>db2数据库<br>是ibm公司，处理海量数据，大型项目。很强悍。</p>\n<p>Informix数据库<br>是ibm公司。在银行系统，安全性高</p>\n<p>Sybase数据库</p>\n<hr>\n<h2 id=\"mysql的优点\"><a href=\"#mysql的优点\" class=\"headerlink\" title=\"mysql的优点\"></a>mysql的优点</h2><p>开源，免费成本低<br>性能高，移植性也好<br>体积小，便于安装</p>\n<h2 id=\"mysql数据库的安装和配置\"><a href=\"#mysql数据库的安装和配置\" class=\"headerlink\" title=\"mysql数据库的安装和配置\"></a>mysql数据库的安装和配置</h2><p>看MySQL-5.7.17安装与配置.docx</p>\n<h2 id=\"mysql的基本使用\"><a href=\"#mysql的基本使用\" class=\"headerlink\" title=\"mysql的基本使用\"></a>mysql的基本使用</h2><p>（1）连接到mysql<br>Cmd&gt;mysql -h 主机名 -u 用户名 -p 密码 回车<br>举例：</p>\n<p>说明：<br>如果你没有写-h localhost 默认是连接本地</p>\n<p>如果你需要远程登录到另一个mysql,则需要修改配置。<br>一般情况下部让远程登录。</p>\n<p>（2）sql服务的退出<br>exit或ctrl+c</p>\n<p>（3）关闭和启动mysql服务<br>界面操作：</p>\n<p>命令模式：<br>启动：net stop mysql<br>停止：net start mysql<br>举例：</p>\n<p>说明：这里mysql不是固定的，是安装时取的服务名称。</p>\n<h2 id=\"mysql数据库三层架构介绍\"><a href=\"#mysql数据库三层架构介绍\" class=\"headerlink\" title=\"mysql数据库三层架构介绍\"></a>mysql数据库三层架构介绍</h2><p>专业术语</p>\n<p>Db：<br>数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。</p>\n<p>Dbms：<br>数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。</p>\n<p>Sql:<br>结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。</p>\n<p>数据库服务器，数据库和表的关系如图所示：</p>\n<p>示意图：</p>\n<h2 id=\"mysql常见命令\"><a href=\"#mysql常见命令\" class=\"headerlink\" title=\"mysql常见命令\"></a>mysql常见命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看当前所有的数据库</span><br><span class=\"line\">show databases;</span><br><span class=\"line\"></span><br><span class=\"line\">2.打开指定的库</span><br><span class=\"line\">use 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">3.查看所在的数据库名</span><br><span class=\"line\">select database();</span><br><span class=\"line\"></span><br><span class=\"line\">4.查看当前库的所有表</span><br><span class=\"line\">show tables;</span><br><span class=\"line\"></span><br><span class=\"line\">5.查看其它库的所有表</span><br><span class=\"line\">show tables from 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">6.创建表</span><br><span class=\"line\">create table user(id int, name varchar(20));</span><br><span class=\"line\"></span><br><span class=\"line\">7.查看表结构</span><br><span class=\"line\">desc 表名;\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">8.查看服务器的版本</span><br><span class=\"line\">方式一：登录到mysql服务端</span><br><span class=\"line\">Select version();</span><br><span class=\"line\">方式二：没有登录到mysql服务端</span><br><span class=\"line\">Mysql --version或mysql --V</span><br><span class=\"line\"></span><br><span class=\"line\">9.查看当前时区</span><br><span class=\"line\">SHOW VARIABLES LIKE &#x27;time_zone&#x27;</span><br><span class=\"line\">SET time_zone=&#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mysql的语法规范\"><a href=\"#Mysql的语法规范\" class=\"headerlink\" title=\"Mysql的语法规范\"></a>Mysql的语法规范</h2><p>1.不区分大小写，单建议关键字大写，表名，列名小写。<br>2.每条语句最好用分号结尾。<br>3.每条命令根据需要，可以进行缩进或换行<br>4.注释<br>单行注释：两种<br>第一种：#注释文字<br>第二种：– 注释文字<br>多行注释：/* 注释文字 */</p>\n<h1 id=\"常用数据类型\"><a href=\"#常用数据类型\" class=\"headerlink\" title=\"常用数据类型\"></a>常用数据类型</h1><h2 id=\"数值型\"><a href=\"#数值型\" class=\"headerlink\" title=\"数值型\"></a>数值型</h2><p>2.1.1.整型</p>\n<p>特点：<br>（1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>（2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值<br>（4）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！</p>\n<p>2.1.2.小数</p>\n<p>浮点型：<br>Float(m, d)，double(m, d)<br>4            8</p>\n<p>定点型：<br>Dec(m, d)，decimal(m, d)<br>M+2        m+2</p>\n<p>特点：<br>（1）<br>M：整数部位+小数部位（总长度）<br>D：小数部位<br>如果超出范围插入临界值</p>\n<p>（2）<br>M和D都可以省略<br>如果是decimal，则m默认为10，d默认为0<br>如果是double和float，则会随着插入的数值的精度来决定精度</p>\n<p>（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用</p>\n<p>2.2.字符型</p>\n<p>较短的文本：<br>Char<br>Varchar</p>\n<p>特点：</p>\n<p>写法        m的意思            特点            空间的耗费        效率<br>Char    char(m)        最大的字符数    固定长度        比较耗费        高<br>Varchar    varchar(m)    最大的字符数    可变长度的字符    比较节省        低</p>\n<p>较长的文本：<br>Text<br>Blob（较大的二进制）</p>\n<p>Enum类型：<br>说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。<br>如果列表成员为1<del>255，则需要1个字节存储<br>如果列表成员为255</del>65535，则需要2个字节存储<br>最多需要65535个成员</p>\n<p>Set类型：<br>说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区<br>别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>\n<p>2.3.日期型</p>\n<p>总结：<br>Date：只保存日期，并没有保存到时分秒<br>Time：只保存时间（时分秒）<br>Year：只保存年</p>\n<p>Datetime：保存日期+时间<br>Timestamp：保存日期+时间</p>\n<p>Datetime VS Timestamp</p>\n<p>字节    范围        时区等的影响<br>Datetime     8        1000-9999        不受<br>Timestamp    4        1970-2038        受</p>\n<h1 id=\"DQL语言（select）\"><a href=\"#DQL语言（select）\" class=\"headerlink\" title=\"DQL语言（select）\"></a>DQL语言（select）</h1><h2 id=\"基础查询\"><a href=\"#基础查询\" class=\"headerlink\" title=\"基础查询\"></a>基础查询</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>select 查询列表 from 表名</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>查询列表开源是字段，常量表达式，函数，也可以有多个。<br>查询结构是一个虚拟表。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>1.查询单个字段<br>Select 字段名 from 表名</p>\n<p>2.查询多个字段<br>Select 字段名,字段名 from 表名</p>\n<p>3.查询所有的字段<br>Select * from 表名</p>\n<p>4.查询常量<br>Select 常量值<br>注意：字符型和日期型常量值必须用单引号用起来，数值类不需要</p>\n<p>5.查询函数<br>Select 函数名（实例参数）;</p>\n<p>6.查询表达式<br>Select 100*10;</p>\n<p>7.取别名<br>两种方式<br>As<br>Select last_name as 姓名 from 表名  </p>\n<p>空格<br>Select last_name 姓名 from 表名</p>\n<p>8.去重<br>Select distinct 字段名 from 表名</p>\n<p>9.+<br>作用：加法运算<br>Select 数值+数值;直接运算<br>Select 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，    再做运算。</p>\n<p>10.补充Concat函数<br>功能：拼接字符<br>Select concat(字符1,字符2,字符3,….)</p>\n<p>11.补充ifnull函数<br>Select ifnull(name, 0) from user</p>\n<p>12.补充isnull函数<br>Select isnull(name) from user<br>功能：拍的某个字段是否为null，如果是返回1，如果不是返回0</p>\n<h2 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select 查询列表<br>From 表名<br>Where 筛选条件</p>\n<h3 id=\"筛选条件的分类\"><a href=\"#筛选条件的分类\" class=\"headerlink\" title=\"筛选条件的分类\"></a>筛选条件的分类</h3><p>（1）简单条件运算符  </p>\n<p><code>&gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;</code></p>\n<p>Select * from user where age&gt;15;</p>\n<p>Select * from user where age&lt;15;</p>\n<p>Select * from user where age&lt;&gt;15;</p>\n<p>&lt;=&gt;:安全等于，可以判断普通数值，也可以判断是否为null<br>Select * from user where age&lt;=&gt; null;</p>\n<p>（2）逻辑运算符</p>\n<p><code>and or not</code></p>\n<p>And:<br>SELECT last_name FROM employees WHERE salary&gt;=10000 AND salary&lt;=20000;</p>\n<p>Or:<br>SELECT * FROM employees WHERE department_id&lt;90 OR department_id&gt;110 OR salary&gt;15000;</p>\n<p>Not:<br>SELECT * FROM employees WHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;</p>\n<p>（3）模糊查询</p>\n<p><code>Like, between and, in, is null, is not null </code></p>\n<p>like：<br>Select * from user where name like’%a%’;<br>Select * from user where name like’_a%’;</p>\n<p>between and:<br>作用：在哪两个数之间<br>Select * from user where age between 10 and 20;</p>\n<p>in:<br>Select * from user where id in(1,2,3);</p>\n<p>is null:<br>作用：判断是否为null<br>Select * from user where age is null;</p>\n<p>is not null:<br>作用：判断是否不为空<br>Select * from user where age is not null;</p>\n<h2 id=\"排序查询\"><a href=\"#排序查询\" class=\"headerlink\" title=\"排序查询\"></a>排序查询</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select * from 表名<br>[Where 筛选条件]<br>Order by 排序列表[asc desc]</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>（1）asc代表升序，desc代表降序，如果不写是升序。<br>（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名<br>（3）order by子句一般是放查询语句的最后面，limit子句除外</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>#案例：查询员工信息，要求工资冲高到底排序  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span>, salary<span class=\"operator\">*</span><span class=\"number\">12</span><span class=\"operator\">*</span>(<span class=\"number\">1</span><span class=\"operator\">+</span>IFNULL(commission_pct, <span class=\"number\">0</span>)) <span class=\"keyword\">AS</span> 年薪 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 年薪 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> LENGTH(email) <span class=\"keyword\">DESC</span>, department_id <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><p>功能：类似java中的方法<br>好处：提高重用性和隐藏实现细节<br>调用：select 函数名(参数列表)  </p>\n<h3 id=\"字符函数\"><a href=\"#字符函数\" class=\"headerlink\" title=\"字符函数\"></a>字符函数</h3><p>LENGTH：<br>作用：获取参数的字节个数<br>SELECT LENGTH(‘oyr’);<br>SELECT LENGTH(‘欧阳荣’);</p>\n<p>CONCAT：<br>作用：拼接字符串<br>SELECT CONCAT(‘abc’, ‘jkl’);<br>SELECT CONCAT(first_name, last_name) out_put FROM employees;</p>\n<p>UPPER：<br>作用：字符串变大写<br>SELECT UPPER(“asc”);</p>\n<p>Lower：<br>作用：字符串变小写<br>SELECT LOWER(“ASC”);</p>\n<p>Substr:<br>作用：截取字符串，两种使用方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#第一种：截取从指定索引处后面所有字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣真的帅哦&quot;, <span class=\"number\">4</span>);  </span><br><span class=\"line\">结果：真的帅哦</span><br><span class=\"line\"></span><br><span class=\"line\">#第二种：截取从指定索引处指定字符串的字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣不是一般帅哦&quot;, <span class=\"number\">1</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\"># 案例<span class=\"number\">1</span>：姓名首字母大写，其他字符小写然后用_拼接，显示出来</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"built_in\">UPPER</span>(SUBSTR(last_name, <span class=\"number\">1</span>, <span class=\"number\">1</span>)), <span class=\"string\">&#x27;_&#x27;</span>, <span class=\"built_in\">LOWER</span>(SUBSTR(last_name, <span class=\"number\">2</span>))) <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<p>Trim:<br>作用：去除两边空格或去除两边指定字符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#去除两边空格：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;   欧阳荣 &#x27;</span>));</span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\">#去除两边指定字符：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;a&#x27;</span> <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;aaaaaaaa欧阳aaa荣aaaaaa&#x27;</span>);</span><br><span class=\"line\">结果：欧阳aaa荣</span><br></pre></td></tr></table></figure>\n\n<p>Lpad：<br>作用：lpad 用指定的字符实现左填充指定长度<br>SELECT LPAD(‘欧阳荣’, 10, ‘a’) out_put;</p>\n<p>Rpad：<br>作用：用指定的字符实现右填充指定长度<br>SELECT LPAD(‘欧阳荣’, 12, ‘ab’) out_put;</p>\n<p>Replace：<br>作用：替换字符串<br>SELECT REPLACE(‘赵吊彬是zz赵吊彬赵吊彬赵吊彬’, ‘赵吊彬’, ‘李执志’);</p>\n<p>Instr:<br>作用：获取子串第一次出现的索引<br>SELECT INSTR(‘欧阳荣多对多’, ‘欧阳’);<br>结果为：1</p>\n<h3 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h3><p>Round:<br>作用：四舍五入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种使用：</span><br><span class=\"line\">SELECT ROUND(1.65);</span><br><span class=\"line\">结果：2</span><br><span class=\"line\"></span><br><span class=\"line\">第二种使用：</span><br><span class=\"line\">SELECT ROUND(1.657, 2);</span><br><span class=\"line\">结果：1.66</span><br></pre></td></tr></table></figure>\n\n<p>Ceil：<br>作用：向上取整<br>SELECT CEIL(1.52);<br>结果：2</p>\n<p>Floor：<br>作用：向下取整<br>SELECT FLOOR(9.99);<br>结果：9</p>\n<p>Truncate：<br>作用：截断<br>SELECT TRUNCATE(10.19, 1);<br>结果：10.1</p>\n<p>Mod：<br>作用：取余<br>SELECT MOD(10, 3);<br>结果：1</p>\n<p>Rand：<br>作用：获取随机数，返回0-1之间的小数<br>SELECT RAND();</p>\n<h3 id=\"日期函数\"><a href=\"#日期函数\" class=\"headerlink\" title=\"日期函数\"></a>日期函数</h3><p>NOW：<br>作用：返回当前系统日期+时间<br>SELECT NOW();</p>\n<p>Curdate：<br>作用：返回当前系统日期，不包含时间<br>SELECT CURDATE();</p>\n<p>Curtime：<br>作用：返回当前时间，不包含日期<br>SELECT CURTIME();</p>\n<p>Year：<br>作用：获取年<br>Select year(now());<br>SELECT YEAR(‘1999-1-1’) 年;</p>\n<p>Month:<br>作用：获取月<br>SELECT MONTH(NOW()) 月;</p>\n<p>Day:<br>作用：获取日<br>Select DAY(now()) 日;</p>\n<p>日期格式符：</p>\n<p>Str_to_date:<br>作用：将日期格式的字符转换成指定格式的日期<br>SELECT STR_TO_DATE(‘1999-6-2’, ‘%Y-%c-%d’) out_put;<br>SELECT * FROM employees WHERE hiredate=STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’);</p>\n<p>Date_format：<br>作用：将日期转换成字符<br>SELECT DATE_FORMAT(NOW(), ‘%y年%m月%d日’) AS out_put;</p>\n<p>案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）<br>SELECT last_name, DATE_FORMAT(hiredate, ‘%M月/%d日 %y年’)<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p>\n<p>Datediff：<br>作用：返回两个日期相差的天数<br>SELECT DATEDIFF(NOW(), ‘1999-06-24’);</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><p>VERSION：<br>作用：查看当前mysql版本号<br>SELECT VERSION();</p>\n<p>DATABASE：<br>作用：查看当前打开的数据库<br>Select DATABASE();</p>\n<p>USER：<br>作用：查看当前登录的用户<br>Select USER();</p>\n<h3 id=\"流程控制函数\"><a href=\"#流程控制函数\" class=\"headerlink\" title=\"流程控制函数\"></a>流程控制函数</h3><p>If：<br>作用：判断真假<br>SELECT IF(10&lt;5, ‘小’, ‘大’);</p>\n<p>Case:<br>作用：判断<br>语法：<br>case 要带的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量1 then 要显示的值1或语句1;<br>…..<br>else 要显示的值n或语句n<br>End</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：查询员工的工资，要求</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">30</span>,显示的工资为<span class=\"number\">1.1</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">40</span>，显示的工资为<span class=\"number\">1.2</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">50</span>，显示的工资为<span class=\"number\">1.3</span>倍</span><br><span class=\"line\">其他部门，显示的工资为原工资</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary 原工资, </span><br><span class=\"line\"><span class=\"keyword\">CASE</span> department_id</span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">30</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">40</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.2</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">50</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.3</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> salary</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 新工资</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br><span class=\"line\"></span><br><span class=\"line\">案例：查询员工的工资的情况</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">20000</span>，显示A级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">15000</span>，显示B级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">10000</span>,显示C级别</span><br><span class=\"line\">否则，显示D级别</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,salary,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">20000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">15000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">10000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;D&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 级别</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><h3 id=\"分组函数\"><a href=\"#分组函数\" class=\"headerlink\" title=\"分组函数\"></a>分组函数</h3><p>sum:<br>作用：求和<br>SELECT SUM(salary) FROM employees;</p>\n<p>max:<br>作用：最大值<br>Select max(salary) from employees;</p>\n<p>min：<br>作用：最小值<br>SELECT MIN(salary) FROM employees;</p>\n<p>avg：<br>作用：平均数<br>SELECT AVG(salary) FROM employees;</p>\n<p>count：<br>作用：计算个数<br>Select count(*) from user;</p>\n<p>注意事项：<br>sum，avg一般用于数值型<br>max，min，count可以处理任何类型<br>以上分组函数都忽略null值</p>\n<h3 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h3><p>语法：<br>select 分组函数，列（要求出现在group by的后面）<br>from 表<br>[where 筛选条件]<br>group by 分组的列表<br>[having 分组后的筛选]<br>[order by 子句]</p>\n<p>注意：<br>查询列表必须特殊，要求是分组函数或group by后出现的字段<br>分组后筛选在group by子句的后面使用 having 关键字<br>分组函数做条件肯定是放在having子句中<br>能用分组前筛选，就优先使用分组前筛选<br>group by 子句支持单个字段分组，多个字段分组（用逗号隔开）</p>\n<p>简单分组：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id,<span class=\"built_in\">AVG</span>(salary) 平均工资 <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id; </span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询每个工种的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询每个位置上的部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> location_id, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> location_id;</span><br></pre></td></tr></table></figure>\n\n<p>添加筛选条件：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id, <span class=\"built_in\">AVG</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%a%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询有奖金的每个领导手下的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MAX</span>(salary)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> commission_pct <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询哪个部门的员工个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> department_id, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\"><span class=\"keyword\">from</span> employees</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> department_id <span class=\"keyword\">having</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">4</span>：查询每个工种有奖金的员工的最高工资<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>的工种编号和最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MAX</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">5</span>：查询领导编号<span class=\"operator\">&gt;</span><span class=\"number\">102</span>的每个领导手下的最低工资<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>的领导编号是哪个</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MIN</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> manager_id<span class=\"operator\">&gt;</span><span class=\"number\">102</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MIN</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">6</span>：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数<span class=\"operator\">&gt;</span><span class=\"number\">5</span>的有哪些</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, LENGTH(last_name), <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 员工个数 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> LENGTH(last_name) <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接查询\"><a href=\"#连接查询\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h2><p>什么是连接查询：<br>又称多表查询，当查询的字段来自多个表时，就会用到连接查询。</p>\n<p>笛卡尔积:<br>笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</p>\n<p>按功能分类：</p>\n<ul>\n<li>内连接：  <ul>\n<li>等值连接  </li>\n<li>非等值连接  </li>\n<li>自连接  </li>\n</ul>\n</li>\n<li>外连接：  <ul>\n<li>左外连接  </li>\n<li>右外连接  </li>\n<li>全外连接（mysql不支持）  </li>\n</ul>\n</li>\n<li>交叉连接：  </li>\n</ul>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select 查询列表<br>From 表1 别名 【连接类型】<br>Join 表2 别名<br>On 连接条件<br>【where 筛选条件】<br>【group by 分组】<br>【having 分组后筛选】<br>【order by 排序列表】</p>\n<h3 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3><p>Sql192语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询女神名和对应男生名</span><br><span class=\"line\">SELECT b.name,bs.boyName </span><br><span class=\"line\">FROM beauty b, boys bs </span><br><span class=\"line\">WHERE b.boyfriend_id = bs.id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询员工名和对应的部门名</span><br><span class=\"line\">SELECT e.last_name, e.department_id, d.department_name </span><br><span class=\"line\">FROM employees e, departments d </span><br><span class=\"line\">WHERE e.department_id=d.department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询有奖金的员工名，部门名</span><br><span class=\"line\">SELECT e.`last_name`, d.`department_id`, e.`commission_pct` </span><br><span class=\"line\">FROM employees e,departments d </span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class=\"line\">SELECT j.job_title, COUNT(*) </span><br><span class=\"line\">FROM employees e, jobs j </span><br><span class=\"line\">WHERE e.`job_id`=j.`job_id` </span><br><span class=\"line\">GROUP BY j.`job_title` ORDER BY COUNT(*) DESC;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）非等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询员工的工资和工资级别</span><br><span class=\"line\">SELECT e.`salary`, j.`grade_level` </span><br><span class=\"line\">FROM employees e, job_grades j</span><br><span class=\"line\">WHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`=&#x27;E&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）自连接</span><br><span class=\"line\">查询员工名和上级的名称</span><br><span class=\"line\">SELECT e1.last_name, e2.`last_name` </span><br><span class=\"line\">FROM employees e1,  employees e2</span><br><span class=\"line\">WHERE e1.`manager_id`=e2.`employee_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">三表连接：查询员工名，部门名和所在的城市</span><br><span class=\"line\">SELECT e.last_name, d.`department_name`, l.`city` </span><br><span class=\"line\">FROM employees e, departments d, locations l</span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;</span><br></pre></td></tr></table></figure>\n\n<p>sql99语法：Inner </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询员工名，部门名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">查询名字中只能包含e的员工名和工种名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, j.`job_title` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> jobs j <span class=\"keyword\">ON</span> e.`job_id`<span class=\"operator\">=</span>j.`job_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`last_name` <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询部门个数<span class=\"operator\">&gt;</span><span class=\"number\">3</span>的城市名和部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> l.`city`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> locations l </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> l.`location_id` <span class=\"operator\">=</span> d.`location_id`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> l.`city` <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询工资级别的个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span>的个数，并按工资级别降序</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> j.`grade_level`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 个数 <span class=\"keyword\">FROM</span> job_grades j</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> e.`salary` <span class=\"keyword\">BETWEEN</span> j.`lowest_sal` <span class=\"keyword\">AND</span> j.`highest_sal`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> j.`grade_level` <span class=\"keyword\">HAVING</span> 个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 个数 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><p>应用场景：用于查询一个表中有，另一个表没有</p>\n<p>1.外连接的查询结构为主表中的所有记录<br>如果从表中有和它匹配的，则显示匹配值<br>如果从表中没有和它匹配的，则显示为null<br>外连接查询结果=内连接结果+主表中有而从表没有的数据</p>\n<p>2.左外连接，left join左边的是主表<br>右外连接，right join右边的是主表  </p>\n<p>3.左外和右外交换两个表的顺序，可以实现同样的效果</p>\n<p>（1）左连接：<br>语法：Left 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b </span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> boys bo <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> departments d</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> d.`department_id`<span class=\"operator\">=</span>e.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n<p>（2）右连接<br>语法：Right 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> boys bo </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> beauty b <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n\n<p>（3）全外（mysql不支持）<br>语法：Full 【outer】</p>\n<h3 id=\"交叉连接\"><a href=\"#交叉连接\" class=\"headerlink\" title=\"交叉连接\"></a>交叉连接</h3><p>语法：Cross</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女神男神表交叉连接</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> b.<span class=\"operator\">*</span>, bo.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b</span><br><span class=\"line\"><span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><p>出现在其他语句的select语句，称为子查询或内出现<br>内部嵌套其他select语句的查询，称为外查询或主查询</p>\n<h3 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h3><p>按子查询出现的位置：<br>1）select 后面<br>2）from 后面<br>3）wehre 或 having后面<br>4）exists后面（相关子查询）  </p>\n<p>按结果集的行列数不同：<br>1）标量子查询（结果集只有一行一列）<br>2）列子查询（结果集只有一列多行）<br>3）行子查询（结果集有多行多列）<br>4）表子查询（结果集一般为多行多列）</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p><code>&gt; &lt; &lt;&gt; = </code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">谁的工资比 Abel 高？</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> last_name<span class=\"operator\">=</span><span class=\"string\">&#x27;Abel&#x27;</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">返回job_id与<span class=\"number\">141</span>号员工相同，salary比<span class=\"number\">143</span>号员工多的员工姓名，job_id和工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,job_id,salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> job_id <span class=\"operator\">=</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> job_id <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">案例<span class=\"number\">3</span>：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, job_id, salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"operator\">=</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">MIN</span>(salary) <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">In</span>（常用）：</span><br><span class=\"line\">作用：可以是子查询中的任一一个</span><br><span class=\"line\">返回location_id是<span class=\"number\">1400</span>或<span class=\"number\">1700</span>的部们中的所有员工姓名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> department_id <span class=\"keyword\">IN</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> department_id <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">WHERE</span> location_id <span class=\"keyword\">IN</span>(<span class=\"number\">1400</span>, <span class=\"number\">1700</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Any</span>（不常用）：</span><br><span class=\"line\">作用：任一一个</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ANY</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">All</span>（不常用）：</span><br><span class=\"line\">作用：所有的</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ALL</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页查询（常用）\"><a href=\"#分页查询（常用）\" class=\"headerlink\" title=\"分页查询（常用）\"></a>分页查询（常用）</h2><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。</p>\n<h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><p>select 参数列表<br>from 表<br>left join 表名 on 连接条件<br>where 筛选条件<br>group by 分组字段 having 分组后筛选<br>order by 排序字段<br>limit 【offset,】 size；</p>\n<p>offset 要显示条目的起始索引（起始索引从0开始）<br>size 要显示的条目个数<br>特点：limit语句放在查询语句的最后</p>\n<h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>查询第二页，一页10条记录<br>Select * from user limit 10, 10;</p>\n<h2 id=\"Union联合查询\"><a href=\"#Union联合查询\" class=\"headerlink\" title=\"Union联合查询\"></a>Union联合查询</h2><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>\n<p>应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>查询语句1<br>union<br>查询语句2<br>union<br>….</p>\n<p>特点：<br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以包含重复项</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--Union all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"DML语言\"><a href=\"#DML语言\" class=\"headerlink\" title=\"DML语言\"></a>DML语言</h1><p>数据库操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p>\n<h2 id=\"插入语句\"><a href=\"#插入语句\" class=\"headerlink\" title=\"插入语句\"></a>插入语句</h2><h3 id=\"方式1\"><a href=\"#方式1\" class=\"headerlink\" title=\"方式1\"></a>方式1</h3><p>语法：<br>Inser into 表名(列名, …) values(值1, …);</p>\n<p>使用：<br>INSERT INTO users VALUES(1, ‘欧阳荣’, ‘男’, 166842.5);<br>INSERT INTO users(id, NAME, sex, gz) VALUES(2, ‘赵云彬’, ‘欧阳荣’, NULL);</p>\n<h3 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h3><p>语法：<br>insert into 表名 set 列名=值,列名=值,….;</p>\n<p>使用：<br>INSERT INTO boys SET id=6, boyName=’侄子’, userCp=147258;</p>\n<h3 id=\"两种开发方式pk\"><a href=\"#两种开发方式pk\" class=\"headerlink\" title=\"两种开发方式pk\"></a>两种开发方式pk</h3><p>insert方式一次可以加多条，第二种方式不行<br>INSERT INTO boys VALUES(7, ‘欧阳荣’, 10000000), (8, ‘欧阳荣’, 10000000);</p>\n<p>insert方式可以用子查询<br>INSERT INTO boys SELECT 10, ‘ii’, 150044;</p>\n<h2 id=\"修改语句\"><a href=\"#修改语句\" class=\"headerlink\" title=\"修改语句\"></a>修改语句</h2><h3 id=\"修改单表的记录（常用）\"><a href=\"#修改单表的记录（常用）\" class=\"headerlink\" title=\"修改单表的记录（常用）\"></a>修改单表的记录（常用）</h3><p>语法：<br>Update 表名 set 列=新值, 列=新值…. where 筛选条件;</p>\n<p>案例：<br>修改beauty表中姓唐的女神电话为1389988889<br>UPDATE beauty SET phone=’1389988889’ WHERE NAME LIKE ‘唐%’;</p>\n<p>修改boys表中id号为2的名称为张飞，魅力值10<br>UPDATE boys SET boyName=’张飞’, userCP=10 WHERE id=2;</p>\n<p>4.2.2.修改多表的记录（补充）<br>192语法：<br>UPDATE 表名 别名,表名 别名<br>SET 列=值,列=值 …<br>WHERE 连接添加 AND 筛选条件</p>\n<p>199语法:<br>UPDATE 表名 别名<br>INNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件<br>SET 列=值，列=值 …<br>WHERE 筛选条件</p>\n<p>案例（以下实现都为199语法）：</p>\n<p>修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.id=b.boyfriend_id<br>SET phone=’114’<br>WHERE bo.boyName=’张无忌’;</p>\n<p>修改没有男朋友的女神的男朋友的编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.id=b.boyfriend_id<br>SET b.boyfriend_id=2<br>WHERE bo.id IS NULL;</p>\n<p>4.3.删除语句</p>\n<p>4.3.1.方式1：delete<br>语法：<br>（1）单表删除（重要）：<br>Delete from 表名 where 筛选条件;</p>\n<p>（2）多表删除（补充）<br>192：<br>Delete 表1别名, 表2别名<br>from 表一 别名, 表二别名<br>Where 连接条件 and 筛选条件</p>\n<p>199：<br>Delete 表1别名, 表2别名<br>From 表一 别名<br>inner|Left|right| join 表2 别名 on 连接条件<br>Where 筛选条件</p>\n<p>案例：</p>\n<p>删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE ‘%9’;</p>\n<p>删除张无忌的女朋友的信息<br>DELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id<br>WHERE bo.<code>boyName</code>=’张无忌’;</p>\n<p>删除黄晓明的信息以及他女朋友的信息<br>DELETE b, bo FROM boys bo<br>INNER JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p>\n<p>4.3.2.方式2：truncate<br>语法：<br>Truncate table 表名;</p>\n<p>特点：<br>不能加筛选条件，也叫做清空。</p>\n<p>4.3.3.delete pk truncate（面试题）</p>\n<p>1.delete可以加where条件，truncate不可以<br>2.truncate删除，效率高一丢丢<br>3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。<br>如果使用truncate删除后，再插入值，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值<br>5.truncate删除不能回滚，delete删除可以回滚。</p>\n<p>5.DDL语言<br>数据库定义语言，也就是库和表的管理</p>\n<p>5.1.库的管理</p>\n<p>5.1.1.库的创建</p>\n<p>语法：<br>create database [if not exists] 库名 [character set 字符集]</p>\n<p>案例：</p>\n<p>创建一个db_book库<br>CREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;</p>\n<p>5.1.2.库的修改</p>\n<p>修改库名（现在不能用了）：<br>语法：<br>rename database 库名 to 新库名;</p>\n<p>案例<br>把db_oyr库名改成my_oyr<br>RENAME DATABASE db_oyr TO my_oyr;</p>\n<p>修改字符集：<br>语法：<br>alert database 库名 character set 字符集;</p>\n<p>案例：</p>\n<p>修改db_oyr的字符集为gbk<br>ALTER DATABASE db_oyr CHARACTER SET gbk;</p>\n<p>5.1.3.库的删除</p>\n<p>语法：<br>DROP DATABASE [IF EXISTS] 库名;</p>\n<p>案例:<br>删除db_oyr<br>DROP DATABASE db_oyr; </p>\n<p>5.2.表的管理</p>\n<p>5.2.1.表的创建</p>\n<p>语法：<br>create table 表名(<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    …<br>    列名 列类型【（类型长度） 约束】<br>);</p>\n<p>案例：<br>创建book表<br>CREATE TABLE book(<br>    id INT,#编号<br>    bName VARCHAR(20),#图书名<br>    price DOUBLE,#价格<br>    authorId INT,#作者编号<br>    publishDate DATETIME#出版日期<br>);</p>\n<p>5.2.2.表的修改</p>\n<p>语法：<br>Alter table 表名 add|drop|modify|change column 列名 【列类型 约束】</p>\n<p>（1）修改列名</p>\n<p>ALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);</p>\n<p>（2）修改列的类型或约束</p>\n<p>ALTER TABLE my_book MODIFY COLUMN myName INT;</p>\n<p>（3）添加新列</p>\n<p>ALTER TABLE book ADD COLUMN oo VARCHAR(20);</p>\n<p>（4）删除列</p>\n<p>ALTER TABLE book DROP COLUMN oo;</p>\n<p>（5）修改表名</p>\n<p>ALTER TABLE book RENAME TO my_book;</p>\n<p>5.2.3.表的删除</p>\n<p>语法：<br>DROP TABLE 【IF EXISTS】 表名;</p>\n<p>案例：</p>\n<p>删除my_book表<br>DROP TABLE IF EXISTS my_book;</p>\n<p>5.2.4.表的复制<br>1)复制表的结构<br>语法：<br>Create table 新表名 like 被复制的表名;</p>\n<p>复制boys的结构<br>CREATE TABLE copy LIKE boys;</p>\n<p>2)复制表的结构和数据<br>语法：<br>Create table 新表名<br>Select * from 被复制表的表名</p>\n<p>复制boys表的结构和数据<br>CREATE TABLE copy2<br>SELECT * FROM boys;</p>\n<p>复制boys部门数据和部分列<br>CREATE TABLE copy3<br>SELECT id,boyName FROM boys WHERE id&lt;5;<br>SELECT * FROM copy3;</p>\n<p>复制几个字段的结构<br>CREATE TABLE copy4<br>SELECT id, boyName FROM boys<br>WHERE 1=2;</p>\n<p>5.3.常见的约束</p>\n<p>5.3.1.约束介绍</p>\n<p>六大约束：<br>NOT NULL：非空约束，用于保证该字段的值不能为空<br>UNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空<br>PRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空<br>CHEACK：检查约束【MYSQL中不支持，没有效果】<br>FOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值<br>DEFAULT：默认值，用于保证字段有默认值</p>\n<p>添加约束的时机：<br>创建表时<br>修改表时</p>\n<p>约束的添加分类：<br>列级约束：<br>六大约束语法上都支持，单外检约束没有效果<br>表级约束：<br>除了非空，默认，其他都支持</p>\n<p>列级约束 VS 表级约束<br>位置            支持的约束类型                    是否可以起别名<br>列级：    列的后面        都支持，但外键没有效果            不可以<br>表级：    所有列的下面    默认和非空不支持，其他都支持    可以主键（没有效果）</p>\n<p>5.3.2.添加列级约束</p>\n<p>新建一个库students，在里面测试添加列级约束</p>\n<h1 id=\"新建主修表\"><a href=\"#新建主修表\" class=\"headerlink\" title=\"新建主修表\"></a>新建主修表</h1><p>create table major(<br>    id bigint(20) primary key, #主键约束<br>    major_name varchar(25) NOT NULL #非空约束<br>)</p>\n<h1 id=\"新建学生表\"><a href=\"#新建学生表\" class=\"headerlink\" title=\"新建学生表\"></a>新建学生表</h1><p>create table student(<br>    id bigint(20) primary key, #主键约束<br>    stu_name varchar(25) NOT NULL, #非空约束<br>    sex char(2) CHECK(sex = ‘男’ or sex = ‘女’), #检查约束<br>    age int default 20, #默认约束<br>    card varchar(25) unique,#唯一约束<br>    major_id bigint(20) REFERENCES major(id) #外键约束<br>)</p>\n<p>经过测试后发现，检查约束是无效的，而且外检约束也是无效的。<br>其他都是ok的。</p>\n<p>5.3.3.添加表级约束</p>\n<p>语法：<br>在表字段的最下面<br>[constraint 约束名] 约束类型(字段名)<br>表级约束添加外键是有效的。</p>\n<p>指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效<br>  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束<br>CONSTRAINT ch_sex CHECK(sex = ‘女’ or sex =’男’),<br>  CONSTRAINT <code>pk_student_major</code> FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>不指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  PRIMARY KEY(id), #主键，约束名不生效<br>  UNIQUE KEY(card), #唯一约束<br>    CHECK(sex = ‘女’ or sex =’男’),<br>  FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>5.3.4.主键约束 VS 唯一约束</p>\n<p>保证唯一性    是否允许为空    一个表中有几个    是否允许出现组合<br>主键        √            ×                最多一个        √，但不推荐<br>唯一        √            ×                可以多个        √，但不推荐</p>\n<p>唯一约束可以允许为空，但null只能出现一次。<br>组合就是组合主键或组合唯一约束。</p>\n<p>5.3.5.外键的特点</p>\n<p>从表：当前表<br>主表：被关联的表</p>\n<p>1.要求在从表中设置外键关系<br>2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）<br>4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表</p>\n<p>5.3.6.修改表时添加约束</p>\n<p>语法：<br>1.添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束</p>\n<p>2.添加表级约束<br>alter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]</p>\n<p>添加非空约束：<br>列级：<br>alter table student modify column stu_name varchar(25) not null;</p>\n<p>添加默认约束：<br>列级：<br>alter table student modify column age int default 20</p>\n<p>添加主键约束：<br>列级：<br>alter table student modify column id bigint(20) primary key<br>表级：<br>alter table student add primary key(id)</p>\n<p>添加唯一约束：<br>列级：<br>alter table student modify column card varchar(25) unique<br>表级：<br>alter table student add constraint un_card unique(card)</p>\n<p>添加外键约束：<br>表级：<br>alter table student add constraint fk_student_major foreign key(id) references major(id)</p>\n<p>5.3.7.修改表时删除约束</p>\n<p>1.删除非空约束（直接不写就是删除）<br>alter table student modify column stu_name varchar(25)</p>\n<p>2.删除默认约束（不写即是删除）<br>alter table student modify column age int default 20</p>\n<p>3.删除主键约束<br>aler table 表名 drop primary key</p>\n<p>4.删除唯一约束<br>alter table 表名 drop index 约束名</p>\n<p>5.删除外键约束<br>alter table 表名 drop foreign key 约束名</p>\n<p>5.4.标识列</p>\n<p>什么是标识列？<br>标识列是自增长列<br>含义：可以不手动的插入值，系统提供默认的序列值</p>\n<p>特点：<br>1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）<br>2.一个表只能有一个标识列<br>3.标识类的类型只能是数值型<br>4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值</p>\n<p>创建表时设置标识列<br>create table tb_user(<br>    id int primary key auto_increment, #主键并且设置标识列<br>    name varchar(25) not null<br>)</p>\n<p>修改表时设置标识列<br>alter table tb_user modify column id int primary key auto_increment</p>\n<p>修改表时删除标识列<br>alter table tb_user modify column id int primary key</p>\n<p>6.TCL 语言<br>TCL：Transaction Control Language 事物控制语言</p>\n<p>事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>\n<p>6.1.MySQL 中的存储引擎</p>\n<p>1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。<br>2、通过show engines；来查看mysql支持的存储引擎。<br>3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>\n<p>6.2.事务的ACID属性</p>\n<ol>\n<li><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。</p>\n</li>\n<li><p>一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。</p>\n</li>\n<li><p>隔离性（Isolation）<br>并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。</p>\n</li>\n<li><p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>\n</li>\n</ol>\n<p>6.3.事物的使用步骤</p>\n<p>事物又分两种：隐式事物和显式事物<br>隐式事物：事物没有明显的开启和结束的标记<br>列如insert，update，delete</p>\n<p>显式事物：事物具有明显的开启和结束的标记<br>前提：必须设置自动提交功能为禁用</p>\n<p>查看当前自动提交功能开关<br>show variables like ‘autocommit’</p>\n<p>关闭自动提交功能，并不是永久的，只是当前回话被关闭<br>set autocommit=0;</p>\n<p>开启事物的语法：<br>#步骤1：开启事物<br>set autocommit=0;<br>start transaction;#开启事物，可选的<br>#步骤2：编写事物中的sql语句（select insert update delete）<br>语句1;<br>语句2;<br>…….<br>#步骤3：结束事物<br>commit;#提交事物<br>rollback;回滚事物</p>\n<p>实战操作：<br>初始化<br>create table account(<br>    id bigint(20) primary key auto_increment,<br>    acc_name varchar(25),<br>    money double<br>)<br>INSERT INTO account (id, acc_name, money) VALUES (1, ‘欧阳荣’, 1500);<br>INSERT INTO account (id, acc_name, money) VALUES (2, ‘罗总’, 500);</p>\n<p>转账成功提交：执行后可以看到数据库数据已经改变了<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>commit;</p>\n<p>转账失败回滚：执行后会发现数据并没有改变<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>rollback;</p>\n<p>6.4.数据库的隔离级别</p>\n<p>6.4.1.并发问题</p>\n<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>\n<p>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段.<br>之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p>\n<p>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段.<br>之后, T1再次读取同一个字段, 值就不同了.</p>\n<p>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插<br>入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。</p>\n<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>\n<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p>\n<p>6.4.2.四种事务隔离级别</p>\n<p>Oracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。</p>\n<p>Mysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。</p>\n<p>6.5.回滚点使用（savepotion）</p>\n<p>set autocommit=0;#设置不自动提交<br>start transaction;#开启事物<br>delete form account where id=1;<br>savepoint a;#保存点<br>delete from account where id=2;<br>rollback to a;#回滚到保存点<br>这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。</p>\n<p>7.视图<br>7.1.什么是视图</p>\n<p>含义：虚拟表，和普通表一样使用<br>MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</p>\n<p>应用场景：<br>1.多个地方用到同样的查询结果<br>2.该查询结果使用的sql语句较复杂</p>\n<p>7.2.视图的创建</p>\n<p>语法：<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>OR REPLACE：表示替换已有视图</p>\n<p>ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表</p>\n<p>[WITH [CASCADED | LOCAL] CHECK OPTION]：<br>表示视图在更新时保证在视图的权限范围之内<br>cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件<br>local表示更新视图的时候，要满足该视图定义的一个条件即可<br>推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 </p>\n<p>实际操作：</p>\n<p>1.查询邮箱中包含a字符的员工名，部门名，工种信息<br>– 创建视图<br>create view view_test1<br>AS<br>SELECT<br>    CONCAT(e.first_name, e.last_name) 员工名,<br>    dept.department_name 部门名,<br>    j.job_title 工种信息<br>FROM<br>    employees e<br>LEFT JOIN departments dept ON dept.department_id = e.department_id<br>LEFT JOIN jobs j ON j.job_id = e.job_id<br>where email LIKE ‘%a%’<br>– 查询视图<br>select * from view_test1</p>\n<p>2.查询各部门的平均工资级别<br>create view view_test2<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name</p>\n<p>SELECT<br>    vt.dept_name,<br>    jb.grade_level<br>FROM<br>    view_test2 vt<br>LEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal<br>AND jb.highest_sal</p>\n<p>3.查询平均工资最低的部门<br>create view view_test3<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>4.查询平均工资最低的部门名和工资<br>create view view_test4<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>视图的好处：<br>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>\n<p>7.3.视图的修改</p>\n<p>方式一：如果存在，则覆盖<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>方式二：指定修改视图<br>alter<br>[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>    [DEFINER = { user | CURRENT_USER }]<br>    [SQL SECURITY { DEFINER | INVOKER }]<br>view 视图名<br>as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION];</p>\n<p>方式一实际操作：<br>create or replace view view_test4<br>as<br>select * from employees where employee_id &gt; 105</p>\n<p>方式二实际操作：<br>alter view view_test4<br>as<br>select * from employees where employee_id &gt; 120</p>\n<p>7.4.视图的删除</p>\n<p>语法：<br>drop view 视图名,视图名,视图名……..</p>\n<p>实际操作：<br>drop view view_test4, view_test3</p>\n<p>7.5.查看视图<br>方式1：desc 视图名</p>\n<p>方式2：show create view 视图名</p>\n<p>方式1实际操作：<br>desc view_test2</p>\n<p>可以看到实际上能看到的是当前视图可以查询出的字段信息</p>\n<p>方式2实际操作：<br>show create view view_test2</p>\n<p>可以看到的是当前拿到的是创建视图的逻辑sql。</p>\n<p>7.6.视图VS表</p>\n<p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view            只是保存了逻辑sql        增删改查，一般不能增删改查</p>\n<p>表        create table            保存了数据                增删改查</p>\n<p>8.变量</p>\n<p>8.1.系统变量</p>\n<p>说明：变量由系统提供的，不是银行定义，属于服务器层面<br>系统变量又可以细分为全局变量和局部变量</p>\n<p>使用的语法：<br>1.查看所有的系统变量<br>show global|[session] variables</p>\n<p>2.查看满足条件的部分系统变量<br>show global | [session] variables like ‘%char%’;</p>\n<p>3.查看指定的某个系统变量的值<br>select @@global | [session] .系统变量名</p>\n<p>4.为某个系统变量赋值<br>方式一：<br>set global | [session] 系统变量名 = 值;</p>\n<p>方式二：<br>Set @@global | [session] .系统变量名 = 值;</p>\n<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别</p>\n<p>8.1.1.全局变量实际操作</p>\n<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）</p>\n<p>（1）查看所有的全局变量<br>show global variables;</p>\n<p>（2）查看部分的全局变量<br>show global variables like ‘%char%’;</p>\n<p>（3）查看指定的全局变量的值<br>select @@global.autocommit;</p>\n<p>（4）为某个指定的全局变量赋值<br>set @@global.autocommit = 0;</p>\n<p>8.1.2.局部变量实际操作</p>\n<p>作用域：仅仅针对于当前会话（连接）有效</p>\n<p>（1）查看所有的会话变量<br>show variables<br>show session variables</p>\n<p>（2）查看部分的会话变量<br>show variables like ‘%char%’<br>show session variables like ‘%char%’</p>\n<p>（3）指定查看某个会话变量<br>select @@character_set_client<br>select @@session.character_set_client</p>\n<p>（4）为某个会话变量赋值<br>set autocommit=0<br>set @@session.autocommit=1</p>\n<p>8.2.自定义变量</p>\n<p>说明：变量是用户自定义的，不是由系统自动生成的。<br>自定义变量又可以细分成用户变量（当前会话有效），局部变量<br>使用步骤：<br>声明<br>赋值<br>使用（查看，比较，运算等）</p>\n<p>8.2.1.用户变量</p>\n<p>作用域：针对于电器干会话（连接）有效，同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end外面</p>\n<p>使用语法：</p>\n<p>（1）声明并初始化：<br>set @用户变量名=值 或<br>set @用户变量名:=值 或<br>select @用户变量名:=值</p>\n<p>（2）赋值（更新用户变量的值）<br>方式一：通过set和select<br>set @变量名=值 或<br>set @变量名:=值 或<br>select @变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO @变量名<br>from 表</p>\n<p>（3）使用（查看用户变量的值）<br>select @用户变量名</p>\n<p>实际操作：</p>\n<p>声明并且初始化：</p>\n<h1 id=\"声明并且初始化\"><a href=\"#声明并且初始化\" class=\"headerlink\" title=\"声明并且初始化\"></a>声明并且初始化</h1><p>set @name=’欧阳荣’;<br>set @name:=10;<br>select @name:=’罗总’;</p>\n<p>赋值：<br>#赋值<br>set @count = 10;<br>set @count := 15;<br>select @count := 20;<br>select count(*) into @count from account;</p>\n<p>使用：<br>select @count;</p>\n<p>8.2.2.局部变量</p>\n<p>作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句</p>\n<p>（1）声明<br>declare 变量名 类型;<br>declare 变量名 类型 default 值;</p>\n<p>（2）赋值<br>方式一：通过set和select<br>set 局部变量名=值 或<br>set 局部变量名:=值 或<br>select @局部变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO 局部变量名<br>from 表</p>\n<p>（3）使用<br>select 局部变量名</p>\n<p>8.2.3.用户变量 VS 局部变量</p>\n<p>作用域        定义和使用的位置                语法<br>用户变量    当前会话    会话中的任何地方                必须加@符，不限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句    不用加@符，需要限定类型</p>\n<p>9.存储过程和函数<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p>\n<p>9.1.存储过程</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>9.1.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create procedure 存储过程名(参数列表)<br>begin<br>存储过程体（一组合法的SQL语句）<br>end</p>\n<p>注意：<br>1.参数列表包含三部分<br>参数模式    参数名    参数类型<br>in            student    varchar(20)</p>\n<p>参数模式：<br>in：    该参数可以作为输入，也就是该参数需要调用方法传入值<br>out：    该参数可以作为输出，也就是该参数可以作为返回值<br>inout：    该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值</p>\n<p>2.如果存储过程体仅仅只有一句话，begin end可以省略。<br>存储过程的每条SQL语句的结尾要求必须加上分号。<br>存储过程的结尾可以使用delimiter重新设置<br>语法：<br>DELIMITER 结束标记<br>DELIMITER $</p>\n<p>调用语法：<br>CALL 存储过程名（实参列表）</p>\n<p>查看语法：<br>show create procedure 存储过程名;</p>\n<p>删除语法：<br>drop procedure 存储过程名;</p>\n<p>9.1.2.存储过程实战</p>\n<p>（1）空参的存储过程：</p>\n<h1 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1()<br>begin<br>    insert into admin(name, money) values(‘z1’, 11), (‘z2’, 22), (‘z3’, 33), (‘z4’, 44), (‘z5’, 55);<br>end;</p>\n<p>#调用存储过程<br>CALL myp1();</p>\n<p>带in模式参数的存储过程：<br>根据女神名获取男神信息</p>\n<h1 id=\"创建存储过程-1\"><a href=\"#创建存储过程-1\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1(in beauty_name varchar(25))<br>begin<br>    select bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<h1 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h1><p>call myp1(‘赵敏’)</p>\n<p>根据用户名和密码判断是否能登录成功<br>– 创建存储过程<br>create procedure myp2(in username varchar(25), in password varchar(25))<br>begin<br>    declare result int default ‘0’;<br>    select count(*) INTO result from admin a where a.username = username and a.<code>password</code> = password;<br>    select if(result &gt; 0, ‘成功’, ‘失败’);<br>end;<br>– 调用<br>call myp2(‘john’, ‘8888’)</p>\n<p>（2）带out模式的存储过程：</p>\n<p>根据女神名，返回对应的男神名<br>#创建<br>create procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))<br>begin<br>    select bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;<br>– 调用<br>set @boy_name=’’;<br>call myp3(‘赵敏’, @boy_name);<br>select @boy_name;</p>\n<p>根据女神名，返回对应的男神名和男神魅力值<br>创建<br>create procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)<br>begin<br>    select bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<p>– 调用<br>set @boy_name=’’;<br>set @user_cp=0;<br>call myp4(‘赵敏’, @boy_name, @user_cp);<br>select @boy_name, @user_cp;</p>\n<p>（3）带inout模式参数的存储过程</p>\n<p>传入a和b两个值，最终a和b都翻倍并返回<br>#创建<br>create procedure myp5(inout x int, inout y int)<br>begin<br>    set x = x<em>2;<br>    set y = y</em>2;<br>end;<br>#调用<br>set @x = 10;<br>set @y = 20;<br>call myp5(@x, @y);<br>select @x, @y;</p>\n<p>9.2.函数</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>存储过程与函数的区别：<br>存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新<br>函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果</p>\n<p>9.2.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create function 函数名(参数列表) returns 返回类型<br>begin<br>函数体<br>end</p>\n<p>注意：<br>1.参数列表包含两部分：参数名 参数类型<br>2.函数体：肯定会有return语句，如果没有会报错。<br>如果return语句没有放在函数体的最后也不报错，但不建议。<br>3.函数体重仅有一句话，则可以省略begin end<br>4.使用delimiter语句设置结束标记</p>\n<p>调用语法：<br>select 函数名（参数列表）</p>\n<p>查看语法：<br>show create function 函数名</p>\n<p>删除语法：<br>dorp function 函数名</p>\n<p>9.2.2.函数实战</p>\n<p>（1）无参有返回</p>\n<p>返回公司的员工个数：<br>#创建<br>create function myf1() returns int<br>begin<br>    declare count int default 0;<br>    select COUNT(*) into count from employees;<br>    return count;<br>end;<br>#调用<br>select myf1();</p>\n<p>（2）有参返回</p>\n<p>根据员工名返回工资：<br>#创建<br>create function myf2(username varchar(25)) returns double<br>begin<br>    declare money double default 0;<br>    select salary into money from employees where last_name = username;<br>    return money;<br>end;<br>#调用<br>select myf2(‘Kochhar’);</p>\n<p>根据部门名，发挥该部门的平均工资<br>#创建<br>create function myf3(dept_name varchar(25)) returns double<br>begin<br>    declare ave_salary double default 0;<br>    select avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id<br>    where dept.department_name = dept_name group by dept.department_id;<br>    return ave_salary;<br>end;<br>#调用<br>select myf3(‘Adm’);</p>\n<p>实现传入两个float，返回两者之和：</p>\n<p>#创建<br>create function myf1(x float, y float) returns float<br>begin<br>    declare sum float default 0;<br>    set sum = x + y;<br>    return sum;<br>end;<br>#调用<br>select myf1(1, 5.1);</p>\n<p>（3）查看函数<br>show create function myf3;</p>\n<p>（4）删除函数<br>drop function myf3</p>\n<p>10.流程控制结构<br>顺序结构：程序从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上重复执行一段代码</p>\n<p>10.1.分支结构</p>\n<p>（1）if函数<br>功能：实现简单的双分支<br>语法：<br>If(表达式1, 表达式2, 表达式3)<br>执行顺序：<br>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值<br>应用：任何地方<br>实战操作：<br>select if(1 &gt; 2, 1, 2)<br>当前sql执行后会返回2</p>\n<p>（2）case结构</p>\n<p>在begin end 外面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 返回的值1<br>when 要判断的值 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 返回的值1<br>when 要判断的条件2 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>在begin end里面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 要执行的语句1<br>when 要判断的值 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 要执行的语句1<br>when 要判断的条件2 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create procedure show_grade(in grade int)<br>begin<br>    declare result varchar(2);<br>    CASE<br>    WHEN grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    WHEN grade&gt;=80 THEN set result = ‘B’;<br>    WHEN grade&gt;=60 THEN set result = ‘C’;<br>    ELSE set result = ‘D’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>CALL show_grade(99);</p>\n<p>#根据传递的数据库类型，显示对应的数据库名<br>create procedure show_database_type(in val int)<br>begin<br>    declare result varchar(20);<br>    CASE val<br>    WHEN 1 THEN set result = ‘mysql’;<br>    WHEN 2 THEN set result = ‘oracle’;<br>    WHEN 3 THEN set result = ‘sql server’;<br>    ELSE set result = ‘不认识的类型，滚啊。。。’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>call show_database_type(1);</p>\n<p>（3）if结构<br>功能：实现多重分类<br>语法：<br>if 条件1 then 语法1;<br>esleif 条件2 then 语法2;<br>…<br>[else 语句n;]<br>end if;</p>\n<p>应用场景：应用在begin end中</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create function show_grade(grade int) returns char(1)<br>begin<br>    declare result char(1);<br>    if grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    elseif grade&gt;=80 THEN set result = ‘B’;<br>    elseif grade&gt;=60 THEN set result = ‘C’;<br>    else set result = ‘D’;<br>    end if;<br>    return result;<br>end;</p>\n<p>select show_grade(55);</p>\n<p>#批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>create procedure pro_while_insert2(in count int)<br>begin<br>    declare i int default 1;<br>    a:while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        if i&gt;=20 then leave a;<br>        end if;<br>        set i=i+1;<br>    end while a;<br>end;</p>\n<p>call pro_while_insert2(30);</p>\n<p>10.2.循环结构</p>\n<p>循环分类：<br>while、 loop、repeat</p>\n<p>循环控制：<br>iterate类似于continue，结束本次循环，继续下一次循环<br>leave类似于break，结束当前所在循环。</p>\n<p>三种循环语法：</p>\n<p>（1）while<br>[标签:] while 循环条件 do<br>循环体<br>end while [标签]</p>\n<p>（2）loop<br>[标签:] loop<br>循环体<br>end loop [标签]</p>\n<p>（3）repeat<br>[标签:] repeat<br>循环体<br>until 结束循环的条件<br>end repeat [标签]</p>\n<p>循环实战操作：</p>\n<p>#批量插入，根据次数插入到amdin表中多条数据<br>create procedure pro_while_insert(in count int)<br>begin<br>    declare i int default 1;<br>    while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        set i=i+1;<br>    end while;<br>end;</p>\n<p>call pro_while_insert(10);</p>\n<p>while VS repeat VS loop<br>while：先判断后执行<br>repeat：先执行后判断<br>loop：没有条件的死循环</p>\n<h1 id=\"博客园所学\"><a href=\"#博客园所学\" class=\"headerlink\" title=\"博客园所学\"></a>博客园所学</h1><h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.<br>单列索引:一个索引只包含一个列,一个表可以有多个单列索引.<br>组合索引:一个组合索引包含两个或两个以上的列。</p>\n<h3 id=\"索引的创建\"><a href=\"#索引的创建\" class=\"headerlink\" title=\"索引的创建\"></a>索引的创建</h3><p>1）单列索引</p>\n<p>普通索引：<br>第一种方式 :<br>CREATE INDEX 索引名ON 表名(<code>字段名</code>(length))</p>\n<p>第二种方式: <br>ALTER TABLE award ADD INDEX account_Index(<code>account</code>)</p>\n<p>唯一索引：<br>CREATE UNIQUE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length));<br>ALTER TABLE TableName ADD UNIQUE (column_list)</p>\n<p>主键索引：不允许有空值</p>\n<p>2）组合索引：</p>\n<p>语法：<br>CREATE INDEX IndexName On <code>TableName</code>(<code>字段名</code>(length),<code>字段名</code>(length),…);</p>\n<h3 id=\"索引的删除\"><a href=\"#索引的删除\" class=\"headerlink\" title=\"索引的删除\"></a>索引的删除</h3><p>语法：<br>DORP INDEX IndexName ON <code>TableName</code></p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>触发器：监视某种情况，并触发某种操作。</p>\n<h3 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h3><p>触发器创建语法四要素：1.监视地点(table)<br>　　　　　　　　　　　2.监视事件(insert/update/delete)<br>　　　　　　　　　　 3.触发时间(after/before)<br>　　　　　　　　　　　4.触发事件(insert/update/delete)</p>\n<p>语法：<br>create trigger triggerName after/before insert/update/delete<br>on 表名 for each row #这句话是固定的<br> begin<br>     #需要执行的sql语句<br> end<br>注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发<br>注意2:insert/update/delete:只能选一个</p>\n<p>创建一个视图：<br>create trigger tag1 after insert on order_table<br>for each row<br>begin<br>    update goods set num=num-3 where id=1;<br>end;</p>\n<p>我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。<br>对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。<br>所以现在我们可以这样来改我们的触发器:<br>create trigger tg1 after insert on order_table<br>for each row<br>BEGIN<br>    update goods set num = num-new.much where id=new.gid;<br>END;</p>\n<p>当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？<br> 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。<br>create trigger tg2 after delete on order_table<br>for each ROW<br>BEGIN<br>    update goods set num = num+old.much where id=old.gid;<br>END;</p>\n<h3 id=\"删除触发器\"><a href=\"#删除触发器\" class=\"headerlink\" title=\"删除触发器\"></a>删除触发器</h3><p>语法：drop trigger 触发器名称;<br>使用：drop trigger dg1;</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckqcfpmjf0001howm27ymayqm","category_id":"ckqcfpmji0004howm0jvn2kyh","_id":"ckqcfpmjl000ahowm7gij1tls"},{"post_id":"ckqcfpmjh0003howm2fbcfsy1","category_id":"ckqcfpmjk0007howm88q04ed4","_id":"ckqcfpmjl000chowm8k3a1if7"},{"post_id":"ckqcfpmjn000ehowmfqg73yzt","category_id":"ckqcfpmjk0007howm88q04ed4","_id":"ckqcfpmjp000lhowmdi6rb918"},{"post_id":"ckqcfpmjo000hhowmfl7y1nzi","category_id":"ckqcfpmjk0007howm88q04ed4","_id":"ckqcfpmjq000phowmb3t14dv1"},{"post_id":"ckqcfpmjm000dhowm7avefaes","category_id":"ckqcfpmjo000fhowmhdwzawd2","_id":"ckqcfpmjq000qhowmh3ko2af2"},{"post_id":"ckqcfpmjo000jhowm3bze2s9m","category_id":"ckqcfpmjp000mhowm082w0j12","_id":"ckqcfpmjq000showmebuk8v14"},{"post_id":"ckqcfpmk9000thowmge1723lh","category_id":"ckqcfpmka000uhowm7g6l34em","_id":"ckqcfpmka000xhowmfiia8kwn"},{"post_id":"ckqcfpmkh000yhowm9vc8cx2l","category_id":"ckqcfpmjp000mhowm082w0j12","_id":"ckqcfpmki0010howmcnhj9bvh"}],"PostTag":[{"post_id":"ckqcfpmjf0001howm27ymayqm","tag_id":"ckqcfpmjj0005howm3ua18azm","_id":"ckqcfpmjk0009howm7n6yhbv7"},{"post_id":"ckqcfpmjh0003howm2fbcfsy1","tag_id":"ckqcfpmjk0008howm7fy71o95","_id":"ckqcfpmjl000bhowmbygy7cx3"},{"post_id":"ckqcfpmjn000ehowmfqg73yzt","tag_id":"ckqcfpmjk0008howm7fy71o95","_id":"ckqcfpmjo000ihowm10h6cdtx"},{"post_id":"ckqcfpmjo000hhowmfl7y1nzi","tag_id":"ckqcfpmjk0008howm7fy71o95","_id":"ckqcfpmjp000khowmago40t60"},{"post_id":"ckqcfpmjm000dhowm7avefaes","tag_id":"ckqcfpmjo000ghowm5wyggxwk","_id":"ckqcfpmjq000ohowmhl2n0dlj"},{"post_id":"ckqcfpmjo000jhowm3bze2s9m","tag_id":"ckqcfpmjp000nhowmf1c74r9p","_id":"ckqcfpmjq000rhowmfhkrfwd8"},{"post_id":"ckqcfpmk9000thowmge1723lh","tag_id":"ckqcfpmka000vhowmeix927t8","_id":"ckqcfpmka000whowm37zz4s67"},{"post_id":"ckqcfpmkh000yhowm9vc8cx2l","tag_id":"ckqcfpmjp000nhowmf1c74r9p","_id":"ckqcfpmki000zhowmguvcal5v"}],"Tag":[{"name":"hexo","_id":"ckqcfpmjj0005howm3ua18azm"},{"name":"MQ","_id":"ckqcfpmjk0008howm7fy71o95"},{"name":"Markdown","_id":"ckqcfpmjo000ghowm5wyggxwk"},{"name":"MySQL","_id":"ckqcfpmjp000nhowmf1c74r9p"},{"name":"Dubbo","_id":"ckqcfpmka000vhowmeix927t8"}]}}